<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>SQL Notepad</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
:root {
  --bg:#0f172a;
  --bg2:#0b1327;
  --panel:#0d1326;
  --editor:#0b1020;
  --fg:#e5e7eb;
  --muted:#94a3b8;
  --border:#1f2a44;
  --accent:#d9534f;
  --accent-hover:#c9302c;
  --pill:#111827;
}
[data-theme="light"] {
  --bg:#f8fafc;
  --bg2:#eef2f7;
  --panel:#ffffff;
  --editor:#ffffff;
  --fg:#0f172a;
  --muted:#475569;
  --border:#d1d5db;
  --accent:#0ea5e9;
  --accent-hover:#0284c7;
  --pill:#e5e7eb;
}

* { box-sizing: border-box; }
html, body { height: 100%; }
body {
  font-family: Arial, sans-serif;
  display: grid;
  /* 4 rows: header, menubar, toolbar (.bar), content (.wrap) */
  grid-template-rows: auto auto auto 1fr;
  background: var(--bg);
  color: var(--fg);
  min-height: 100vh;
}

/* When interface is hidden, drop the bar row (header + menubar + content) */
body.interface-hidden { grid-template-rows: auto auto 1fr; }

header {
  padding: 16px 20px;
  background: var(--bg);
  border-bottom: 1px solid var(--border);
}
body.interface-hidden header { padding: 6px 12px; }
header h1 { margin: 0 0 6px; font-size: 20px; }
header p { margin: 0; font-size: 14px; color: var(--muted); min-height: 1.4em; }
kbd {
  background: var(--pill);
  border: 1px solid var(--border);
  border-bottom-width: 2px;
  border-radius: 6px;
  padding: 2px 6px;
  font-family: inherit;
  font-size: 12px;
  color: var(--fg);
}

/* ===== Toolbar (.bar) ===== */
.bar {
  grid-row: 3;                 /* sits on the 3rd (auto) row */
  display:flex; gap:8px; align-items:center;
  padding:8px 20px;
  background: var(--bg2); color: var(--fg);
  border-bottom:1px solid var(--border);
  height:auto;                 /* ensure intrinsic height */
  line-height:1.2;
  flex-wrap: wrap;
}
body.interface-hidden .bar { display:none; }

.bar .right {
  margin-left:auto; display:flex; gap:8px; align-items:center; flex-wrap:nowrap;
  white-space:nowrap;
}
.pill {
  background: var(--pill);
  padding: 4px 8px;
  border-radius: 999px;
  font-size: 12px;
  border: 1px solid var(--border);
}
.bar button {
  padding:8px 10px; font-size:14px; cursor:pointer; border:none; color:white;
  background: var(--accent); border-radius:8px;
}
.bar button.secondary {
  background: transparent; color: var(--fg);
  border: 1px solid var(--border);
}
.bar button:hover { background: var(--accent-hover); }
.bar button.secondary:hover { background: var(--panel); }

/* ===== Main wrap/content ===== */
.wrap {
  grid-row: 4;                 /* the filling row */
  display:grid; grid-template-columns: 300px 1fr; gap:0; height: 100%;
  min-height: 0; /* allow child to stretch correctly */
}
.wrap.board-hidden { grid-template-columns: 1fr; }

/* FIX: place .wrap on row 3 when interface is hidden so it fills the 3rd track */
body.interface-hidden .wrap { 
  grid-row: 3; 
  grid-template-columns: 1fr !important; 
}

aside.panel {
  background: var(--panel); border-right:1px solid var(--border);
  display:flex; flex-direction:column;
}
aside.panel.hidden { display:none; }
body.interface-hidden aside.panel { display:none !important; }
/* (grid columns are already collapsed above for hidden mode) */

aside.panel h2 { margin: 12px 12px 4px; font-size:14px; color: var(--fg); font-weight:600; }
aside.panel small { margin: 0 12px 8px; color: var(--muted); }
#board {
  margin: 0 12px 12px; flex:1; resize:none; width: calc(100% - 24px);
  background: var(--editor); color: var(--fg); border:1px solid var(--border);
  border-radius:8px; padding:10px;
  font-family: ui-monospace, Menlo, Consolas, monospace; font-size:13px; line-height:1.4;
}
.panel .row { display:flex; gap:8px; padding:0 12px 12px; }
.panel .row button { flex:1; }

textarea#textArea {
  width: 100%; height: 100%;
  font-size: 16px; padding: 14px; border: none; outline: none;
  background: var(--editor); color: var(--fg);
  font-family: ui-monospace, Menlo, Consolas, monospace;
}
body.interface-hidden textarea#textArea { margin-left: 12px; }

/* ===== Modal shared styles ===== */
.overlay {
  position: fixed; inset: 0; background: rgba(0,0,0,0.5);
  display: none; align-items: center; justify-content: center; z-index: 9999;
}
.dialog {
  width: 720px; max-width: 95%; padding: 16px;
  border-radius: 12px; background: var(--panel); color: var(--fg);
  border: 1px solid var(--border); font-family: Arial, sans-serif;
  box-shadow: 0 10px 30px rgba(0,0,0,0.35);
}
.dialog .title { font-size: 16px; font-weight: 700; margin-bottom: 6px; }
.dialog .hint { font-size: 13px; color: var(--muted); margin-bottom: 10px; }
.dialog .row { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:12px; }
.dialog label { font-size: 14px; display:flex; align-items:center; gap:6px; }
.dialog input[type="number"], .dialog select {
  padding: 8px; border-radius: 8px; border: 1px solid var(--border);
  background: var(--editor); color: var(--fg);
}
.dialog .btns { display:flex; gap:8px; justify-content:flex-end; margin-top: 8px; }
.dialog button {
  padding:10px 12px; border-radius:8px; cursor:pointer;
  border:1px solid var(--border); background: var(--bg2); color: var(--fg);
}
.dialog button.primary { border:none; background: var(--accent); color:#fff; }
.dialog button.primary:hover { background: var(--accent-hover); }

.divider { height:1px; background: var(--border); margin: 12px 0; }

.icon { display:inline-flex; align-items:center; gap:6px; }
.icon svg { width:16px; height:16px; vertical-align:middle; }

.about-list { line-height: 1.6; font-size: 14px; color: var(--fg); }
.about-list kbd { font-size: 12px; }

/* ===== Duplicate end token highlighter overlay ===== */
#highlightOverlay {
  position: fixed;
  inset: auto auto auto auto; /* set dynamically via JS to match the textarea */
  pointer-events: none;
  white-space: pre-wrap;
  word-break: break-word;
  overflow: hidden;
  z-index: 999; /* under modals, over editor */
  color: transparent; /* base text hidden */
}

/* Safety button to restore UI when hidden */
#showControlsBtn {
  position: fixed;
  top: 12px;
  right: 8px;
  z-index: 10000;
  display: none;
  background: var(--accent);
  color: #fff;
  border: none;
  border-radius: 8px;
  padding: 8px 10px;
  cursor: pointer;
  box-shadow: 0 4px 12px rgba(0,0,0,.25);
}

/* === Duplicate End Tokens Modal === */
#dupesListWrap { border:1px solid var(--border); border-radius:10px; background:var(--editor); }
#dupesHeader { display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:8px; }
#dupesCount { font-size:13px; color:var(--muted); }
#dupesSearch {
  width:240px; padding:8px 10px; border-radius:8px; border:1px solid var(--border);
  background:var(--bg2); color:var(--fg);
}
#dupesList {
  max-height: 360px; overflow:auto; padding:6px;
  border-top:1px dashed var(--border);
}
.dupeItem {
  display:flex; align-items:center; justify-content:space-between; gap:10px;
  padding:8px 10px; border-bottom:1px dashed var(--border);
}
.dupeItem:last-child { border-bottom:none; }
.dupeToken { font-family: ui-monospace, Menlo, Consolas, monospace; word-break:break-all; }
.dupeBadge {
  background: var(--pill); border:1px solid var(--border);
  border-radius:999px; padding:2px 8px; font-size:12px;
}
.dupeActions { display:flex; gap:6px; }
.dupeBtn {
  padding:6px 8px; border-radius:8px; cursor:pointer;
  border:1px solid var(--border); background:var(--bg2); color:var(--fg);
}
.dupeBtn:hover { background: var(--panel); }

/* ===== Scoped Menubar (kept from your version) ===== */
.menubar{
  background: var(--bg2);
  border-bottom: 1px solid var(--border);
  padding: 0 8px;
  position: sticky; top: 0;
  z-index: 150;
}
.appmenu-root{ list-style:none; margin:0; padding:0; display:flex; gap:6px; }
.appmenu-item{ position:relative; }
.appmenu-trigger{
  background:transparent; color:var(--fg);
  border:1px solid transparent;
  padding:6px 8px; border-radius:6px; cursor:pointer; font-size:13px;
}
.appmenu-trigger:hover, .appmenu-trigger:focus{
  background:var(--panel);
  border-color: var(--border);
  outline:none;
}

.appmenu{
  position:absolute; top:100%; left:0; min-width:190px;
  background:var(--panel); border:1px solid var(--border);
  border-radius:8px; padding:4px; margin-top:4px; display:none;
  box-shadow: 0 6px 16px rgba(0,0,0,.25);
  z-index: 160;
}
.appmenu.show{ display:block; }

.appmenu li{ list-style:none; }
.appmenu button[role="menuitem"]{
  display:block; width:100%; text-align:left;
  background:transparent; color:var(--fg); border:none;
  padding:6px 8px; border-radius:6px; cursor:pointer; font-size:13px;
}
.appmenu button[role="menuitem"]:hover{ background:var(--bg2); }

.appmenu-sep{ height:1px; background:var(--border); margin:4px; border-radius:1px; }

/* Nested submenu */
.appmenu-nested{ position:relative; }
.appmenu-trigger.nested{
  display:flex; justify-content:space-between; align-items:center; width:100%;
}
.appmenu-field{
  position:absolute;
  left:100%; top:0; margin-left:4px; min-width:190px;
  z-index: 170;
}

/* Mobile: stack */
@media (max-width:600px){
  .appmenu, .appmenu-field{
    position:fixed; left:12px; right:12px; top:auto; bottom:12px;
    margin:0; max-height:50vh; overflow:auto;
  }
}

.scopeInput{
  min-width:120px; max-width:220px;
  padding:8px 10px; border-radius:8px; border:1px solid var(--border);
  background: var(--editor); color: var(--fg); outline: none;
}
.scopeInput:empty:before{ content: attr(data-ph); color: var(--muted); }

/* List Extractor small tweaks (reuses .overlay and .dialog) */
#list-extractor-modal .title { margin-bottom: 6px; }
#list-extractor-modal .hint { margin-bottom: 8px; }
#le_result { white-space: pre; }

/* Field Swapper modal styles (scoped by #field-swapper-modal) */
  #field-swapper-modal .title { margin-bottom: 6px; }
  #field-swapper-modal .hint { margin-bottom: 8px; }

  .fs-list-wrap {
    border: 1px solid var(--border);
    background: var(--editor);
    border-radius: 10px;
    padding: 6px;
  }
  .fs-list {
    max-height: 320px;
    overflow: auto;
    margin: 0;
    padding: 0;
    list-style: none;
  }
  .fs-item {
    display: grid;
    grid-template-columns: 24px 64px 1fr;
    align-items: center;
    gap: 8px;
    padding: 8px;
    border-radius: 8px;
    border: 1px dashed transparent;
    user-select: none;
  }
  .fs-item + .fs-item { margin-top: 6px; }
  .fs-item[draggable="true"] { cursor: grab; }
  .fs-item.dragging { opacity: 0.6; }
  .fs-item.drop-before { border-color: var(--accent); }
  .fs-item.drop-after  { border-color: var(--accent); }

  .fs-handle {
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }
  .fs-num {
    font: 12px/1 ui-monospace, Menlo, Consolas, monospace;
    color: var(--muted);
    background: var(--pill);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 4px 8px;
    text-align: center;
  }
  .fs-name[contenteditable="true"] {
    min-height: 28px;
    padding: 6px 8px;
    border-radius: 8px;
    border: 1px solid var(--border);
    background: var(--bg2);
    outline: none;
  }
  .fs-name[contenteditable="true"]:empty:before {
    content: attr(data-ph);
    color: var(--muted);
  }
  
    /* Scoped to error-handling only */
  #error-handling-modal .dialog .title { margin-bottom: 6px; }
  #error-handling-modal #ehListWrap {
    border:1px solid var(--border);
    background: var(--editor);
    border-radius: 10px;
    max-height: 360px;
    overflow:auto;
    padding: 6px;
  }
  #error-handling-modal .eh-list {
    list-style: none;
    margin: 0;
    padding: 0;
  }
  #error-handling-modal .eh-item {
    display: grid;
    grid-template-columns: auto 1fr auto;
    align-items: start;
    gap: 10px;
    padding: 8px;
    border-bottom: 1px dashed var(--border);
  }
  #error-handling-modal .eh-item:last-child { border-bottom: none; }

  #error-handling-modal .eh-badge {
    border: 1px solid var(--border);
    background: var(--pill);
    border-radius: 999px;
    padding: 2px 8px;
    font-size: 12px;
    line-height: 1.4;
    white-space: nowrap;
  }
  #error-handling-modal .eh-badge.error { color: #fff; background: #b91c1c; border-color:#7f1d1d; }
  #error-handling-modal .eh-badge.warn  { color: #111; background: #fbbf24; border-color:#b45309; }

  #error-handling-modal .eh-msg {
    font-size: 14px;
    line-height: 1.45;
  }
  #error-handling-modal .eh-loc {
    font-size: 12px;
    color: var(--muted);
    white-space: nowrap;
  }

/* Append/Prepend (scoped) */
#append-prepend-modal .title { margin-bottom: 6px; }
#append-prepend-modal .hint { margin-bottom: 8px; }
#append-prepend-modal input[type="number"],
#append-prepend-modal input[type="text"],
#append-prepend-modal select {
  padding: 8px; border-radius: 8px; border: 1px solid var(--border);
  background: var(--editor); color: var(--fg);
}

/* Template Maker (scoped) */
#template-maker-modal .title { margin-bottom: 6px; }
#template-maker-modal .dialog .hint { margin-bottom: 10px; }

/* Show the safety button when hidden */
body.interface-hidden #showControlsBtn { display: inline-block; }


</style>
</head>
<body data-theme="light">
  <header>
    <h1>SQL Notepad</h1>
    <p>&nbsp;</p>
  </header>
  <!-- === Top Software Menu (scoped) === -->
<nav class="menubar" aria-label="App menu">
  <ul class="appmenu-root">
    <li class="appmenu-item">
      <button class="appmenu-trigger" data-menu="file">File</button>
      <ul class="appmenu appmenu-file" role="menu">
        <li><button id="mnuNewDoc"      role="menuitem">New</button></li>
        <li><button id="mnuImportBoard" role="menuitem">Import to Copy Board</button></li>
        <li><button id="mnuClearBoard"  role="menuitem">Clear Copy Board</button></li>
        <li class="appmenu-sep" aria-hidden="true"></li>
        <li><button id="mnuToggleBoard" role="menuitem">Hide/Show Copy Board</button></li>
        <li><button id="mnuToggleUI"    role="menuitem">Toggle Interface (Ctrl+S)</button></li>
      </ul>
    </li>

    <li class="appmenu-item">
      <button class="appmenu-trigger" data-menu="tools">Tools</button>
      <ul class="appmenu appmenu-tools" role="menu">
        <li><button id="mnuTokenizer" role="menuitem">Tokenizer</button></li>
        <li><button id="mnuMath"      role="menuitem">Math</button></li>

        <!-- Nested submenu: Field ▸ -->
        <li class="appmenu-nested">
          <button class="appmenu-trigger nested" data-menu="field">Field ▸</button>
          <ul class="appmenu appmenu-field" role="menu">
            <li><button id="mnuFieldAdd"    role="menuitem">Add Field</button></li>
            <li><button id="mnuFieldRemove" role="menuitem">Remove Field</button></li>
            <li><button id="mnuFieldSet"    role="menuitem">Set Field</button></li>
			<li><button id="mnuFieldSwapper" role="menuitem">Swapper</button></li>
			<li><button id="mnuFieldAppendPrepend" role="menuitem">Append/Prepend</button></li>
          </ul>
        </li>

        <li class="appmenu-sep" aria-hidden="true"></li>
        <li><button id="mnuListExtractor" role="menuitem">List Extractor</button></li>
		<li><button id="mnuTemplateMaker" role="menuitem">Template Maker</button></li>
		<li><button id="mnuErrorHandling" role="menuitem">Debugging</button></li>
      </ul>
    </li>

    <li class="appmenu-item">
      <button class="appmenu-trigger" data-menu="help">Help</button>
      <ul class="appmenu appmenu-help" role="menu">
        <li><button id="mnuHelp" role="menuitem">Help</button></li>
      </ul>
    </li>

    <li class="appmenu-item">
      <button class="appmenu-trigger" data-menu="about">About</button>
      <ul class="appmenu appmenu-about" role="menu">
        <li><button id="mnuAbout" role="menuitem">About</button></li>
      </ul>
    </li>
  </ul>
</nav>
  <div class="bar">
    <span class="pill" id="countPill">Copy Board: 0 items</span>
    <span class="pill" id="rowsCountPill">Set: 0 rows</span>
	<span class="pill" id="setNumPill">Set: 0 #</span>
    <button id="importBtn" class="secondary" title="Import text from system clipboard">Import Clipboard</button>
	
    <button id="tokenizeBtn"   title="Replace last field in every tuple with a unique token">Tokenizer</button>
    <button id="nthFieldRemover" title="Remove the n’th field (1-based) from every tuple">Remove Field</button>
    <button id="addFieldBtn" title="Add a new field across all tuples">Add Field</button>
    <button id="mathButton"    title="Open math tools for field operations">Math</button>

    <div class="right">
      <button id="toggleBoardBtn" class="secondary" title="Hide/Show Copy Board">Hide Copy Board</button>
      <!-- Help button (book icon) -->
      <button id="helpBtn" class="secondary" title="About / Help">
        <span class="icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
               stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
            <path d="M4 4h16v15H6.5A2.5 2.5 0 0 0 4 21.5z"></path>
          </svg>
          Help
        </span>
      </button>

      <button id="settingsBtn" class="secondary" title="Settings">
        <span class="icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
               stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06a2 2 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09c.17 0 .35-.03 .51-.1 .61-.25 1-.85 1-1.51V9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06 .06c.51 .51 1.23 .66 1.82 .33H9c.66 0 1.26-.39 1.51-1V3a2 2 0 0 1 4 0v.09c.25 .61 .85 1 1.51 1h.09c.59 .33 1.31 .18 1.82-.33l.06-.06a2 2 0 1 1 2.83 2.83l-.06 .06c-.51 .51-.66 1.23-.33 1.82V9c0 .66 .39 1.26 1 1.51 .16 .07 .34 .1 .51 .1H21a2 2 0 0 1 0 4h-.09c-.17 0-.35 .03-.51 .1-.61 .25-1 .85-1 1.51z"></path>
          </svg>
          Settings
        </span>
      </button>
    </div>
  </div>

  <div class="wrap" id="mainWrap">
    <aside class="panel" id="leftPanel">
      <h2>Copy Board</h2>
      <small>Paste here (CSV, lines, or whitespace). Edits update the queue.</small>
      <textarea id="board" placeholder='Examples:
alpha, "New York", bravo
or one
per
line'></textarea>
      <div class="row">
        <button id="dedupeBtn" class="secondary">Dedupe</button>
        <button id="shuffleBtn" class="secondary">Shuffle</button>
      </div>
    </aside>

    <textarea id="textArea" placeholder="Paste or type SQL here…"></textarea>
  </div>

  <!-- Highlighter overlay & safety show-controls button -->
  <div id="highlightOverlay" aria-hidden="true"></div>
  <button id="showControlsBtn" title="Show Controls">Show Controls</button>

  <!-- Remove n’th Field Modal -->
  <div class="overlay" id="nth-remover-modal">
    <div class="dialog">
      <div class="title">Remove n’th Field</div>
      <div class="hint">Enter a <b>1-based</b> field index (1 = first field). Removes that field from all tuples.</div>
      <div class="row">
        <label>Field #
          <input type="number" id="nthIndexInput" min="1" value="1" style="width:90px;">
        </label>
      </div>
      <div class="btns">
        <button id="nthCancelBtn">Cancel</button>
        <button id="nthApplyBtn" class="primary">Remove Field</button>
      </div>
    </div>
  </div>

  <!-- Add Field Modal -->
  <div class="overlay" id="add-field-modal">
    <div class="dialog">
      <div class="title">Add Field</div>
      <div class="hint">Choose field type and where to insert it. Fields are <b>1-based</b>.</div>
      <div class="row">
        <label><input type="radio" name="newFieldType" value="number" checked> Number (0)</label>
        <label><input type="radio" name="newFieldType" value="string"> String ('')</label>
      </div>
      <div class="row">
        <label>Insert after field #
          <input type="number" id="addAfterInput" min="0" value="0" style="width:90px;">
        </label>
        <small class="hint">Use 0 to insert at the beginning.</small>
      </div>
      <div class="btns">
        <button id="addFieldCancelBtn">Cancel</button>
        <button id="addFieldApplyBtn" class="primary">Add Field</button>
      </div>
    </div>
  </div>

  <!-- Math Modal -->
  <div class="overlay" id="math-modal">
    <div class="dialog">
      <div class="title">SQL Field Math</div>

      <div class="hint">Result: <b>Target = Number (op) Source</b> · Fields are <b>1-based</b> · Flip → <b>Source (op) Number</b></div>
      <div class="row" id="interfieldRow"></div>
      <div class="btns">
        <button id="applyInterfieldBtn" class="primary">Apply Interfield</button>
      </div>

      <div class="divider"></div>

      <div class="hint">Result: <b>Field = Field (op) Number</b> · Fields are <b>1-based</b> · Optional Flip → <b>Number (op) Field</b></div>
      <div class="row" id="fieldRow"></div>
      <div class="btns">
        <button id="applyFieldBtn" class="primary">Apply Field</button>
      </div>

      <div class="divider"></div>

      <div class="hint">Result: <b>Target = Field Ⓐ (op) Field Ⓑ</b> · Fields are <b>1-based</b></div>
      <div class="row" id="fieldFieldRow"></div>
      <div class="btns">
        <button id="applyFieldFieldBtn" class="primary">Apply Field Ⓐ (op) Field Ⓑ → Target</button>
        <button id="mathCloseBtn">Close</button>
      </div>

      <div class="divider"></div>

      <div class="title" style="font-size:14px; margin:0;">Apply to</div>
      <div class="row">
        <label><input type="checkbox" id="mathScopeSet" checked> Current set</label>
        <label><input type="checkbox" id="mathScopeDoc"> Whole document</label>
      </div>
    </div>
  </div>
  
  <!-- Set Field Modal -->
<div class="overlay" id="set-field-modal">
  <div class="dialog">
    <div class="title">Set Field</div>
    <div class="hint">Fields are <b>1-based</b>. Apply to the current set (around the caret) or the whole document.</div>

    <!-- Apply scope -->
    <!-- Set Field scope -->
	<div class="divider"></div>
	<div class="title" style="font-size:14px; margin:0;">Apply to</div>
	<div class="row">
	  <div id="setScopeInput" class="scopeInput" contenteditable="true" data-ph="doc or 1, 2, 3…">doc</div>
	  <small class="hint" style="margin-top:11px;">Type <b>doc</b> for whole document, or a number of set (sets = rows separated by blank lines).</small>
	</div>
    <div class="divider"></div>
    <!-- Op A: target = X when Y = value -->
    <div class="title" style="font-size:14px;margin-bottom:6px;">Target field = value when other field equals</div>
    <div class="row">
      <label>Target field
        <input type="number" id="sf_target_when" min="1" value="1" style="width:90px;">
      </label>
      <label>Value type
        <select id="sf_val_when_type">
          <option value="string">String</option>
          <option value="number">Number</option>
        </select>
      </label>
      <label>Value
        <input type="text" id="sf_val_when" placeholder="'' or 0">
      </label>
      <label>When field
        <input type="number" id="sf_cond_field" min="1" value="1" style="width:90px;">
      </label>
      <label>Equals type
        <select id="sf_cond_type">
          <option value="string">String</option>
          <option value="number">Number</option>
        </select>
      </label>
      <label>Equals
        <input type="text" id="sf_cond_value" placeholder="match value">
      </label>
    </div>
    <div class="btns">
      <button id="sf_apply_when" class="primary">Apply</button>
    </div>

    <div class="divider"></div>

    <!-- Op B: target = X (unconditional) -->
    <div class="title" style="font-size:14px;margin-bottom:6px;">Target field = value (unconditional)</div>
    <div class="row">
      <label>Target field
        <input type="number" id="sf_target_all" min="1" value="1" style="width:90px;">
      </label>
      <label>Value type
        <select id="sf_val_all_type">
          <option value="string">String</option>
          <option value="number">Number</option>
        </select>
      </label>
      <label>Value
        <input type="text" id="sf_val_all" placeholder="'' or 0">
      </label>
    </div>
    <div class="btns">
      <button id="sf_apply_all" class="primary">Apply</button>
    </div>

    <div class="divider"></div>

    <!-- Op C: fields X..Y replaced with a string -->
    <div class="title" style="font-size:14px;margin-bottom:6px;">Fields X to Y replaced with string field</div>
    <div class="row">
      <label>From field
        <input type="number" id="sf_span_start" min="1" value="1" style="width:90px;">
      </label>
      <label>To field
        <input type="number" id="sf_span_end" min="1" value="2" style="width:90px;">
      </label>
      <label>Replacement string
        <input type="text" id="sf_span_text" placeholder="new value">
      </label>
    </div>
    <div class="btns">
      <button id="sf_apply_span" class="primary">Apply</button>
      <button id="sf_close">Close</button>
    </div>
  </div>
</div>

  <!-- Settings Modal -->
  <div class="overlay" id="settings-modal">
    <div class="dialog">
      <div class="title">Settings</div>
      <div class="hint">Personalize editor behaviors.</div>

      <div class="row">
		<label>
		  <input type="checkbox" id="clearLastField">
		  Clear last field on Ctrl+D duplicate line
		</label>
      </div>

      <div class="row">
        <label>
          <input type="checkbox" id="tokenizerReplaceAll">
          Tokenizer: replace <b>all</b> last fields (not just empty)
        </label>
      </div>

      <div class="divider"></div>

      <div class="title" style="font-size:14px; margin:0;">Token Style</div>
      <div class="hint">Affects <em>Tokenizer</em> and <em>Ctrl+G</em> token generation.</div>
      <div class="row">
        <label>Style
          <select id="tokenStyle">
            <option value="alnum">Alpha-numeric (A-z, 0-9)</option>
            <option value="alpha">Alpha only (A-z)</option>
            <option value="upper">Uppercase (A-Z)</option>
            <option value="lower">Lowercase (a-z)</option>
          </select>
        </label>
        <label>Length
          <input type="number" id="tokenLength" min="4" max="64" value="12" style="width:90px;">
        </label>
      </div>

      <div class="divider"></div>

      <div class="title" style="font-size:14px; margin:0;">Theme</div>
      <div class="row">
        <label>Theme
          <select id="themeSelect">
            <option value="light">Light</option>
            <option value="dark">Dark</option>
          </select>
        </label>
      </div>

      <div class="btns">
        <button id="settingsCloseBtn" class="primary">Done</button>
      </div>
    </div>
  </div>

  <!-- About / Help Modal -->
  <div class="overlay" id="about-modal">
    <div class="dialog">
      <div class="title">About SQL Notepad</div>
      <div class="hint">Keyboard shortcuts & features</div>
      <div class="about-list">
        <ul>
          <li><kbd>Ctrl</kbd>+<kbd>B</kbd> – collect selection to Copy Board (removes it from editor)</li>
          <li><kbd>Ctrl</kbd>+<kbd>I</kbd> – dump Copy Board items into the n’th field across tuples (field dump)</li>
          <li><kbd>Ctrl</kbd>+<kbd>G</kbd> – insert a unique random token at the caret</li>
          <li><kbd>Ctrl</kbd>+<kbd>D</kbd> – duplicate current line (down). If enabled in <em>Settings</em>, clears the <em>last field</em> on the duplicate</li>
          <li><kbd>Ctrl</kbd>+<kbd>R</kbd> – remove current line, crimping content upward</li>
		  <li><kbd>Ctrl</kbd>+<kbd>K</kbd> – Copy current field across all tuples in set</li>
          <li><kbd>Ctrl</kbd>+<kbd>Z</kbd>/<kbd>Ctrl</kbd>+<kbd>Y</kbd> – undo/redo snapshots (10-depth ring)</li>
		  <li><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>E</kbd> – Open duplicate token report</li>
		   <li><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>U</kbd> – Open debugging report</li>
		  <li><kbd>Ctrl</kbd>+<kbd>S</kbd> – toggle interface visibility (safety button also available)</li>
          <li><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>V</kbd> – import clipboard into Copy Board</li>
          <li><b>Tokenizer</b> – fills only empty last fields (<code>''</code> or <code>' '</code>) with unique tokens; optionally replace <em>all</em> last fields via <em>Settings</em></li>
          <li><b>Remove n’th Field</b> – removes a 1-based field index from every tuple</li>
          <li><b>Add Field</b> – inserts Number (<code>0</code>) or String (<code>''</code>) after the specified field index</li>
          <li><b>Math</b> – Interfield (Number & Field), Field Math (Field & Number), and Field vs Field → Target</li>
          <li><b>Copy Board</b> – accepts CSV, lines, or whitespace; includes Dedupe and Shuffle utilities</li>
        </ul>
      </div>
      <div class="btns">
        <button id="aboutCloseBtn" class="primary">Close</button>
      </div>
    </div>
  </div>
<!-- Error Handling Modal -->
<div class="overlay" id="error-handling-modal" aria-modal="true" role="dialog">
  <div class="dialog">
    <div class="title">Error Handling</div>
    <div class="hint">Scan the current document for errors and warnings. Results are grouped as a scrollable list.</div>

    <div id="ehSummary" class="pill" style="display:inline-block; margin-bottom:8px;">—</div>

    <div id="ehListWrap">
      <ul id="ehList" class="eh-list" aria-live="polite"></ul>
    </div>

    <div class="btns" style="margin-top:10px;">
      <button id="ehRescanBtn" class="secondary">Rescan</button>
      <button id="ehCloseBtn" class="primary">Close</button>
    </div>
  </div>
</div>
<script>
/* ============================
   Persistent UI state (theme, panel, settings)
============================ */
const THEME_KEY = 'sqlFieldDump.theme';
const BOARD_VIS_KEY = 'sqlFieldDump.boardCollapsed';
const SETTINGS_KEY = 'sqlFieldDump.settings';

function loadSettings() {
  try {
    const raw = localStorage.getItem(SETTINGS_KEY);
    return raw ? JSON.parse(raw) : {
      clearTokenOnDuplicate: false,
      tokenizerReplaceAll: false,
      tokenStyle: 'alnum',
      tokenLength: 12,
      theme: 'light',
      highlightDuplicates: false
    };
  } catch {
    return {
      clearTokenOnDuplicate: false,
      tokenizerReplaceAll: false,
      tokenStyle: 'alnum',
      tokenLength: 12,
      theme: 'light',
      highlightDuplicates: false
    };
  }
}
function saveSettings(s) {
  try { localStorage.setItem(SETTINGS_KEY, JSON.stringify(s)); } catch {}
}
let SETTINGS = loadSettings();

function applyTheme(theme) {
  document.body.setAttribute('data-theme', theme);
}
function toggleTheme() {
  const current = document.body.getAttribute('data-theme') || 'light';
  const next = current === 'dark' ? 'light' : 'dark';
  applyTheme(next);
  localStorage.setItem(THEME_KEY, next);
  const themeSelect = document.getElementById('themeSelect');
  if (themeSelect) themeSelect.value = next;
}
(function initTheme() {
  const savedSettings = SETTINGS.theme;
  const legacy = localStorage.getItem(THEME_KEY);
  applyTheme(savedSettings || legacy || 'light');
})();

function applyBoardVisibility(collapsed) {
  const wrap = document.getElementById('mainWrap');
  const panel = document.getElementById('leftPanel');
  const btn = document.getElementById('toggleBoardBtn');
  if (collapsed) {
    wrap.classList.add('board-hidden');
    panel.classList.add('hidden');
    if (btn) btn.textContent = 'Show Copy Board';
  } else {
    wrap.classList.remove('board-hidden');
    panel.classList.remove('hidden');
    if (btn) btn.textContent = 'Hide Copy Board';
  }
}
function toggleBoard() {
  const collapsed = localStorage.getItem(BOARD_VIS_KEY) === 'true';
  const next = !collapsed;
  applyBoardVisibility(next);
  localStorage.setItem(BOARD_VIS_KEY, String(next));
}
(function initBoardVis() {
  const collapsed = localStorage.getItem(BOARD_VIS_KEY) === 'true';
  applyBoardVisibility(collapsed);
})();

document.getElementById('toggleBoardBtn').addEventListener('click', toggleBoard);

/* ============================
   Elements & Copy Board state
============================ */
const collectedItems = [];
const textArea   = document.getElementById('textArea');
const boardArea  = document.getElementById('board');
const countPill  = document.getElementById('countPill');
const parsePill  = document.getElementById('parsePill');
const setNumPill = document.getElementById('setNumPill');

const rowsCountPill = document.getElementById('rowsCountPill');

function updateBoardView() {
  if (boardArea) boardArea.value = collectedItems.join('\n');
  if (countPill) {
    countPill.textContent = `Copy Board: ${collectedItems.length} item${collectedItems.length===1?'':'s'}`;
  }
}
function setParseModeLabel(mode) {
  if (parsePill) parsePill.textContent = `Parsing: ${mode}`;
}

// Clear the Copy Board queue + textarea + pill
function clearCopyBoard() {
  collectedItems.length = 0;
  if (boardArea) boardArea.value = '';
  updateBoardView();
}


/* ============================
   CSV-aware tokenization
============================ */
function hasCsvCommaOutsideQuotes(s) {
  let inQ = false;
  for (let i = 0; i < s.length; i++) {
    const ch = s[i];
    if (ch === '"') {
      if (inQ && s[i+1] === '"') { i++; }
      else { inQ = !inQ; }
    } else if (!inQ && ch === ',') {
      return true;
    }
  }
  return false;
}
function csvSplit(s) {
  const out = [];
  let buf = '';
  let inQ = false;
  for (let i = 0; i < s.length; i++) {
    const ch = s[i];
    if (ch === '"') {
      if (inQ && s[i+1] === '"') { buf += '"'; i++; }
      else { inQ = !inQ; }
    } else if (ch === ',' && !inQ) {
      out.push(buf.trim());
      buf = '';
    } else {
      buf += ch;
    }
  }
  out.push(buf.trim());
  return out.map(v => {
    if (v.startsWith('"') && v.endsWith('"')) return v.slice(1, -1);
    return v;
  }).filter(Boolean);
}
function tokenizeAuto(input) {
  const text = input.replace(/\r/g, '');
  if (hasCsvCommaOutsideQuotes(text)) {
    setParseModeLabel('CSV');
    const lines = text.split('\n').filter(l => l.trim().length);
    const items = [];
    for (const line of lines) items.push(...csvSplit(line));
    return items.filter(Boolean);
  }
  if (text.includes('\n')) {
    setParseModeLabel('Lines');
    return text.split('\n').map(s => s.trim()).filter(Boolean);
  }
  setParseModeLabel('Whitespace');
  return text.split(/\s+/).map(s => s.trim()).filter(Boolean);
}
function pushItemsAuto(input) {
  const items = tokenizeAuto(input);
  if (items.length) {
    collectedItems.push(...items);
    updateBoardView();
  }
}
function syncFromBoard() {
  const items = tokenizeAuto(boardArea.value);
  collectedItems.length = 0;
  collectedItems.push(...items);
  updateBoardView();
}
boardArea.addEventListener('input', syncFromBoard);

/* ============================
   Set detection & rows pill
============================ */
function getLineIndexAndColumn(text, caretPos) {
  const lines = text.split(/\r?\n/);
  let acc = 0;
  for (let i = 0; i < lines.length; i++) {
    const len = lines[i].length;
    if (caretPos <= acc + len) {
      return { lines, lineIndex: i, column: caretPos - acc };
    }
    acc += len + 1;
  }
  return { lines, lineIndex: lines.length - 1, column: lines[lines.length - 1].length };
}
function expandToSetBounds(lines, startLine, endLine) {
  const isBlank = (ln) => lines[ln].trim() === '';
  let s = startLine;
  while (s > 0 && !isBlank(s)) s--;
  if (isBlank(s)) s++;
  let e = endLine;
  while (e < lines.length - 1 && !isBlank(e)) e++;
  if (!isBlank(e)) e = e + 1;
  return { start: s, end: e };
}
function findAllTuplesInLineSmart(line) {
  const tuples = [];
  let inQuote = false;

  for (let i = 0; i < line.length; i++) {
    const ch = line[i];

    if (ch === "'") {
      if (inQuote) {
        if (line[i - 1] === '\\') {
          // escaped
        } else if (line[i + 1] === "'") {
          i++;
        } else {
          inQuote = false;
        }
      } else {
        inQuote = true;
      }
    } else if (ch === '\\' && inQuote) {
      i++;
    } else if (!inQuote && ch === '(') {
      const start = i;
      let j = i + 1;
      let depth = 1;
      let q = false;
      for (; j < line.length; j++) {
        const c2 = line[j];
        if (c2 === "'") {
          if (q) {
            if (line[j - 1] === '\\') {
              // escaped
            } else if (line[j + 1] === "'") {
              j++;
            } else {
              q = false;
            }
          } else {
            q = true;
          }
        } else if (c2 === '\\' && q) {
          j++;
        } else if (!q) {
          if (c2 === '(') depth++;
          else if (c2 === ')') {
            depth--;
            if (depth === 0) {
              tuples.push({ open: start, close: j + 1, raw: line.slice(start, j + 1) });
              i = j;
              break;
            }
          }
        }
      }
    }
  }
  return tuples;
}
function countTuplesInRange(lines, start, endExclusive) {
  let count = 0;
  for (let i = start; i < endExclusive; i++) {
    const tuples = findAllTuplesInLineSmart(lines[i]);
    if (tuples && tuples.length) count += tuples.length;
  }
  return count;
}
function updateRowsCountPill() {
  if (!textArea) return;

  const text = textArea.value;
  const selStart = textArea.selectionStart ?? 0;
  const selEnd   = textArea.selectionEnd ?? selStart;

  const infoStart = getLineIndexAndColumn(text, selStart);
  const infoEnd   = getLineIndexAndColumn(text, Math.max(0, selEnd - (selEnd > 0 ? 1 : 0)));
  const lines = infoStart.lines;
  let startLine = infoStart.lineIndex;
  let endLine   = infoEnd.lineIndex;

  // ---- update rows count pill ----
  if (rowsCountPill) {
    if (selStart !== selEnd) {
      const bounds = expandToSetBounds(lines, Math.min(startLine, endLine), Math.max(startLine, endLine));
      const count = countTuplesInRange(lines, bounds.start, bounds.end);
      rowsCountPill.textContent = `Set: ${count} row${count===1?'':'s'}`;
    } else {
      if (lines[startLine].trim() === '') {
        rowsCountPill.textContent = 'Set: 0 rows';
      } else {
        const bounds = expandToSetBounds(lines, startLine, startLine);
        const count = countTuplesInRange(lines, bounds.start, bounds.end);
        rowsCountPill.textContent = `Set: ${count} row${count===1?'':'s'}`;
      }
    }
  }

  // ---- update set number pill ----
  if (setNumPill) {
    const caretLine = infoStart.lineIndex;
    const sets = enumerateSets(lines); // blocks separated by blank lines
    let setIndex = 0;
    for (let i = 0; i < sets.length; i++) {
      const { start, end } = sets[i];
      if (caretLine >= start && caretLine < end) { setIndex = i + 1; break; }
    }
    setNumPill.textContent = `Set: ${setIndex} #`;
  }
}

/* ============================
   Field utilities
============================ */
function splitFieldsRobust(tupleRaw) {
  const inner = tupleRaw.slice(1, -1);
  const parts = [];
  let buf = '';
  let inQuote = false;

  for (let i = 0; i < inner.length; i++) {
    const ch = inner[i];

    if (ch === "'") {
      if (inQuote) {
        if (inner[i - 1] === '\\') {
          buf += ch;
        } else if (inner[i + 1] === "'") {
          buf += "''"; i++;
        } else {
          inQuote = false; buf += ch;
        }
      } else {
        inQuote = true; buf += ch;
      }
    } else if (ch === '\\' && inQuote) {
      buf += ch;
      if (i + 1 < inner.length) { buf += inner[i + 1]; i++; }
    } else if (!inQuote && ch === ',') {
      parts.push(buf.trim()); buf = '';
    } else {
      buf += ch;
    }
  }
  parts.push(buf.trim());
  return parts;
}
function joinFields(parts) { return '(' + parts.join(', ') + ')'; }
function isQuoted(str) { const t = str.trim(); return t.startsWith("'") && t.endsWith("'"); }

/* ============================
   Insert collected items (Ctrl+I)
============================ */
function countCommasBeforeIndexRobust(line, tupleOpen, indexInLine) {
  const start = tupleOpen + 1;
  const end   = Math.max(start, Math.min(indexInLine, line.length));
  let inQuote = false, commas = 0;

  for (let i = start; i < end; i++) {
    const ch = line[i];
    if (ch === "'") {
      if (inQuote) {
        if (line[i - 1] === '\\') {
          // escaped
        } else if (line[i + 1] === "'") {
          i++;
        } else {
          inQuote = false;
        }
      } else {
        inQuote = true;
      }
    } else if (ch === '\\' && inQuote) {
      i++;
    } else if (!inQuote && ch === ',') {
      commas++;
    }
  }
  return commas;
}

function enumerateSets(lines) {
  const sets = [];
  let i = 0;
  while (i < lines.length) {
    while (i < lines.length && lines[i].trim() === '') i++;
    if (i >= lines.length) break;
    const start = i;
    while (i < lines.length && lines[i].trim() !== '') i++;
    sets.push({ start, end: i }); // [start, end)
  }
  return sets;
}

/* ============================
   Keyboard: Collect / Import / Dump / Duplicate / Remove / Token / Undo-Redo / Toggle UI
============================ */
document.addEventListener('keydown', function (event) {
  // Collect: Ctrl+B
  if (event.ctrlKey && event.key.toLowerCase() === 'b' && document.activeElement === textArea) {
    event.preventDefault();

    const start = textArea.selectionStart;
    const end   = textArea.selectionEnd;
    if (start === end) return;

    const selectedText = textArea.value.substring(start, end);
    pushItemsAuto(selectedText);

    const before = textArea.value.substring(0, start);
    const after  = textArea.value.substring(end);
    textArea.value = before + after;
    textArea.setSelectionRange(start, start);
    pushSnapshot(); // record change
    updateRowsCountPill();

    return;
  }

  // Import: Ctrl+Shift+V
  if (event.ctrlKey && event.shiftKey && event.key.toLowerCase() === 'v' &&
      (document.activeElement === textArea || document.activeElement === boardArea)) {
    event.preventDefault();
    navigator.clipboard.readText().then(pushItemsAuto).catch(() => alert('Clipboard read failed.'));
    return;
  }

  // Dump: Ctrl+I
  if (event.ctrlKey && event.key.toLowerCase() === 'i' && document.activeElement === textArea) {
    event.preventDefault();
    if (collectedItems.length === 0) return;

    const caretPos = textArea.selectionStart;
    const info     = getLineIndexAndColumn(textArea.value, caretPos);
    const lines    = info.lines;
    const startLine= info.lineIndex;
    const column   = info.column;

    const tupOnCaret = findAllTuplesInLineSmart(lines[startLine])[0] || null;
    if (!tupOnCaret) return;

    let fieldIndex = 0;
    if (column <= tupOnCaret.open) fieldIndex = 0;
    else if (column >= tupOnCaret.close) {
      const parts = splitFieldsRobust(tupOnCaret.raw);
      fieldIndex = Math.max(0, parts.length - 1);
    } else {
      fieldIndex = countCommasBeforeIndexRobust(lines[startLine], tupOnCaret.open, column);
    }

    let used = 0;
    for (let li = startLine; li < lines.length && used < collectedItems.length; li++) {
      const line = lines[li];
      if (line.trim() === '') break;

      const tuples = findAllTuplesInLineSmart(line);
      if (!tuples.length) continue;

      const t = tuples[0];
      const before = line.slice(0, t.open);
      const after  = line.slice(t.close);

      const parts = splitFieldsRobust(t.raw);
      if (fieldIndex < 0 || fieldIndex >= parts.length) continue;

      const target = parts[fieldIndex];
      const value  = collectedItems[used++];

      parts[fieldIndex] = isQuoted(target) ? `'${String(value).replace(/'/g, "''")}'`
                                           : String(value);

      lines[li] = before + joinFields(parts) + after;
    }

    textArea.value = lines.join('\n');
    textArea.setSelectionRange(caretPos, caretPos);
    pushSnapshot();
    updateBoardView();
    updateRowsCountPill();
  
    return;
  }

  // Duplicate line down: Ctrl+D
  if (event.ctrlKey && event.key.toLowerCase() === 'd' && document.activeElement === textArea) {
    event.preventDefault();
    const pos = textArea.selectionStart;
    const { lines, lineIndex, column } = getLineIndexAndColumn(textArea.value, pos);
    const srcLine = lines[lineIndex];

    let dup = srcLine;
    if (SETTINGS.clearTokenOnDuplicate) {
      dup = clearLastFieldInAllTuples(dup);
    }

    lines.splice(lineIndex + 1, 0, dup);
    textArea.value = lines.join('\n');

    let startOfNew = 0;
    for (let i = 0; i <= lineIndex; i++) startOfNew += lines[i].length + 1;
    const newCaret = startOfNew + Math.min(column, lines[lineIndex + 1].length);
    textArea.setSelectionRange(newCaret, newCaret);
    pushSnapshot();
    updateRowsCountPill();
 
    return;
  }

  // Remove current line: Ctrl+R
  if (event.ctrlKey && event.key.toLowerCase() === 'r' && document.activeElement === textArea) {
    event.preventDefault();
    const pos = textArea.selectionStart;
    const { lines, lineIndex } = getLineIndexAndColumn(textArea.value, pos);
    if (!lines.length) return;

    lines.splice(lineIndex, 1);

    const newIndex = Math.min(lineIndex, Math.max(0, lines.length - 1));
    let acc = 0;
    for (let i = 0; i < newIndex; i++) acc += lines[i].length + 1;

    textArea.value = lines.join('\n');
    textArea.setSelectionRange(acc, acc);
    pushSnapshot();
    updateRowsCountPill();

    return;
  }

  // Generate token: Ctrl+G
  if (event.ctrlKey && event.key.toLowerCase() === 'g' && document.activeElement === textArea) {
    event.preventDefault();
    insertUniqueTokenAtCaret();
    pushSnapshot();

    return;
  }

  // Undo: Ctrl+Z (custom ring buffer)
  if (event.ctrlKey && !event.shiftKey && event.key.toLowerCase() === 'z' && document.activeElement === textArea) {
    event.preventDefault();
    undoSnapshot();
    return;
  }
  // Redo: Ctrl+Y (custom ring buffer)
  if (event.ctrlKey && event.key.toLowerCase() === 'y' && document.activeElement === textArea) {
    event.preventDefault();
    redoSnapshot();
    return;
  }

  // Toggle interface: Ctrl+S
  if (event.ctrlKey && event.key.toLowerCase() === 's') {
    event.preventDefault();
    toggleInterfaceHidden();
    return;
  }
  
  // Show Duplicate End Tokens: Ctrl+Shift+E
if (event.ctrlKey && event.shiftKey && event.key.toLowerCase() === 'e' && document.activeElement === textArea) {
  event.preventDefault();
  openDupesModal();
  return;
}


});

/* ============================
   Tokenizer & token generation
============================ */
function generateTokenWithStyle(length, style) {
  let chars = '';
  switch (style) {
    case 'alpha': chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'; break;
    case 'upper': chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'; break;
    case 'lower': chars = 'abcdefghijklmnopqrstuvwxyz'; break;
    default:      chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'; break;
  }
  let token = '';
  for (let i = 0; i < length; i++) token += chars.charAt(Math.floor(Math.random() * chars.length));
  return token;
}
function getUniqueToken(existingContent, length, style) {
  let token;
  do { token = generateTokenWithStyle(length, style); } while (existingContent.includes(token));
  return token;
}
function insertUniqueTokenAtCaret() {
  if (!textArea) return;
  const content = textArea.value;
  const token = getUniqueToken(content, SETTINGS.tokenLength || 12, SETTINGS.tokenStyle || 'alnum');
  const start = textArea.selectionStart;
  const end   = textArea.selectionEnd;
  textArea.value = content.slice(0, start) + token + content.slice(end);
  const newPos = start + token.length;
  textArea.setSelectionRange(newPos, newPos);
}

function isEmptyQuotedField(str) {
  const t = String(str).trim();
  if (!(t.startsWith("'") && t.endsWith("'"))) return false;
  const inner = t.slice(1, -1).replace(/''/g, "'");
  return inner.trim().length === 0;
}
function replaceLastFieldWithQuotedTokenIfEmpty(tupleRaw, token) {
  const parts = splitFieldsRobust(tupleRaw);
  if (!parts.length) return tupleRaw;
  const last = parts[parts.length - 1];
  if (!isEmptyQuotedField(last)) return tupleRaw;
  parts[parts.length - 1] = `'${String(token).replace(/'/g, "''")}'`;
  return joinFields(parts);
}
function replaceLastFieldWithTokenAlways(tupleRaw, token) {
  const parts = splitFieldsRobust(tupleRaw);
  if (!parts.length) return tupleRaw;
  const last = parts[parts.length - 1];
  const replacement = isQuoted(last) ? `'${String(token).replace(/'/g, "''")}'` : String(token);
  parts[parts.length - 1] = replacement;
  return joinFields(parts);
}

document.getElementById('tokenizeBtn').addEventListener('click', () => {
  if (!textArea) return;
  let content = textArea.value;
  const lines = content.split(/\r?\n/);
  const replaceAll = !!SETTINGS.tokenizerReplaceAll;
  const len = SETTINGS.tokenLength || 12;
  const style = SETTINGS.tokenStyle || 'alnum';

  for (let li = 0; li < lines.length; li++) {
    const line = lines[li];
    if (!line.trim()) continue;

    const tuples = findAllTuplesInLineSmart(line);
    if (!tuples.length) continue;

    let newLine = line;
    for (let k = tuples.length - 1; k >= 0; k--) {
      const t = tuples[k];
      const token = getUniqueToken(content, len, style);

      const before = newLine.slice(0, t.open);
      const after  = newLine.slice(t.close);
      const replacedTuple = replaceAll
        ? replaceLastFieldWithTokenAlways(t.raw, token)
        : replaceLastFieldWithQuotedTokenIfEmpty(t.raw, token);

      if (replacedTuple !== t.raw) {
        newLine = before + replacedTuple + after;

        const docPrefixLen = lines.slice(0, li).join('\n').length + (li > 0 ? 1 : 0);
        const beforeDoc = content.slice(0, docPrefixLen);
        const afterDoc  = content.slice(docPrefixLen + line.length);
        content = beforeDoc + newLine + afterDoc;
      }
    }
    lines[li] = newLine;
  }
  textArea.value = lines.join('\n');
  pushSnapshot();
  updateRowsCountPill();
  
});

/* ============================
   Remove n’th Field
============================ */
const nthModal      = document.getElementById('nth-remover-modal');
const nthInput      = document.getElementById('nthIndexInput');
const nthApplyBtn   = document.getElementById('nthApplyBtn');
const nthCancelBtn  = document.getElementById('nthCancelBtn');
document.getElementById('nthFieldRemover').addEventListener('click', () => {
  nthModal.style.display = 'flex';
  setTimeout(() => nthInput.focus(), 0);
});
nthCancelBtn.addEventListener('click', () => nthModal.style.display = 'none');
nthModal.addEventListener('click', (e) => { if (e.target === nthModal) nthCancelBtn.click(); });

function removeFieldInTuple(tupleRaw, fieldIndex0) {
  const parts = splitFieldsRobust(tupleRaw);
  if (fieldIndex0 < 0 || fieldIndex0 >= parts.length) return tupleRaw;
  parts.splice(fieldIndex0, 1);
  return joinFields(parts);
}
function removeFieldFromAllTuplesInLine(line, fieldIndex0) {
  const tuples = findAllTuplesInLineSmart(line);
  if (!tuples.length) return line;
  let out = line;
  for (let i = tuples.length - 1; i >= 0; i--) {
    const t = tuples[i];
    const before = out.slice(0, t.open);
    const after  = out.slice(t.close);
    const replaced = removeFieldInTuple(t.raw, fieldIndex0);
    out = before + replaced + after;
  }
  return out;
}
function removeFieldAcrossDocument(fieldIndex0) {
  const lines = textArea.value.split(/\r?\n/);
  for (let i = 0; i < lines.length; i++) {
    lines[i] = removeFieldFromAllTuplesInLine(lines[i], fieldIndex0);
  }
  textArea.value = lines.join('\n');
}
nthApplyBtn.addEventListener('click', () => {
  const idx1 = Number(nthInput.value);
  if (!Number.isInteger(idx1) || idx1 < 1) { alert('Enter an integer ≥ 1.'); return; }
  removeFieldAcrossDocument(idx1 - 1);
  nthModal.style.display = 'none';
  pushSnapshot();
  updateRowsCountPill();
 
});
nthInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') nthApplyBtn.click();
  else if (e.key === 'Escape') nthCancelBtn.click();
});

/* ============================
   Add Field modal
============================ */
const addFieldModal = document.getElementById('add-field-modal');
const addFieldBtn   = document.getElementById('addFieldBtn');
const addAfterInput = document.getElementById('addAfterInput');
const addFieldCancelBtn = document.getElementById('addFieldCancelBtn');
const addFieldApplyBtn  = document.getElementById('addFieldApplyBtn');

addFieldBtn.addEventListener('click', () => {
  addFieldModal.style.display = 'flex';
  setTimeout(() => addAfterInput.focus(), 0);
});
addFieldCancelBtn.addEventListener('click', () => addFieldModal.style.display = 'none');
addFieldModal.addEventListener('click', (e) => { if (e.target === addFieldModal) addFieldCancelBtn.click(); });

function addFieldInTuple(tupleRaw, insertAfterN1Based, type) {
  const parts = splitFieldsRobust(tupleRaw);
  const insertIndex = Math.max(0, Math.min(parts.length, (Number(insertAfterN1Based) || 0)));
  const newVal = (type === 'number') ? '0' : "''";
  parts.splice(insertIndex, 0, newVal);
  return joinFields(parts);
}
function addFieldAcrossDocument(insertAfterN1Based, type) {
  const lines = textArea.value.split(/\r?\n/);
  for (let i = 0; i < lines.length; i++) {
    const tuples = findAllTuplesInLineSmart(lines[i]);
    if (!tuples.length) continue;
    let out = lines[i];
    for (let k = tuples.length - 1; k >= 0; k--) {
      const t = tuples[k];
      const before = out.slice(0, t.open);
      const after  = out.slice(t.close);
      const replaced = addFieldInTuple(t.raw, insertAfterN1Based, type);
      out = before + replaced + after;
    }
    lines[i] = out;
  }
  textArea.value = lines.join('\n');
}

addFieldApplyBtn.addEventListener('click', () => {
  const type = (document.querySelector('input[name="newFieldType"]:checked') || {}).value || 'number';
  const afterN = Number(addAfterInput.value);
  if (!Number.isInteger(afterN) || afterN < 0) { alert('Insert-after must be an integer ≥ 0.'); return; }
  addFieldAcrossDocument(afterN, type);
  addFieldModal.style.display = 'none';
  pushSnapshot();
  updateRowsCountPill();

});

/* ============================
   Math popup (scope + ops)
============================ */
const mathModal = document.getElementById('math-modal');
const interfieldRow = document.getElementById('interfieldRow');
const fieldRow = document.getElementById('fieldRow');
const fieldFieldRow = document.getElementById('fieldFieldRow');
const applyInterfieldBtn = document.getElementById('applyInterfieldBtn');
const applyFieldBtn = document.getElementById('applyFieldBtn');
const applyFieldFieldBtn = document.getElementById('applyFieldFieldBtn');
const mathCloseBtn = document.getElementById('mathCloseBtn');
const scopeSetChk = document.getElementById('mathScopeSet');
const scopeDocChk = document.getElementById('mathScopeDoc');

function mk(labelText, el) {
  const lab = document.createElement('label');
  lab.textContent = labelText + ' ';
  lab.appendChild(el);
  return lab;
}
function makeNumberInput(val, min, width) {
  const el = document.createElement('input');
  el.type = 'number'; if (min != null) el.min = String(min);
  if (val != null) el.value = String(val);
  if (width) el.style.width = width;
  return el;
}
function makeSelect(options) {
  const el = document.createElement('select');
  options.forEach(v => { const o = document.createElement('option'); o.value = v; o.textContent = v; el.appendChild(o); });
  return el;
}
function makeRoundingSelect() { return makeSelect(['none','up','down']); }

// Interfield controls
const if_target = makeNumberInput(1, 1, '80px');
const if_op     = makeSelect(['+','-','*','/']);
const if_source = makeNumberInput(2, 1, '80px');
const if_num    = (() => { const n = makeNumberInput(1, null, '120px'); n.step = 'any'; return n; })();
const if_round  = makeRoundingSelect();
const if_flip   = document.createElement('input'); if_flip.type='checkbox';

interfieldRow.appendChild(mk('Target Field', if_target));
interfieldRow.appendChild(mk('Operation', if_op));
interfieldRow.appendChild(mk('Source Field', if_source));
interfieldRow.appendChild(mk('Number', if_num));
interfieldRow.appendChild(mk('Rounding', if_round));
const if_flipWrap = document.createElement('label'); if_flipWrap.appendChild(if_flip); if_flipWrap.appendChild(document.createTextNode(' Flip Order'));
interfieldRow.appendChild(if_flipWrap);

// Field Math controls
const fm_field = makeNumberInput(1, 1, '80px');
const fm_op    = makeSelect(['+','-','*','/']);
const fm_num   = (() => { const n = makeNumberInput(1, null, '120px'); n.step = 'any'; return n; })();
const fm_round = makeRoundingSelect();
const fm_flip  = document.createElement('input'); fm_flip.type='checkbox';

fieldRow.appendChild(mk('Field', fm_field));
fieldRow.appendChild(mk('Operation', fm_op));
fieldRow.appendChild(mk('Number', fm_num));
fieldRow.appendChild(mk('Rounding', fm_round));
const fm_flipWrap = document.createElement('label'); fm_flipWrap.appendChild(fm_flip); fm_flipWrap.appendChild(document.createTextNode(' Flip Order'));
fieldRow.appendChild(fm_flipWrap);

// Field Ⓐ (op) Field Ⓑ controls
const ff_target = makeNumberInput(1, 1, '80px');
const ff_op     = makeSelect(['+','-','*','/']);
const ff_a      = makeNumberInput(1, 1, '80px');
const ff_b      = makeNumberInput(2, 1, '80px');
const ff_round  = makeRoundingSelect();

fieldFieldRow.appendChild(mk('Target Field', ff_target));
fieldFieldRow.appendChild(mk('Operation', ff_op));
fieldFieldRow.appendChild(mk('Field Ⓐ', ff_a));
fieldFieldRow.appendChild(mk('Field Ⓑ', ff_b));
fieldFieldRow.appendChild(mk('Rounding', ff_round));

// open/close
document.getElementById('mathButton').addEventListener('click', () => {
  mathModal.style.display = 'flex';
  // default scope: current set
  scopeSetChk.checked = true;
  scopeDocChk.checked = false;
  setTimeout(() => if_target.focus(), 0);
});
mathCloseBtn.addEventListener('click', () => mathModal.style.display = 'none');
mathModal.addEventListener('click', (e) => { if (e.target === mathModal) mathCloseBtn.click(); });

// enforce radio-like behavior for scope checkboxes
scopeSetChk.addEventListener('change', () => {
  if (scopeSetChk.checked) scopeDocChk.checked = false;
  else if (!scopeDocChk.checked) scopeSetChk.checked = true;
});
scopeDocChk.addEventListener('change', () => {
  if (scopeDocChk.checked) scopeSetChk.checked = false;
  else if (!scopeSetChk.checked) scopeDocChk.checked = true;
});

function computeSetBoundsFromSelection(lines) {
  const selStart = textArea.selectionStart ?? 0;
  const selEnd   = textArea.selectionEnd ?? selStart;
  const infoStart = getLineIndexAndColumn(textArea.value, selStart);
  const infoEnd   = getLineIndexAndColumn(textArea.value, Math.max(0, selEnd - (selEnd > 0 ? 1 : 0)));
  const startLine = Math.min(infoStart.lineIndex, infoEnd.lineIndex);
  const endLine   = Math.max(infoStart.lineIndex, infoEnd.lineIndex);
  return expandToSetBounds(lines, startLine, endLine);
}

function applyMathAcrossRange(opts, range) {
  const { targetIdx0, sourceIdx0, op, constant, rounding, flipOrder } = opts;
  const { lines, start, end } = range;

  for (let li = start; li < end; li++) {
    let line = lines[li];
    if (!line.trim()) continue;

    const tuples = findAllTuplesInLineSmart(line);
    if (!tuples.length) continue;

    let newLine = line;
    for (let k = tuples.length - 1; k >= 0; k--) {
      const t = tuples[k];
      const parts = splitFieldsRobust(t.raw);
      if (targetIdx0 < 0 || targetIdx0 >= parts.length) continue;
      if (sourceIdx0 < 0 || sourceIdx0 >= parts.length) continue;

      const sourceRaw = parts[sourceIdx0].trim();
      const targetRaw = parts[targetIdx0].trim();

      if (isQuoted(sourceRaw)) continue;
      const sourceNum = parseFloat(sourceRaw);
      if (!isFinite(sourceNum)) continue;

      let result;
      if (!flipOrder) {
        switch (op) {
          case '+': result = constant + sourceNum; break;
          case '-': result = constant - sourceNum; break;
          case '*': result = constant * sourceNum; break;
          case '/': if (sourceNum === 0) continue; result = constant / sourceNum; break;
        }
      } else {
        switch (op) {
          case '+': result = sourceNum + constant; break;
          case '-': result = sourceNum - constant; break;
          case '*': result = sourceNum * constant; break;
          case '/': if (constant === 0) continue; result = sourceNum / constant; break;
        }
      }

      if (rounding === 'up')   result = Math.ceil(result);
      if (rounding === 'down') result = Math.floor(result);

      parts[targetIdx0] = isQuoted(targetRaw) ? `'${result}'` : String(result);

      const before = newLine.slice(0, t.open);
      const after  = newLine.slice(t.close);
      newLine = before + joinFields(parts) + after;
    }
    lines[li] = newLine;
  }
  textArea.value = lines.join('\n');
}

function applyFieldMathAcrossRange(opts, range) {
  const { fieldIdx0, op, constant, rounding, flipOrder } = opts;
  const { lines, start, end } = range;

  for (let li = start; li < end; li++) {
    let line = lines[li];
    if (!line.trim()) continue;

    const tuples = findAllTuplesInLineSmart(line);
    if (!tuples.length) continue;

    let newLine = line;
    for (let k = tuples.length - 1; k >= 0; k--) {
      const t = tuples[k];
      const parts = splitFieldsRobust(t.raw);
      if (fieldIdx0 < 0 || fieldIdx0 >= parts.length) continue;

      const raw = parts[fieldIdx0].trim();
      if (isQuoted(raw)) continue;
      const fieldNum = parseFloat(raw);
      if (!isFinite(fieldNum)) continue;

      let result;
      if (!flipOrder) {
        switch (op) {
          case '+': result = fieldNum + constant; break;
          case '-': result = fieldNum - constant; break;
          case '*': result = fieldNum * constant; break;
          case '/': if (constant === 0) continue; result = fieldNum / constant; break;
        }
      } else {
        switch (op) {
          case '+': result = constant + fieldNum; break;
          case '-': result = constant - fieldNum; break;
          case '*': result = constant * fieldNum; break;
          case '/': if (fieldNum === 0) continue; result = constant / fieldNum; break;
        }
      }

      if (rounding === 'up')   result = Math.ceil(result);
      if (rounding === 'down') result = Math.floor(result);

      parts[fieldIdx0] = isQuoted(raw) ? `'${result}'` : String(result);

      const before = newLine.slice(0, t.open);
      const after  = newLine.slice(t.close);
      newLine = before + joinFields(parts) + after;
    }
    lines[li] = newLine;
  }
  textArea.value = lines.join('\n');
}

function applyFieldOpFieldToTargetAcrossRange(opts, range) {
  const { targetIdx0, aIdx0, bIdx0, op, rounding } = opts;
  const { lines, start, end } = range;

  for (let li = start; li < end; li++) {
    let line = lines[li];
    if (!line.trim()) continue;

    const tuples = findAllTuplesInLineSmart(line);
    if (!tuples.length) continue;

    let newLine = line;
    for (let k = tuples.length - 1; k >= 0; k--) {
      const t = tuples[k];
      const parts = splitFieldsRobust(t.raw);
      if (targetIdx0 < 0 || targetIdx0 >= parts.length) continue;
      if (aIdx0 < 0 || aIdx0 >= parts.length) continue;
      if (bIdx0 < 0 || bIdx0 >= parts.length) continue;

      const aRaw = parts[aIdx0].trim();
      const bRaw = parts[bIdx0].trim();
      const targetRaw = parts[targetIdx0].trim();

      if (isQuoted(aRaw) || isQuoted(bRaw)) continue;
      const aNum = parseFloat(aRaw);
      const bNum = parseFloat(bRaw);
      if (!isFinite(aNum) || !isFinite(bNum)) continue;

      let result;
      switch (op) {
        case '+': result = aNum + bNum; break;
        case '-': result = aNum - bNum; break;
        case '*': result = aNum * bNum; break;
        case '/': if (bNum === 0) continue; result = aNum / bNum; break;
        default: continue;
      }

      if (rounding === 'up')   result = Math.ceil(result);
      if (rounding === 'down') result = Math.floor(result);

      parts[targetIdx0] = isQuoted(targetRaw) ? `'${result}'` : String(result);

      const before = newLine.slice(0, t.open);
      const after  = newLine.slice(t.close);
      newLine = before + joinFields(parts) + after;
    }
    lines[li] = newLine;
  }
  textArea.value = lines.join('\n');
}

// apply buttons use scope
applyInterfieldBtn.addEventListener('click', () => {
  const tgt1 = Number(if_target.value);
  const src1 = Number(if_source.value);
  const op   = String(if_op.value);
  const val  = Number(if_num.value);
  const rnd  = String(if_round.value);
  const flip = !!if_flip.checked;

  if (!Number.isInteger(tgt1) || tgt1 < 1) { alert('Target field must be an integer ≥ 1.'); return; }
  if (!Number.isInteger(src1) || src1 < 1) { alert('Source field must be an integer ≥ 1.'); return; }
  if (!isFinite(val)) { alert('Please enter a valid Number.'); return; }
  if (!['+','-','*','/'].includes(op)) { alert('Choose a valid operation.'); return; }
  if (!['none','up','down'].includes(rnd)) { alert('Choose a valid rounding mode.'); return; }

  const range = getScopeBounds();
  applyMathAcrossRange({
    targetIdx0: tgt1 - 1,
    sourceIdx0: src1 - 1,
    op, constant: val,
    rounding: rnd,
    flipOrder: flip
  }, range);
  pushSnapshot();
  updateRowsCountPill();
  
});

applyFieldBtn.addEventListener('click', () => {
  const fld1 = Number(fm_field.value);
  const op   = String(fm_op.value);
  const val  = Number(fm_num.value);
  const rnd  = String(fm_round.value);
  const flip = !!fm_flip.checked;

  if (!Number.isInteger(fld1) || fld1 < 1) { alert('Field must be an integer ≥ 1.'); return; }
  if (!isFinite(val)) { alert('Please enter a valid Number.'); return; }
  if (!['+','-','*','/'].includes(op)) { alert('Choose a valid operation.'); return; }
  if (!['none','up','down'].includes(rnd)) { alert('Choose a valid rounding mode.'); return; }

  const range = getScopeBounds();
  applyFieldMathAcrossRange({
    fieldIdx0: fld1 - 1,
    op, constant: val,
    rounding: rnd,
    flipOrder: flip
  }, range);
  pushSnapshot();
  updateRowsCountPill();

});

applyFieldFieldBtn.addEventListener('click', () => {
  const tgt1 = Number(ff_target.value);
  const a1   = Number(ff_a.value);
  const b1   = Number(ff_b.value);
  const op   = String(ff_op.value);
  const rnd  = String(ff_round.value);

  if (!Number.isInteger(tgt1) || tgt1 < 1) { alert('Target field must be an integer ≥ 1.'); return; }
  if (!Number.isInteger(a1) || a1 < 1) { alert('Field Ⓐ must be an integer ≥ 1.'); return; }
  if (!Number.isInteger(b1) || b1 < 1) { alert('Field Ⓑ must be an integer ≥ 1.'); return; }
  if (!['+','-','*','/'].includes(op)) { alert('Choose a valid operation.'); return; }
  if (!['none','up','down'].includes(rnd)) { alert('Choose a valid rounding mode.'); return; }

  const range = getScopeBounds();
  applyFieldOpFieldToTargetAcrossRange({
    targetIdx0: tgt1 - 1,
    aIdx0: a1 - 1,
    bIdx0: b1 - 1,
    op,
    rounding: rnd
  }, range);
  pushSnapshot();
  updateRowsCountPill();

});

/* ============================
   Settings modal wiring (added highlightDuplicates)
============================ */
const settingsModal = document.getElementById('settings-modal');
const settingsBtn   = document.getElementById('settingsBtn');
const settingsClose = document.getElementById('settingsCloseBtn');
const clearOnDupChk = document.getElementById('clearLastField');
const tokenizerReplaceAllChk = document.getElementById('tokenizerReplaceAll');
const tokenStyleSel = document.getElementById('tokenStyle');
const tokenLengthInp= document.getElementById('tokenLength');
const themeSelect   = document.getElementById('themeSelect');

function openSettings() {
  clearOnDupChk.checked = !!SETTINGS.clearTokenOnDuplicate;
  tokenizerReplaceAllChk.checked = !!SETTINGS.tokenizerReplaceAll;
  tokenStyleSel.value = SETTINGS.tokenStyle || 'alnum';
  tokenLengthInp.value = SETTINGS.tokenLength || 12;
  themeSelect.value = (document.body.getAttribute('data-theme') || SETTINGS.theme || 'light');
  settingsModal.style.display = 'flex';
}
function closeSettings() {
  SETTINGS.clearTokenOnDuplicate = !!clearOnDupChk.checked;
  SETTINGS.tokenizerReplaceAll = !!tokenizerReplaceAllChk.checked;
  SETTINGS.tokenStyle = String(tokenStyleSel.value || 'alnum');
  const len = Number(tokenLengthInp.value);
  SETTINGS.tokenLength = (Number.isInteger(len) && len >= 4 && len <= 64) ? len : 12;
  SETTINGS.theme = String(themeSelect.value || 'light');
  saveSettings(SETTINGS);
  applyTheme(SETTINGS.theme);
  settingsModal.style.display = 'none';

}
settingsBtn.addEventListener('click', openSettings);
settingsClose.addEventListener('click', closeSettings);
settingsModal.addEventListener('click', (e) => { if (e.target === settingsModal) closeSettings(); });
// immediate save hooks (optional)
clearOnDupChk.addEventListener('change', () => { SETTINGS.clearTokenOnDuplicate = !!clearOnDupChk.checked; saveSettings(SETTINGS); });
tokenizerReplaceAllChk.addEventListener('change', () => { SETTINGS.tokenizerReplaceAll = !!tokenizerReplaceAllChk.checked; saveSettings(SETTINGS); });
tokenStyleSel.addEventListener('change', () => { SETTINGS.tokenStyle = tokenStyleSel.value; saveSettings(SETTINGS); });
tokenLengthInp.addEventListener('change', () => {
  const v = Number(tokenLengthInp.value);
  if (Number.isInteger(v) && v>=4 && v<=64) { SETTINGS.tokenLength = v; saveSettings(SETTINGS); }
});
themeSelect.addEventListener('change', () => { SETTINGS.theme = themeSelect.value; saveSettings(SETTINGS); applyTheme(SETTINGS.theme); });

/* ============================
   Helpers to clear LAST field (Ctrl+D)
============================ */
function clearLastFieldInTuple(tupleRaw) {
  const parts = splitFieldsRobust(tupleRaw);
  if (!parts.length) return tupleRaw;
  parts[parts.length - 1] = "''";
  return joinFields(parts);
}
function clearLastFieldInAllTuples(line) {
  const tuples = findAllTuplesInLineSmart(line);
  if (!tuples.length) return line;
  let out = line;
  for (let i = tuples.length - 1; i >= 0; i--) {
    const t = tuples[i];
    const before = out.slice(0, t.open);
    const after  = out.slice(t.close);
    const replaced = clearLastFieldInTuple(t.raw);
    out = before + replaced + after;
  }
  return out;
}

/* ============================
   About / Help modal
============================ */
const aboutModal = document.getElementById('about-modal');
const helpBtn    = document.getElementById('helpBtn');
const aboutClose = document.getElementById('aboutCloseBtn');

helpBtn.addEventListener('click', () => { aboutModal.style.display = 'flex'; });
aboutClose.addEventListener('click', () => { aboutModal.style.display = 'none'; });
aboutModal.addEventListener('click', (e) => { if (e.target === aboutModal) aboutClose.click(); });

/* ============================
   Live updates for rows pill + snapshots + highlighter
============================ */
textArea.addEventListener('input', () => { updateRowsCountPill(); pushSnapshot(); });
textArea.addEventListener('keyup', updateRowsCountPill);
textArea.addEventListener('mouseup', updateRowsCountPill);
textArea.addEventListener('select', updateRowsCountPill);

/* ============================
   Snapshot ring buffer (10)
============================ */
const SNAP_MAX = 10;
let snapStack = []; // [{value, selStart, selEnd}]
let snapIndex = -1; // points to current snapshot

function pushSnapshot() {
  const val = textArea.value;
  const selStart = textArea.selectionStart || 0;
  const selEnd = textArea.selectionEnd || selStart;

  // Avoid pushing identical consecutive snapshots
  if (snapIndex >= 0 && snapStack[snapIndex] && snapStack[snapIndex].value === val) return;

  // If we've undone and then type, discard forward history
  if (snapIndex < snapStack.length - 1) {
    snapStack = snapStack.slice(0, snapIndex + 1);
  }

  snapStack.push({ value: val, selStart, selEnd });
  // Keep only last SNAP_MAX
  if (snapStack.length > SNAP_MAX) {
    snapStack.shift();
  }
  snapIndex = snapStack.length - 1;
}

function applySnapshotAt(idx) {
  if (idx < 0 || idx >= snapStack.length) return;
  const s = snapStack[idx];
  textArea.value = s.value;
  const start = Math.min(s.selStart, textArea.value.length);
  const end   = Math.min(s.selEnd,   textArea.value.length);
  textArea.setSelectionRange(start, end);
  updateRowsCountPill();
 
}

function undoSnapshot() {
  if (snapIndex <= 0) return;
  snapIndex--;
  applySnapshotAt(snapIndex);
}
function redoSnapshot() {
  if (snapIndex >= snapStack.length - 1) return;
  snapIndex++;
  applySnapshotAt(snapIndex);
}
// Seed the initial snapshot
setTimeout(pushSnapshot, 0);

/* ============================
   Interface hide/show (Ctrl+S + button)
============================ */
function toggleInterfaceHidden() {
  const hidden = document.body.classList.toggle('interface-hidden');
  
}
document.getElementById('showControlsBtn').addEventListener('click', () => {
  document.body.classList.remove('interface-hidden');

});

/* ============================
   Duplicate end-token highlighter (overlay)
============================ */
const overlayEl = document.getElementById('highlightOverlay');

// find the range of the last field inside a tuple raw string "( ... )"
// returns {start, end} indices relative to tupleRaw
function getLastFieldRange(tupleRaw) {
  const inner = tupleRaw.slice(1, -1);
  let inQ = false;
  let startIdx = 0;
  let lastStart = 0;

  for (let i = 0; i < inner.length; i++) {
    const ch = inner[i];
    if (ch === "'") {
      if (inQ) {
        if (inner[i - 1] === '\\') {
          // keep inQ
        } else if (inner[i + 1] === "'") {
          i++; // skip escaped quote
        } else {
          inQ = false;
        }
      } else {
        inQ = true;
      }
    } else if (ch === '\\' && inQ) {
      i++;
    } else if (!inQ && ch === ',') {
      // field boundary: next field starts at i+1 (skip space later)
      lastStart = i + 1;
    }
  }
  // Trim whitespace around last field
  // lastStart currently points to char after last comma or 0 if single field
  // Calculate actual indices in tupleRaw including parentheses
  const innerSlice = inner.slice(lastStart);
  const leadingSpaces = innerSlice.match(/^\s*/)[0].length;
  let start = 1 + lastStart + leadingSpaces; // 1 for '('
  // end is before ')', but trim trailing spaces
  let end = tupleRaw.length - 1; // index of ')'
  // move left over spaces
  let e = end - 1;
  while (e >= 0 && /\s/.test(tupleRaw[e])) e--;
  end = e + 1;
  return { start, end };
}

// Extract normalized end-token value from a tuple raw
function getLastFieldValue(tupleRaw) {
  const { start, end } = getLastFieldRange(tupleRaw);
  const raw = tupleRaw.slice(start, end).trim();
  if (raw.startsWith("'") && raw.endsWith("'")) {
    const inner = raw.slice(1, -1).replace(/''/g, "'");
    return inner.trim();
  }
  return raw;
}

// Escape HTML for overlay content
function escapeHtml(s) {
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

// Debounce overlay refresh to avoid excessive work during rapid typing
let highlightTimer = null;

// === Copy Board buttons ===
const clearBtn  = document.getElementById('clearBtn');
const importBtn = document.getElementById('importBtn');

if (clearBtn) {
  clearBtn.addEventListener('click', () => {
    collectedItems.length = 0;      // clear queue
    updateBoardView();              // refresh textarea + pill
  });
}

if (importBtn) {
  importBtn.addEventListener('click', async () => {
    try {
      const txt = await navigator.clipboard.readText();
      pushItemsAuto(txt);           // tokenize + append to queue
    } catch (err) {
      // Fallback if clipboard API not available/blocked
      const txt = prompt('Paste clipboard contents here:','');
      if (txt != null) pushItemsAuto(txt);
    }
  });
}


/* ============================
   Init
============================ */
updateBoardView();
setParseModeLabel('Auto');
updateRowsCountPill();

</script>
<script>
// ...place this after the scopeSetChk/scopeDocChk are created...
function getScopeBounds(){
  const lines = textArea.value.split(/\r?\n/);
  // Use the actual checkbox ids you created for the Math modal:
  if (scopeDocChk && scopeDocChk.checked) {
    return { lines, start: 0, end: lines.length };
  }
  // default: current set (block) around the caret/selection
  const bounds = computeSetBoundsFromSelection(lines);
  return { lines, start: bounds.start, end: bounds.end };
}
</script>

<script>
/* ===== Set Field modal logic ===== */

// Split the document into "sets" (blocks separated by blank lines)
function enumerateSets(lines){
  const sets = [];
  const isBlank = (i) => !lines[i] || lines[i].trim() === '';
  let i = 0, n = lines.length;
  while (i < n){
    while (i < n && isBlank(i)) i++;      // skip leading blanks
    if (i >= n) break;
    const start = i;
    while (i < n && !isBlank(i)) i++;     // consume non-blank block
    const end = i;                        // [start, end)
    sets.push({ start, end });
  }
  return sets;
}

// Read "doc" or a 1-based set number from the contenteditable field
function getSetFieldScopeBounds(){
  const lines = textArea.value.split(/\r?\n/);
  const si = document.getElementById('setScopeInput');
  const raw = (si?.textContent || '').trim().toLowerCase();

  if (raw === 'doc' || raw === 'document' || raw === 'all'){
    return { lines, start: 0, end: lines.length };
  }

  if (/^\d+$/.test(raw)){
    const n = parseInt(raw, 10);
    const sets = enumerateSets(lines);
    if (n >= 1 && n <= sets.length){
      return { lines, start: sets[n - 1].start, end: sets[n - 1].end };
    }
    alert(`Set #${n} not found. There ${sets.length===1 ? 'is 1 set' : 'are ' + sets.length + ' sets'}. Using document.`);
    return { lines, start: 0, end: lines.length };
  }

  // Fallback: treat as doc
  return { lines, start: 0, end: lines.length };
}

const setFieldModal = document.getElementById('set-field-modal');

function openSetFieldModal(){

  setFieldModal.style.display = 'flex';
  setTimeout(()=> document.getElementById('sf_target_when').focus(), 0);
}
function closeSetFieldModal(){ setFieldModal.style.display = 'none'; }
document.getElementById('sf_close').addEventListener('click', closeSetFieldModal);
setFieldModal.addEventListener('click', (e)=>{ if (e.target === setFieldModal) closeSetFieldModal(); });

// Helpers: quoting & comparisons
function quoteIfNeeded(val, type, preserveQuotedTarget){
  if (type === 'number') return String(Number(val));
  const escaped = String(val).replace(/'/g, "''");
  return `'${escaped}'`;
}
// Replace fieldValueAsType() with this:
function fieldValueAsType(raw, type){
  const t = raw.trim();
  if (type === 'number'){
    // allow numbers even if quoted, e.g. '12'
    let inner = t;
    if (t.startsWith("'") && t.endsWith("'")){
      inner = t.slice(1,-1).replace(/''/g,"'");
    }
    const n = parseFloat(inner);
    return isFinite(n) ? n : NaN;
  } else {
    if (t.startsWith("'") && t.endsWith("'")){
      return t.slice(1,-1).replace(/''/g,"'").trim(); // trim strings
    }
    return t.trim();
  }
}

function applySetFieldTransformAcrossRange(transformTupleFn){
  const { lines, start, end } = getSetFieldScopeBounds(); // <-- new scope
  for (let li = start; li < end; li++){
    let line = lines[li];
    if (!line.trim()) continue;

    // Work right-to-left so indices stay valid as tuples change length
    let mutated = line;
    const tuples = findAllTuplesInLineSmart(mutated);
    for (let k = tuples.length - 1; k >= 0; k--){
      // re-scan this line to keep tuple positions accurate
      const current = findAllTuplesInLineSmart(mutated);
      const t = current[k];
      const before = mutated.slice(0, t.open);
      const after  = mutated.slice(t.close);
      const replaced = transformTupleFn(t.raw); // returns new "( ... )"
      mutated = before + replaced + after;
    }
    lines[li] = mutated;
  }
  textArea.value = lines.join('\n');
  pushSnapshot();
  updateRowsCountPill();

}


// Core transform helpers
function setTargetInTuple(tupleRaw, targetIdx0, valueStr, valueType){
  const parts = splitFieldsRobust(tupleRaw);
  if (targetIdx0 < 0 || targetIdx0 >= parts.length) return tupleRaw;
  const targetWasQuoted = parts[targetIdx0].trim().startsWith("'") && parts[targetIdx0].trim().endsWith("'");
  const replacement = (valueType === 'number' && !targetWasQuoted) ? String(Number(valueStr))
                      : quoteIfNeeded(valueStr, valueType);
  parts[targetIdx0] = replacement;
  return joinFields(parts);
}
function setTargetWhenInTuple(tupleRaw, targetIdx0, condIdx0, valueStr, valueType, condVal, condType){
  const parts = splitFieldsRobust(tupleRaw);
  if (targetIdx0 < 0 || targetIdx0 >= parts.length) return tupleRaw;
  if (condIdx0   < 0 || condIdx0   >= parts.length) return tupleRaw;

 // Replace just the middle of setTargetWhenInTuple() where eq is computed:
	const curCond = fieldValueAsType(parts[condIdx0], condType);
	const wantVal = (condType === 'number') ? Number(condVal) : String(condVal).trim();

	const eq = (condType === 'number')
	  ? (isFinite(curCond) && curCond === wantVal)
	  : (String(curCond).trim() === wantVal);

  if (!eq) return tupleRaw;

  const targetWasQuoted = parts[targetIdx0].trim().startsWith("'") && parts[targetIdx0].trim().endsWith("'");
  const replacement = (valueType === 'number' && !targetWasQuoted) ? String(Number(valueStr))
                      : quoteIfNeeded(valueStr, valueType);
  parts[targetIdx0] = replacement;
  return joinFields(parts);
}
function replaceSpanWithString(tupleRaw, startIdx0, endIdx0, text){
  const parts = splitFieldsRobust(tupleRaw);
  if (startIdx0 < 0 || endIdx0 < startIdx0 || startIdx0 >= parts.length) return tupleRaw;
  const clampedEnd = Math.min(endIdx0, parts.length-1);
  const replacement = `'${String(text).replace(/'/g,"''")}'`;
  parts.splice(startIdx0, clampedEnd - startIdx0 + 1, replacement);
  return joinFields(parts);
}

// Document-level applicators
// Replace the body of applyTupleTransformAcrossRange() with this version:
function applyTupleTransformAcrossRange(transformFn){
   const { lines, start, end } = getSetFieldScopeBounds();;
  for (let li = start; li < end; li++){
    let line = lines[li];
    if (!line.trim()) continue;

    // re-scan on the current line state, process right-to-left each pass
    const tuples = findAllTuplesInLineSmart(line);
    if (!tuples.length) continue;

    let newLine = line;
    for (let k = tuples.length - 1; k >= 0; k--){
      const t = findAllTuplesInLineSmart(newLine)[k] || tuples[k]; // refresh indices
      const before = newLine.slice(0, t.open);
      const after  = newLine.slice(t.close);
      const replaced = transformFn(t.raw);
      newLine = before + replaced + after;
    }
    lines[li] = newLine;
  }
  textArea.value = lines.join('\n');
  pushSnapshot();
  updateRowsCountPill();
 
}


/* ---- Wire Apply buttons ---- */

// A) target = value when (cond field == value)
document.getElementById('sf_apply_when').addEventListener('click', ()=>{
  const tgt1 = Number(document.getElementById('sf_target_when').value);
  const vType= String(document.getElementById('sf_val_when_type').value);
  const vVal = document.getElementById('sf_val_when').value;
  const cFld = Number(document.getElementById('sf_cond_field').value);
  const cType= String(document.getElementById('sf_cond_type').value);
  const cVal = document.getElementById('sf_cond_value').value;

  if (!Number.isInteger(tgt1) || tgt1 < 1) return alert('Target field must be an integer ≥ 1.');
  if (!Number.isInteger(cFld) || cFld < 1) return alert('When field must be an integer ≥ 1.');
  if (vType === 'number' && !isFinite(Number(vVal))) return alert('Value must be a valid number.');
  if (cType === 'number' && !isFinite(Number(cVal))) return alert('Equals must be a valid number.');

  applyTupleTransformAcrossRange(tupleRaw =>
    setTargetWhenInTuple(tupleRaw, tgt1-1, cFld-1, vVal, vType, cVal, cType)
  );
});

// B) target = value (unconditional)
document.getElementById('sf_apply_all').addEventListener('click', ()=>{
  const tgt1 = Number(document.getElementById('sf_target_all').value);
  const vType= String(document.getElementById('sf_val_all_type').value);
  const vVal = document.getElementById('sf_val_all').value;

  if (!Number.isInteger(tgt1) || tgt1 < 1) return alert('Target field must be an integer ≥ 1.');
  if (vType === 'number' && !isFinite(Number(vVal))) return alert('Value must be a valid number.');

  applyTupleTransformAcrossRange(tupleRaw =>
    setTargetInTuple(tupleRaw, tgt1-1, vVal, vType)
  );
});

// C) fields X..Y replaced with a string
document.getElementById('sf_apply_span').addEventListener('click', ()=>{
  const s = Number(document.getElementById('sf_span_start').value);
  const e = Number(document.getElementById('sf_span_end').value);
  const txt = document.getElementById('sf_span_text').value;

  if (!Number.isInteger(s) || s < 1) return alert('From field must be an integer ≥ 1.');
  if (!Number.isInteger(e) || e < 1) return alert('To field must be an integer ≥ 1.');
  if (e < s) return alert('To field must be ≥ From field.');

  applyTupleTransformAcrossRange(tupleRaw => replaceSpanWithString(tupleRaw, s-1, e-1, txt));
});
</script>

<script>
// ===== Duplicate End Tokens: lazy init, scan, render, open/close =====
let dupesModal, dupesList, dupesCountEl, dupesCloseBtn, dupesCopyAllBtn, dupesSearch;
let dupesWired = false;

function ensureDupesRefs() {
  if (dupesWired) return true;

  dupesModal = document.getElementById('dupes-modal');
  if (!dupesModal) return false; // modal not in DOM yet

  dupesList        = document.getElementById('dupesList');
  dupesCountEl     = document.getElementById('dupesCount');
  dupesCloseBtn    = document.getElementById('dupesCloseBtn');
  dupesCopyAllBtn  = document.getElementById('dupesCopyAllBtn');
  dupesSearch      = document.getElementById('dupesSearch');

  // Wire modal actions once
  dupesCloseBtn.addEventListener('click', closeDupesModal);
  dupesModal.addEventListener('click', (e) => { if (e.target === dupesModal) closeDupesModal(); });
  dupesSearch.addEventListener('input', () => renderDupesList(dupesSearch.value));

  // Copy single token (exact token string, without surrounding quotes)
  dupesList.addEventListener('click', (e) => {
    const btn = e.target.closest('button.dupeBtn[data-copy]');
    if (!btn) return;
    const tok = btn.getAttribute('data-copy') || '';
    navigator.clipboard.writeText(tok).catch(()=>{});
  });

  // Copy all tokens (one per line)
  dupesCopyAllBtn.addEventListener('click', () => {
    const dupes = collectDuplicateEndTokens().map(([t]) => t).join('\n');
    if (!dupes) return;
    navigator.clipboard.writeText(dupes).catch(()=>{});
  });

  // Auto-refresh while open
  textArea.addEventListener('input', () => {
    if (dupesModal.style.display === 'flex') renderDupesList(dupesSearch.value);
  });

  dupesWired = true;
  return true;
}

function collectDuplicateEndTokens() {
  const counts = new Map();
  const lines = (textArea?.value || '').split(/\r?\n/);

  for (const line of lines) {
    if (!line.trim()) continue;
    const tuples = findAllTuplesInLineSmart(line);
    for (const t of tuples) {
      const val = getLastFieldValue(t.raw);
      if (val === '') continue; // skip empty ''
      counts.set(val, (counts.get(val) || 0) + 1);
    }
  }

  const dupes = [];
  counts.forEach((c, k) => { if (c >= 2) dupes.push([k, c]); });
  dupes.sort((a,b) => b[1] - a[1] || a[0].localeCompare(b[0]));
  return dupes;
}

function renderDupesList(filterText = '') {
  const dupes = collectDuplicateEndTokens();
  const filtered = filterText
    ? dupes.filter(([tok]) => tok.toLowerCase().includes(filterText.toLowerCase()))
    : dupes;

  dupesList.innerHTML = '';
  if (filtered.length === 0) {
    dupesList.innerHTML = `<div class="dupeItem"><span class="hint">No duplicate end tokens found.</span></div>`;
  } else {
    for (const [token, count] of filtered) {
      const row = document.createElement('div');
      row.className = 'dupeItem';
      row.setAttribute('role','listitem');
      row.innerHTML = `
        <span class="dupeToken">'${token.replace(/&/g,'&amp;').replace(/</g,'&lt;')}'</span>
        <div class="dupeActions">
          <span class="dupeBadge" title="Occurrences">${count}×</span>
          <button class="dupeBtn" data-copy="${token.replace(/"/g, '&quot;')}">Copy</button>
        </div>
      `;
      dupesList.appendChild(row);
    }
  }

  const totalDistinct = dupes.length;
  const totalOcc = dupes.reduce((s, [,c]) => s + c, 0);
  dupesCountEl.textContent = totalDistinct
    ? `Duplicates: ${totalDistinct} distinct • ${totalOcc} total occurrences`
    : 'No duplicates detected';
}

function openDupesModal() {
  if (!ensureDupesRefs()) {
    // Modal HTML not in DOM yet — this means the block is below this script.
    // Try again on next frame once parsing advances.
    requestAnimationFrame(() => {
      if (!ensureDupesRefs()) return console.warn('Duplicate tokens modal not found in DOM.');
      renderDupesList('');
      dupesModal.style.display = 'flex';
      setTimeout(() => dupesSearch.focus(), 0);
    });
    return;
  }
  renderDupesList('');
  dupesModal.style.display = 'flex';
  setTimeout(() => dupesSearch.focus(), 0);
}
function closeDupesModal() {
  if (dupesModal) dupesModal.style.display = 'none';
}
</script>
<script>
/* ===== Scoped Software Menu behavior (no impact on .bar) ===== */
(function(){
  const menubar = document.querySelector('.menubar');
  if (!menubar) return;

  const $  = (s, r=document) => r.querySelector(s);
  const $$ = (s, r=document) => Array.from(r.querySelectorAll(s));

  function closeAll(except){
    $$('.menubar .appmenu').forEach(m=>{
      if (except && (m===except || m.contains(except))) return;
      m.classList.remove('show'); m.removeAttribute('aria-expanded');
    });
    $$('.menubar .appmenu-trigger').forEach(b=>{
      if (except && (b===except || b.contains(except))) return;
      b.removeAttribute('aria-expanded');
    });
  }

  // Top-level toggles
  $$('.menubar .appmenu-item > .appmenu-trigger').forEach(btn=>{
    btn.addEventListener('click', (e)=>{
      const parent = e.currentTarget.closest('.appmenu-item');
      const key = btn.getAttribute('data-menu');
      const menu = parent.querySelector(`.appmenu-${key}`);
      const open = menu.classList.contains('show');
      if (!open){
        closeAll();
        menu.classList.add('show');
        menu.setAttribute('aria-expanded','true');
        btn.setAttribute('aria-expanded','true');
      } else {
        closeAll();
      }
      e.stopPropagation();
    });
  });

  // Nested Field submenu (hover + click, sticky-open)
  const nested = $('.appmenu-nested', menubar);
  if (nested){
    const nBtn  = $('.appmenu-trigger.nested', nested);
    const nMenu = $('.appmenu-field', nested);
    let timer = null;

    const open  = ()=>{ nMenu.classList.add('show'); nMenu.setAttribute('aria-expanded','true'); nBtn.setAttribute('aria-expanded','true'); };
    const close = ()=>{ nMenu.classList.remove('show'); nMenu.removeAttribute('aria-expanded'); nBtn.removeAttribute('aria-expanded'); };

    nBtn.addEventListener('mouseenter', ()=>{ if (timer) clearTimeout(timer); open(); });
    nMenu.addEventListener('mouseenter', ()=>{ if (timer) clearTimeout(timer); open(); });
    nBtn.addEventListener('click', (e)=>{ nMenu.classList.contains('show') ? close() : open(); e.stopPropagation(); });

    const delayedClose = ()=>{ if (timer) clearTimeout(timer); timer = setTimeout(close, 200); };
    nBtn.addEventListener('mouseleave', delayedClose);
    nMenu.addEventListener('mouseleave', delayedClose);
  }

  // Outside click closes
  document.addEventListener('click', (e)=>{ if (!e.target.closest('.menubar')) closeAll(); });
  window.addEventListener('blur', ()=> closeAll());
  window.addEventListener('resize', ()=> closeAll());

  // Wire to existing controls
  const bindClick = (id, targetId, extra) => {
    const src = document.getElementById(id), tgt = document.getElementById(targetId);
    if (src && tgt) src.addEventListener('click', ()=>{ closeAll(); tgt.click(); if (extra) extra(); });
  };

  const textArea = document.getElementById('textArea');
  const boardArea = document.getElementById('board');

  // File -> New: clear editor AND copy board
  const btnNew = document.getElementById('mnuNewDoc');
  if (btnNew && textArea){
    btnNew.addEventListener('click', ()=>{
      closeAll();
      if (!confirm('Clear the editor and the Copy Board?')) return;

      // clear editor
      textArea.value = '';
      // clear copy board (queue + textarea + pill)
      if (Array.isArray(window.collectedItems)) {
        window.collectedItems.length = 0;
      }
      if (boardArea) boardArea.value = '';
      window.updateBoardView?.();

      window.updateRowsCountPill?.();
      window.pushSnapshot?.();
  
    });
  }

  // File helpers
  bindClick('mnuImportBoard', 'importBtn');
  bindClick('mnuToggleBoard', 'toggleBoardBtn');

  const tUI = document.getElementById('mnuToggleUI');
  if (tUI && typeof window.toggleInterfaceHidden === 'function'){
    tUI.addEventListener('click', ()=>{ closeAll(); window.toggleInterfaceHidden(); });
  }

  // Tools wiring
  bindClick('mnuTokenizer', 'tokenizeBtn');
  bindClick('mnuMath',      'mathButton');
  bindClick('mnuFieldAdd',    'addFieldBtn');
  bindClick('mnuFieldRemove', 'nthFieldRemover');

  // IMPORTANT: Set Field is intentionally UNLINKED now.
	const setField = document.getElementById('mnuFieldSet');
	if (setField){
	  setField.addEventListener('click', ()=>{ closeAll(); openSetFieldModal(); });
	}


  // Help menu opens the existing help/about modal
  const mnuHelp = document.getElementById('mnuHelp');
  if (mnuHelp){
    mnuHelp.addEventListener('click', ()=>{ closeAll(); document.getElementById('helpBtn')?.click(); });
  }

  // About does nothing (placeholder)
  const mnuAbout = document.getElementById('mnuAbout');
  if (mnuAbout){
    mnuAbout.addEventListener('click', ()=>{ closeAll(); /* no-op for now */ });
  }

  // Optional: List Extractor stub
 // Wire Tools -> List Extractor to new modal
const listX = document.getElementById('mnuListExtractor');
if (listX) {
  listX.addEventListener('click', () => {
    closeAll();
    window.openListExtractor?.();
  });
}

  // File -> Clear Copy Board: clear queue directly (no UI button required)
const mnuClearBoard = document.getElementById('mnuClearBoard');
if (mnuClearBoard) {
  mnuClearBoard.addEventListener('click', () => {
    closeAll();
    clearCopyBoard();
  });
}

  
})();
</script>
<script>
/* ============================
   List Extractor (modular, lazy init + single wiring)
=============================*/
(function(){
  // State
  let wired = false;

  // DOM refs (assigned in ensureRefs)
  let modal, scopeEl, fldInp, modeSel, trimChk, uniqChk, outTA, countEl, genBtn, copyBtn, closeBtn;

  // Helper: parse SQL field to plain text/number-ish string
  function fieldToPlain(raw){
    const t = String(raw).trim();
    if (t.startsWith("'") && t.endsWith("'")){
      return t.slice(1,-1).replace(/''/g,"'");
    }
    const n = Number(t);
    return Number.isFinite(n) ? String(n) : t;
  }

  // Ensure modal DOM + listeners exist (wire once)
  function ensureRefs(){
  if (wired) return true;

  modal   = document.getElementById('list-extractor-modal');
  scopeEl = document.getElementById('listScopeInput');
  fldInp  = document.getElementById('le_field');
  modeSel = document.getElementById('le_output_mode');
  trimChk = document.getElementById('le_trim');
  uniqChk = document.getElementById('le_unique');
  outTA   = document.getElementById('le_result');
  countEl = document.getElementById('le_count');
  copyBtn = document.getElementById('le_copyBtn');
  closeBtn= document.getElementById('le_closeBtn');

  // ✅ removed genBtn entirely
  if (!modal || !fldInp || !modeSel || !trimChk || !uniqChk || !outTA || !countEl || !copyBtn || !closeBtn) {
    console.warn('[ListExtractor] Modal not found in DOM yet.');
    return false;
  }

  // Wire actions
  copyBtn.addEventListener('click', () => {
    if (outTA.value) navigator.clipboard.writeText(outTA.value).catch(()=>{});
  });
  closeBtn.addEventListener('click', closeModal);
  modal.addEventListener('click', (e)=>{ if (e.target === modal) closeModal(); });

  // ✅ Live updates (auto-generate)
  [modeSel, trimChk, uniqChk].forEach(el => el.addEventListener('change', generate));
  fldInp.addEventListener('input', generate);
  scopeEl.addEventListener('input', generate);

  wired = true;
  return true;
}

  // Scope helpers (mirrors Set Field modal)
  function enumerateSetsLocal(lines){
    // Use app’s enumerateSets if available
    if (typeof window.enumerateSets === 'function') return window.enumerateSets(lines);
    const sets = [];
    const isBlank = (i) => !lines[i] || lines[i].trim() === '';
    let i = 0, n = lines.length;
    while (i < n){
      while (i < n && isBlank(i)) i++;
      if (i >= n) break;
      const start = i;
      while (i < n && !isBlank(i)) i++;
      sets.push({ start, end: i });
    }
    return sets;
  }

  function getScopeBoundsForList(){
    const ta = document.getElementById('textArea');
    const lines = (ta?.value || '').split(/\r?\n/);
    const raw = (scopeEl?.textContent || '').trim().toLowerCase();

    if (raw === 'doc' || raw === 'document' || raw === 'all'){
      return { lines, start: 0, end: lines.length };
    }
    if (/^\d+$/.test(raw)){
      const n = parseInt(raw, 10);
      const sets = enumerateSetsLocal(lines);
      if (n >= 1 && n <= sets.length){
        return { lines, start: sets[n - 1].start, end: sets[n - 1].end };
      }
      alert(`Set #${n} not found. There ${sets.length===1 ? 'is 1 set' : 'are ' + sets.length + ' sets'}. Using document.`);
    }
    return { lines, start: 0, end: lines.length };
  }

  // Collect values
  function collectFieldValues(fieldIdx0){
    if (typeof window.findAllTuplesInLineSmart !== 'function' || typeof window.splitFieldsRobust !== 'function'){
      alert('List Extractor requires tuple helpers present in the app.');
      return [];
    }
    const { lines, start, end } = getScopeBoundsForList();
    const vals = [];

    for (let li = start; li < end; li++){
      const line = lines[li];
      if (!line || !line.trim()) continue;
      const tuples = window.findAllTuplesInLineSmart(line);
      if (!tuples.length) continue;

      for (const t of tuples){
        const parts = window.splitFieldsRobust(t.raw);
        if (fieldIdx0 < 0 || fieldIdx0 >= parts.length) continue;
        let v = fieldToPlain(parts[fieldIdx0]);
        if (trimChk.checked) v = String(v).trim();
        vals.push(v);
      }
    }
    return vals;
  }

  // Render output
  function renderOutput(values){
    const items = uniqChk.checked ? Array.from(new Set(values)) : values.slice();
    const text = (modeSel.value === 'lines')
      ? items.join('\n')
      : items.map(s => {
          const needsQuote = /[",\n]/.test(s);
          const cell = s.replace(/"/g, '""');
          return needsQuote ? `"${cell}"` : cell;
        }).join(', ');
    outTA.value = text;
    countEl.textContent = `${items.length} item${items.length===1?'':'s'}`;
  }

  function generate(){
    const f = Number(fldInp.value);
    if (!Number.isInteger(f) || f < 1){
      alert('Field # must be an integer ≥ 1.');
      return;
    }
    const vals = collectFieldValues(f - 1);
    renderOutput(vals);
  }

  function openModal(){
  if (!ensureRefs()) return;

  // Default scope text if empty
  if (!scopeEl.textContent.trim()) scopeEl.textContent = 'doc';

  // Show modal
  modal.style.display = 'flex';

  // Focus Field # after paint
  setTimeout(() => fldInp.focus(), 0);

  // Auto-generate output immediately
  generate();
}

  function closeModal(){ if (modal) modal.style.display = 'none'; }

  // Public opener used by the menubar wiring
  window.openListExtractor = openModal;

  // (Intentionally NOT wiring the menu item here; the menubar script already does it and calls closeAll().)
})();
</script>
<!-- Duplicate End Tokens Modal -->
<div class="overlay" id="dupes-modal" aria-hidden="true">
  <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="dupesTitle">
    <div class="title" id="dupesTitle">Duplicate End Field Tokens</div>
    <div class="hint">Shows each end-field token that appears in <b>2+</b> tuples. List is de-duplicated.</div>

    <div id="dupesListWrap">
      <div id="dupesHeader" style="padding:8px 10px;">
        <span id="dupesCount">Scanning…</span>
        <input id="dupesSearch" type="text" placeholder="Filter tokens…">
      </div>
      <div id="dupesList" role="list"></div>
    </div>

    <div class="btns" style="margin-top:12px;">
      <button id="dupesCopyAllBtn" class="dupeBtn">Copy All</button>
      <button id="dupesCloseBtn" class="primary">Close</button>
    </div>
  </div>
</div>
<!-- List Extractor Modal -->
<div class="overlay" id="list-extractor-modal" aria-hidden="true">
  <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="listExtractorTitle">
    <div class="title" id="listExtractorTitle">List Extractor</div>
    <div class="hint">Build a CSV list from a specific field across <b>doc</b> or a set number.</div>

    <div class="divider"></div>

    <!-- Scope (same pattern as Set Field modal) -->
    <div class="title" style="font-size:14px; margin:0;">Scope</div>
    <div class="row">
      <div id="listScopeInput" class="scopeInput" contenteditable="true" data-ph="doc or 1, 2, 3…">doc</div>
      <small class="hint" style="margin-top:11px;">Type <b>doc</b> for the whole document, or a 1-based set number.</small>
    </div>

    <div class="divider"></div>

    <!-- Field + output options -->
    <div class="row">
      <label>Field #
        <input type="number" id="le_field" min="1" value="1" style="width:90px;">
      </label>

      <label>Output
        <select id="le_output_mode">
          <option value="csv">Comma-separated (single line)</option>
          <option value="lines">One per line</option>
        </select>
      </label>

      <label>
        <input type="checkbox" id="le_trim" checked>
        Trim values
      </label>

      <label>
        <input type="checkbox" id="le_unique">
        Unique only
      </label>
    </div>

    <div class="divider"></div>

    <!-- Results -->
    <div class="row" style="width:100%;">
      <textarea id="le_result" readonly
        style="width:100%; min-height:160px; resize:vertical; background:var(--editor); color:var(--fg); border:1px solid var(--border); border-radius:8px; padding:10px; font-family: ui-monospace, Menlo, Consolas, monospace; font-size:13px;"></textarea>
    </div>

    <div class="row" style="justify-content:space-between; align-items:center;">
      <span id="le_count" class="hint">0 items</span>
      <div class="btns" style="margin:0;">
        <button id="le_copyBtn" class="dupeBtn">Copy</button>
        <button id="le_closeBtn" class="primary">Close</button>
      </div>
    </div>
  </div>
</div>
<!-- Field Swapper Modal -->
<div class="overlay" id="field-swapper-modal" aria-hidden="true">
  <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="fsTitle">
    <div class="title" id="fsTitle">Field Swapper</div>
    <div class="hint">
      Drag to reorder. Double-click a name to edit. Applies to the whole document.
    </div>

    <div class="fs-list-wrap">
      <ul class="fs-list" id="fsList" aria-label="Field order"></ul>
    </div>

    <div class="btns" style="margin-top:12px;">
      <button id="fsCancelBtn">Cancel</button>
      <button id="fsApplyBtn" class="primary">Apply Order to Document</button>
    </div>
  </div>
</div>
<script id="field-swapper-plugin">
(() => {
  // Session-only persistence (no localStorage)
  // byArity[n] = { order: number[], labels: string[] }
  const SWAPPER_STATE = { byArity: Object.create(null), lastArity: 0 };

  // Host helpers already in your app:
  // textArea, findAllTuplesInLineSmart, splitFieldsRobust, joinFields
  function firstTupleParts() {
    const text = textArea.value || '';
    const lines = text.split(/\r?\n/);
    for (let i = 0; i < lines.length; i++) {
      const tuples = findAllTuplesInLineSmart(lines[i]);
      if (tuples && tuples.length) {
        const parts = splitFieldsRobust(tuples[0].raw);
        if (parts && parts.length) return parts;
      }
    }
    return null;
  }

  // Universal label
  const UNIVERSAL_LABEL = 'Field Name';

  function defaultLabels(n) {
    return Array.from({ length: n }, () => UNIVERSAL_LABEL);
  }

  // Always coerce blanks to "Field Name"
  function sanitizeLabels(labels) {
    return labels.map(v => {
      const t = (v ?? '').trim();
      return t || UNIVERSAL_LABEL;
    });
  }

  // Modal hooks (reuse existing HTML/CSS)
  const modal   = document.getElementById('field-swapper-modal');
  const menuBtn = document.getElementById('mnuFieldSwapper');

  function getListEl() {
    return modal ? (modal.querySelector('.fs-list') || modal.querySelector('#fsList')) : null;
  }
  function getApplyBtn() {
    return modal && (
      modal.querySelector('#fsApplyBtn') ||
      modal.querySelector('button.apply-order') ||
      modal.querySelector('[data-action="apply-order"]') ||
      modal.querySelector('button.primary')
    );
  }
  function getCloseBtn() {
    return modal && (
      modal.querySelector('#fsCancelBtn') ||
      modal.querySelector('[data-action="close"]') ||
      modal.querySelector('button:not(.primary)')
    );
  }
  function getRestoreBtn() {
    return modal && (
      modal.querySelector('#fsRestorePlaceholders') ||
      modal.querySelector('[data-action="restore-placeholders"]')
    );
  }

  let currentOrder = [];
  let currentLabels = [];
  let fieldCount = 0;

  function loadStateFor(n) {
    fieldCount = n;
    SWAPPER_STATE.lastArity = n;
    const s = SWAPPER_STATE.byArity[n];
    if (s) {
      currentOrder  = s.order.slice();
      currentLabels = s.labels.slice();
    } else {
      currentOrder  = [...Array(n).keys()];    // mapping: slot -> original index
      currentLabels = defaultLabels(n);
    }
  }
  function saveState() {
    currentLabels = sanitizeLabels(currentLabels);
    SWAPPER_STATE.byArity[fieldCount] = {
      order: currentOrder.slice(),
      labels: currentLabels.slice()
    };
  }

  function relabelDomFromState(list) {
    currentLabels = sanitizeLabels(currentLabels);
    const items = Array.from(list.children);
    items.forEach((li, i) => {
      const num = li.querySelector('.fs-num');
      if (num) {
        // You can keep showing original index or slot number; left as-is
        // Here we continue to show ORIGINAL index to help users track identity:
        const origIdx = currentOrder[i] ?? i;
        num.textContent = String(origIdx + 1);
      }
      const nm = li.querySelector('.fs-name');
      if (nm) {
        nm.textContent = currentLabels[i] || UNIVERSAL_LABEL;
        nm.setAttribute('data-ph', UNIVERSAL_LABEL);
      }
    });
  }

  function renderList() {
    const list = getListEl();
    if (!list) return;

    const first = firstTupleParts();
    list.innerHTML = '';

    if (!first || !first.length) {
      const li = document.createElement('li');
      li.className = 'fs-item';
      li.textContent = 'No tuples detected.';
      list.appendChild(li);
      return;
    }

    const n = first.length;
    loadStateFor(n);
    currentLabels = sanitizeLabels(currentLabels);

    for (let i = 0; i < n; i++) {
      const origIndex = currentOrder[i];

      const li = document.createElement('li');
      li.className = 'fs-item';
      li.draggable = true;
      li.dataset.slotIndex = String(i);
      li.dataset.origIndex = String(origIndex);

      const h = document.createElement('div');
      h.className = 'fs-handle';
      h.setAttribute('aria-hidden', 'true');
      h.textContent = '≡';

      const num = document.createElement('div');
      num.className = 'fs-num';
      num.textContent = String(origIndex + 1); // show original index (optional)

      const nm = document.createElement('div');
      nm.className = 'fs-name';
      nm.setAttribute('contenteditable', 'true');
      nm.setAttribute('data-ph', UNIVERSAL_LABEL);
      nm.textContent = currentLabels[i] || UNIVERSAL_LABEL;

      nm.addEventListener('blur', () => {
        let raw = (nm.textContent || '').trim();
        if (!raw) {
          nm.textContent = UNIVERSAL_LABEL; // immediately restore to "Field Name"
          raw = UNIVERSAL_LABEL;
        }
        currentLabels[i] = raw;
        saveState();
      });

      li.appendChild(h);
      li.appendChild(num);
      li.appendChild(nm);
      list.appendChild(li);
    }

    initDnD(list);
  }

  function initDnD(list) {
    let draggingEl = null;

    list.querySelectorAll('.fs-item').forEach((item) => {
      item.addEventListener('dragstart', (e) => {
        draggingEl = item;
        item.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        try { e.dataTransfer.setData('text/plain', item.dataset.slotIndex || ''); } catch {}
      });

      item.addEventListener('dragend', () => {
        if (draggingEl) draggingEl.classList.remove('dragging');
        draggingEl = null;
      });

      item.addEventListener('dragover', (e) => {
        e.preventDefault();
        if (!draggingEl || draggingEl === item) return;
        const rect = item.getBoundingClientRect();
        const before = (e.clientY - rect.top) < (rect.height / 2);
        item.classList.toggle('drop-before', before);
        item.classList.toggle('drop-after', !before);
      });

      item.addEventListener('dragleave', () => {
        item.classList.remove('drop-before', 'drop-after');
      });

      item.addEventListener('drop', (e) => {
        e.preventDefault();
        item.classList.remove('drop-before', 'drop-after');
        if (!draggingEl || draggingEl === item) return;

        const children = Array.from(list.children);
        const from = children.indexOf(draggingEl);
        const to   = children.indexOf(item);

        const rect = item.getBoundingClientRect();
        const before = (e.clientY - rect.top) < (rect.height / 2);
        let insertAt = to + (before ? 0 : 1);
        if (from < to && !before) insertAt--;

        // DOM move
        list.removeChild(draggingEl);
        if (insertAt >= list.children.length) list.appendChild(draggingEl);
        else list.insertBefore(draggingEl, list.children[insertAt]);

        // State move (keep label with the moved item)
        const movedOrder  = currentOrder.splice(from, 1)[0];
        const movedLabel  = currentLabels.splice(from, 1)[0];
        currentOrder.splice(insertAt, 0, movedOrder);
        currentLabels.splice(insertAt, 0, movedLabel);

        saveState();
        // Re-label DOM to keep "Field Name" rule consistent
        relabelDomFromState(list);
      });
    });
  }

  // Apply: reorder tuples according to currentOrder, preserving values
  function reorderTupleParts(parts, order) {
    const out = new Array(parts.length);
    for (let i = 0; i < parts.length; i++) {
      const src = order[i];
      if (src == null || src < 0 || src >= parts.length) return null;
      out[i] = parts[src];
    }
    return out;
  }

  function applyOrderAcrossDocument() {
    const first = firstTupleParts();
    if (!first) return;

    const n = first.length;
    const state = SWAPPER_STATE.byArity[n];
    if (!state) return;

    const order = state.order.slice();
    state.labels = sanitizeLabels(state.labels);

    const lines = textArea.value.split(/\r?\n/);
    for (let li = 0; li < lines.length; li++) {
      let line = lines[li];
      if (!line.trim()) continue;

      const tuples = findAllTuplesInLineSmart(line);
      if (!tuples.length) continue;

      let newLine = line;
      for (let k = tuples.length - 1; k >= 0; k--) {
        const t = tuples[k];
        const before = newLine.slice(0, t.open);
        const raw    = newLine.slice(t.open, t.close);
        const after  = newLine.slice(t.close);

        const parts = splitFieldsRobust(raw);
        if (!parts || parts.length !== n) continue;

        const reordered = reorderTupleParts(parts, order);
        if (!reordered) continue;

        newLine = before + joinFields(reordered) + after;
      }
      lines[li] = newLine;
    }

    textArea.value = lines.join('\n');
    try { pushSnapshot && pushSnapshot(); } catch {}
    try { updateRowsCountPill && updateRowsCountPill(); } catch {}
  }

  // Open / Close & Buttons
  function openModal() { if (!modal) return; renderList(); modal.style.display = 'flex'; }
  function closeModal(){ if (!modal) return; modal.style.display = 'none'; }

  if (menuBtn) menuBtn.addEventListener('click', openModal);

  if (modal) {
    modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });

    const applyBtn = getApplyBtn();
    if (applyBtn) applyBtn.addEventListener('click', () => { applyOrderAcrossDocument(); closeModal(); });

    const closeBtn = getCloseBtn();
    if (closeBtn) closeBtn.addEventListener('click', closeModal);

    const restoreBtn = getRestoreBtn();
    if (restoreBtn) restoreBtn.addEventListener('click', () => {
      // Reset every label to "Field Name"
      const list = getListEl();
      if (!list) return;
      currentLabels = defaultLabels(currentLabels.length);
      saveState();
      relabelDomFromState(list);
    });

    modal.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeModal(); });
  }
})();
</script>
<script id="append-prepend-plugin">
/*
  Append/Prepend Plugin (raw-preserving)
  - Opens from Tools → Field → Append/Prepend (button id: mnuFieldAppendPrepend)
  - Modal id: append-prepend-modal
  - Preserves user input exactly — NO extra escaping or quote transforms.
  - Depends on host helpers already in your app:
      - textArea
      - findAllTuplesInLineSmart(line)
      - splitFieldsRobust(tupleRaw)
      - joinFields(parts)
      - isEmptyQuotedField(str)         (optional; we also do our own empty check)
*/

document.addEventListener('DOMContentLoaded', () => {
  // --- Quick accessors ---
  const get = (id) => document.getElementById(id);

  // --- Quote helpers: preserve raw content exactly ---
  function isQuotedPart(part) {
    const t = String(part).trim();
    return t.startsWith("'") && t.endsWith("'");
  }
  function rawInner(part) {
    // Returns the raw text between the FIRST and LAST single quote—no un/escaping
    const t = String(part).trim();
    return t.slice(1, -1);
  }

  // Empty detection that respects the user's raw content
  function partIsEmpty(part) {
    const t = String(part).trim();
    if (t.length === 0) return true;
    if (isQuotedPart(t)) {
      const inner = rawInner(t);
      return inner.trim().length === 0;
    }
    // Unquoted non-empty chars count as non-empty
    return false;
  }

  // Concatenate while preserving target's quoting style and raw characters
  function concatPreservingTarget(targetPart, addStr, op /* 'append' | 'prepend' */) {
    const t = String(targetPart);
    if (isQuotedPart(t)) {
      const inner = rawInner(t); // raw between quotes
      const newInner = (op === 'prepend') ? (addStr + inner) : (inner + addStr);
      return "'" + newInner + "'"; // re-wrap in single quotes, keep content as-is
    } else {
      const base = t.trim();
      return (op === 'prepend') ? (addStr + base) : (base + addStr);
    }
  }

  // Apply a tuple-modifier across the entire document
  function applyAcrossDocument(modifier) {
    const ta = get('textArea');
    if (!ta) return;

    const lines = ta.value.split(/\r?\n/);
    let changed = false;

    for (let i = 0; i < lines.length; i++) {
      const tuples = findAllTuplesInLineSmart(lines[i]);
      if (!tuples.length) continue;

      let out = lines[i];

      // Replace from the end to keep indices stable
      for (let k = tuples.length - 1; k >= 0; k--) {
        const t = tuples[k];
        const before = out.slice(0, t.open);
        const after  = out.slice(t.close);
        const parts  = splitFieldsRobust(t.raw);

        const updated = modifier(parts);
        if (updated) {
          out = before + joinFields(updated) + after;
          changed = true;
        }
      }
      lines[i] = out;
    }

    if (changed) {
      const prevStart = ta.selectionStart, prevEnd = ta.selectionEnd;
      ta.value = lines.join('\n');
      // Try to preserve caret/selection
      ta.setSelectionRange(prevStart, prevEnd);
      // If host has snapshotting, record it
      if (typeof window.pushSnapshot === 'function') {
        window.pushSnapshot();
      }
      if (typeof window.updateRowsCountPill === 'function') {
        window.updateRowsCountPill();
      }
    }
  }

  // ===== Field mode: Target = Target [Append/Prepend] × Field =====
  function runFieldMode() {
    const tgt1 = Number(get('ap_target_field_f')?.value ?? 1);
    const src1 = Number(get('ap_source_field')?.value ?? 2);
    const op   = get('ap_op_f')?.value || 'append';

    if (!Number.isInteger(tgt1) || tgt1 < 1) { alert('Target field must be an integer ≥ 1.'); return; }
    if (!Number.isInteger(src1) || src1 < 1) { alert('Source field must be an integer ≥ 1.'); return; }

    applyAcrossDocument((parts) => {
      const tgt0 = tgt1 - 1;
      const src0 = src1 - 1;
      if (tgt0 >= parts.length || src0 >= parts.length) return null;

      const targetPart = parts[tgt0];
      const sourcePart = parts[src0];

      // "If field is empty do nothing."
      if (partIsEmpty(sourcePart) || (typeof isEmptyQuotedField === 'function' && isEmptyQuotedField(sourcePart))) return null;

      const addStr = isQuotedPart(sourcePart) ? rawInner(sourcePart) : String(sourcePart).trim();
      parts[tgt0] = concatPreservingTarget(targetPart, addStr, op);
      return parts;
    });
  }

  // ===== String mode: Target = Target [Append/Prepend] × String =====
  function runStringMode() {
    const tgt1 = Number(get('ap_target_field_s')?.value ?? 1);
    const op   = get('ap_op_s')?.value || 'append';
    const sRaw = get('ap_string_input')?.value ?? '';

    if (!Number.isInteger(tgt1) || tgt1 < 1) { alert('Target field must be an integer ≥ 1.'); return; }
    // "When input is empty do nothing."
    if (sRaw.length === 0) return;

    applyAcrossDocument((parts) => {
      const tgt0 = tgt1 - 1;
      if (tgt0 >= parts.length) return null;

      parts[tgt0] = concatPreservingTarget(parts[tgt0], sRaw, op);
      return parts;
    });
  }

  // ===== Modal wiring (open/close + buttons) =====
  function openModal() {
    const modal = get('append-prepend-modal');
    if (!modal) return;
    modal.style.display = 'flex';
  }
  function closeModal() {
    const modal = get('append-prepend-modal');
    if (!modal) return;
    modal.style.display = 'none';
  }

  // Bind menu and modal buttons
  get('mnuFieldAppendPrepend')?.addEventListener('click', openModal);
  get('ap_apply_field')?.addEventListener('click', runFieldMode);
  get('ap_apply_string')?.addEventListener('click', runStringMode);
  get('ap_close_btn')?.addEventListener('click', closeModal);

  // Click backdrop to close
  get('append-prepend-modal')?.addEventListener('click', (e) => {
    if (e.target === e.currentTarget) closeModal();
  });
});
</script>
<script id="template-maker-plugin">
document.addEventListener('DOMContentLoaded', () => {
  // Elements
  const modal   = document.getElementById('template-maker-modal');
  const openBtn = document.getElementById('mnuTemplateMaker');
  if (!modal || !openBtn) return; // HTML missing? abort quietly

  const fieldInput = document.getElementById('tmFieldIndex');
  const sepChk     = document.getElementById('tmSepBlank');
  const applyBtn   = document.getElementById('tmApplyBtn');
  const cancelBtn  = document.getElementById('tmCancelBtn');
  const altListEl  = document.getElementById('tmListAlt');

  // --- helpers ---
  function replaceNthFieldInFirstTuple(line, n1, value) {
    const tuples = findAllTuplesInLineSmart(line);
    if (!tuples.length) return line;
    const t = tuples[0];
    const before = line.slice(0, t.open);
    const after  = line.slice(t.close);
    const parts  = splitFieldsRobust(t.raw);

    const idx0 = (n1|0) - 1;
    if (idx0 < 0 || idx0 >= parts.length) return line;

    const target = parts[idx0];
    // If destination is quoted, escape inner single quotes by doubling them
    const v = isQuoted(target) ? `'${String(value).replace(/'/g, "''")}'` : String(value);
    parts[idx0] = v;
    return before + joinFields(parts) + after;
  }

  function getCurrentSetBounds() {
    const content = textArea.value;
    const caret   = textArea.selectionStart ?? 0;
    const info    = getLineIndexAndColumn(content, caret);
    const lines   = info.lines;
    const { start, end } = expandToSetBounds(lines, info.lineIndex, info.lineIndex);
    return { lines, start, end };
  }

  function getMethod2Items() {
    const raw = (altListEl?.value ?? '').trim();
    if (!raw) return [];
    return raw.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
  }

  function getMethod1Items() {
    // falls back to your already-collected Copy Board items
    // (collectedItems is provided by your board logic)
    return Array.isArray(collectedItems) ? collectedItems : [];
  }

  function getSourceItems() {
    // Prefer Method 2 when textarea is non-empty; otherwise use Copy Board (Method 1)
    const m2 = getMethod2Items();
    if (m2.length > 0) return m2;
    return getMethod1Items();
  }

  function applyTemplate() {
    const fieldN = Number(fieldInput.value);
    if (!Number.isInteger(fieldN) || fieldN < 1) {
      alert('Enter a valid 1-based field index (≥ 1).');
      return;
    }

    const items = getSourceItems();
    if (!Array.isArray(items) || items.length === 0) {
      alert('No items found. Add items to Copy Board (Method 1) or paste a one-per-line list (Method 2).');
      return;
    }

    const { lines, start, end } = getCurrentSetBounds();
    if (start === end) { alert('No active set at caret. Place caret inside a block.'); return; }

    const baseSet = lines.slice(start, end);
    const outputs = [];
    for (const item of items) {
      const copy = baseSet.map(line => replaceNthFieldInFirstTuple(line, fieldN, item));
      outputs.push(copy.join('\n'));
    }

    // Build final block; keep user’s "blank line between copies" setting
    const block = outputs.join(sepChk && sepChk.checked ? '\n\n' : '\n');

    // Append after the document's last set with EXACTLY one blank line separation
    let doc = textArea.value.replace(/\s+$/, '');
    textArea.value = doc + '\n\n' + block;

    const caret = textArea.selectionStart ?? textArea.value.length;
    textArea.setSelectionRange(caret, caret);

    try { pushSnapshot(); } catch {}
    try { updateRowsCountPill(); } catch {}
    try { updateBoardView(); } catch {}
  }

  // --- modal wiring ---
  function openModal() {
    try { window.closeAll?.(); } catch {}
    modal.style.display = 'flex';
    setTimeout(() => fieldInput?.focus(), 0);
  }
  function closeModal() { modal.style.display = 'none'; }

  openBtn.addEventListener('click', openModal);
  applyBtn.addEventListener('click', () => { applyTemplate(); closeModal(); });
  cancelBtn.addEventListener('click', closeModal);
  modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });
  document.addEventListener('keydown', (e) => {
    if (modal.style.display === 'flex' && e.key === 'Escape') closeModal();
  });
});
</script>
<!-- Append/Prepend Modal -->
<div class="overlay" id="append-prepend-modal" aria-modal="true" role="dialog">
  <div class="dialog">
    <div class="title">Append / Prepend</div>
    <div class="hint">Operate across the entire document. If the chosen source/string is empty, that tuple is skipped.</div>

    <!-- A) Target = Target [Append/Prepend] × Field -->
    <div class="title" style="font-size:14px;margin:8px 0 6px;">A) Target field ⟵ target [Append/Prepend] × field</div>
    <div class="row">
      <label>Target field
        <input type="number" id="ap_target_field_f" min="1" value="1" style="width:90px;">
      </label>
      <label>Operation
        <select id="ap_op_f">
          <option value="append">Append</option>
          <option value="prepend">Prepend</option>
        </select>
      </label>
      <label>× Field
        <input type="number" id="ap_source_field" min="1" value="2" style="width:90px;">
      </label>
    </div>
    <div class="btns">
      <button id="ap_apply_field" class="primary">Apply Field → Target</button>
    </div>

    <div class="divider"></div>

    <!-- B) Target = Target [Append/Prepend] × String -->
    <div class="title" style="font-size:14px;margin:8px 0 6px;">B) Target field ⟵ target [Append/Prepend] × string</div>
    <div class="row">
      <label>Target field
        <input type="number" id="ap_target_field_s" min="1" value="1" style="width:90px;">
      </label>
      <label>Operation
        <select id="ap_op_s">
          <option value="append">Append</option>
          <option value="prepend">Prepend</option>
        </select>
      </label>
      <label>× String
        <input type="text" id="ap_string_input" placeholder="leave empty to skip">
      </label>
    </div>
    <div class="btns">
      <button id="ap_apply_string" class="primary">Apply String → Target</button>
      <button id="ap_close_btn">Close</button>
    </div>
  </div>
</div>
<!-- Template Maker Modal -->
<!-- Template Maker Modal -->
<div class="overlay" id="template-maker-modal" aria-modal="true" role="dialog">
  <div class="dialog">
    <div class="title">Template Maker</div>

    <!-- Shared options -->
    <div class="row" style="margin-bottom:6px;">
      <label>Field # (1-based)
        <input type="number" id="tmFieldIndex" min="1" value="1" style="width:100px;">
      </label>
      <label style="margin-left:8px;">
        <input type="checkbox" id="tmSepBlank" checked>
        Add blank line between copies
      </label>
    </div>

    <!-- Method 1 -->
    <div class="hint" style="margin-top:6px;"><b>Method 1 — Use Copy Board (CSV-aware)</b></div>
    <div class="hint">
      The <b>current set</b> (block around the caret) becomes a <b>working template</b>.
      A copy is created for each item in the <b>Copy Board</b>, and that item is placed in the chosen
      <b>n’th field</b> of <em>every row</em> in that copy. All copies are appended to the end of the document.
    </div>
    <div class="btns" style="margin-top:8px;">
      <button id="tmApplyCBBtn" class="primary">Make Templates from Copy Board</button>
    </div>

    <div class="divider"></div>

    <!-- Method 2 -->
    <div class="hint"><b>Method 2 — One-per-line list</b></div>
    <div class="hint" style="margin-bottom:6px;">
      <i>Note:</i> Copy Board uses a CSV list. Place a <b>one-per-line</b> list here to maintain commas inside a field item.
    </div>
    <div class="row" style="margin-bottom:0;">
      <textarea id="tmListAlt" placeholder="one item per line…" style="width:100%;min-height:120px;background:var(--editor);color:var(--fg);border:1px solid var(--border);border-radius:8px;padding:10px;font-family: ui-monospace, Menlo, Consolas, monospace;line-height:1.4;"></textarea>
    </div>
    <div class="row">
      <small class="hint">
        Tip: The set is the block of non-blank lines around your caret. If the field index is larger than the row’s field count,
        that row is skipped (keeps the original row).
      </small>
    </div>
    <div class="btns">
      <button id="tmApplyLinesBtn" class="primary">Make Templates from Lines</button>
      <button id="tmCloseBtn">Close</button>
    </div>
  </div>
</div>
<script id="template-maker-plugin">
/**
 * Template Maker (v2)
 * - Two independent methods, each with its own fire button:
 *   (1) Copy Board (CSV/lines/whitespace aware, uses your collectedItems)
 *   (2) One-per-line textarea (preserves commas within items)
 * - Appends all generated copies to the **end of the document**, with optional 1 blank line between
 * - Single-fire bindings, DOMContentLoaded-wrapped, defensive fallbacks to your existing helpers
 */
(function () {
  document.addEventListener('DOMContentLoaded', () => {
    if (window.__tm_v2_init) return; // idempotent
    window.__tm_v2_init = true;

    // ---- Element refs
    const modal          = document.getElementById('template-maker-modal');
    const openBtn        = document.getElementById('mnuTemplateMaker');
    const closeBtn       = document.getElementById('tmCloseBtn');
    const fieldInput     = document.getElementById('tmFieldIndex');
    const sepChk         = document.getElementById('tmSepBlank');
    const applyCBBtn     = document.getElementById('tmApplyCBBtn');
    const applyLinesBtn  = document.getElementById('tmApplyLinesBtn');
    const altListEl      = document.getElementById('tmListAlt');
    const editor         = window.textArea || document.getElementById('textArea');

    if (!modal || !openBtn || !fieldInput || !applyCBBtn || !applyLinesBtn || !editor) {
      console.warn('[TemplateMaker v2] Missing required DOM nodes.');
      return;
    }

    // ---- App helpers (prefer your existing ones)
    const joinFields = (parts) => (typeof window.joinFields === 'function')
      ? window.joinFields(parts)
      : '(' + parts.join(', ') + ')';

    const getLineIndexAndColumn = (text, pos) => {
      if (typeof window.getLineIndexAndColumn === 'function') return window.getLineIndexAndColumn(text, pos);
      const lines = text.split(/\r?\n/);
      let acc = 0;
      for (let i = 0; i < lines.length; i++) {
        const len = lines[i].length + 1;
        if (pos <= acc + len - 1) return { lines, lineIndex: i, column: pos - acc };
        acc += len;
      }
      return { lines, lineIndex: lines.length - 1, column: lines.at(-1)?.length ?? 0 };
    };

    const expandToSetBounds = (lines, startIdx) => {
      if (typeof window.expandToSetBounds === 'function') {
        const ex = window.expandToSetBounds(lines, startIdx, startIdx);
        return { start: ex.start, end: ex.end };
      }
      // contiguous non-blank block
      let s = startIdx, e = startIdx;
      while (s > 0 && lines[s - 1].trim() !== '') s--;
      while (e < lines.length - 1 && lines[e + 1].trim() !== '') e++;
      return { start: s, end: e + 1 }; // end is exclusive
    };

    const findAllTuplesInLineSmart = (line) => (typeof window.findAllTuplesInLineSmart === 'function')
      ? window.findAllTuplesInLineSmart(line)
      : []; // bail if not available

    const splitFieldsRobust = (tupleRaw) => (typeof window.splitFieldsRobust === 'function')
      ? window.splitFieldsRobust(tupleRaw)
      : []; // bail if not available

    const isQuoted = (s) => {
      const t = String(s).trim();
      return t.startsWith("'") && t.endsWith("'");
    };

    // Extract the **current set** as lines and tuple segments
    function getCurrentSetInfo() {
      const content = editor.value;
      const caret   = editor.selectionStart ?? 0;
      const { lines, lineIndex } = getLineIndexAndColumn(content, caret);
      const { start, end } = expandToSetBounds(lines, lineIndex);
      return { content, lines, start, end };
    }

    // Build copies: for each item, clone the set and put item into nth field of every tuple in that set
    function buildCopiesFromItems(items, n1, addBlank) {
      if (!Array.isArray(items) || items.length === 0) return '';

      const { content, lines, start, end } = getCurrentSetInfo();
      const setLines = lines.slice(start, end); // exclusive end
      const copies = [];

      for (const rawItem of items) {
        const item = String(rawItem);
        const newLines = setLines.map((line) => {
          if (!line.trim()) return line;

          const tuples = findAllTuplesInLineSmart(line);
          if (!tuples.length) return line;

          // Apply to ALL tuples in the line
          let out = line;
          for (let k = tuples.length - 1; k >= 0; k--) {
            const t = tuples[k];
            const before = out.slice(0, t.open);
            const after  = out.slice(t.close);
            const parts  = splitFieldsRobust(t.raw);

            const idx0 = (n1|0) - 1;
            if (idx0 < 0 || idx0 >= parts.length) continue; // skip row if field too large

            const target = parts[idx0];
            parts[idx0] = isQuoted(target)
              ? `'${item.replace(/'/g, "''")}'`
              : item;

            out = before + joinFields(parts) + after;
          }
          return out;
        });

        copies.push(newLines.join('\n'));
      }

      // Append with exactly one blank line between copies if requested
      const sep = addBlank ? '\n\n' : '\n';
      return copies.join(sep);
    }

    // Tokenize board text using your app’s logic (already present in your file)
    function itemsFromCopyBoard() {
      // Prefer the live queue if present; otherwise parse #board
      if (Array.isArray(window.collectedItems) && window.collectedItems.length) {
        return window.collectedItems.slice();
      }
      const boardArea = document.getElementById('board');
      if (!boardArea) return [];
      // Fallback: use your existing tokenizer if available
      if (typeof window.tokenizeAuto === 'function') return window.tokenizeAuto(boardArea.value);
      // Very safe fallback: split on newlines
      return boardArea.value.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    }

    function itemsFromLinesTextarea() {
      const raw = (altListEl?.value ?? '').replace(/\r/g, '');
      return raw.split('\n').map(s => s.trim()).filter(Boolean);
    }

    function appendToDocumentWithTrailingBlankBlock(block) {
      if (!block) return;

      const doc = editor.value.replace(/\r/g, '');
      const docEndsWithBlank =
        /\n\s*\n$/.test(doc) || doc.trim() === '';

      // Always ensure **exactly one** full blank line separates last set and the new block
      const spacer = doc.trim() === '' ? '' : (docEndsWithBlank ? '\n' : '\n\n');
      editor.value = doc + spacer + block;
    }

    // ---- Method 1: Copy Board
    function applyFromCopyBoard() {
      const n1 = Number(fieldInput.value || 1);
      if (!Number.isInteger(n1) || n1 < 1) { alert('Enter a valid 1-based field index.'); return; }

      const items = itemsFromCopyBoard();
      if (!items.length) { alert('Copy Board is empty.'); return; }

      const block = buildCopiesFromItems(items, n1, !!sepChk.checked);
      appendToDocumentWithTrailingBlankBlock(block);
    }

    // ---- Method 2: One-per-line textarea
    function applyFromLines() {
      const n1 = Number(fieldInput.value || 1);
      if (!Number.isInteger(n1) || n1 < 1) { alert('Enter a valid 1-based field index.'); return; }

      const items = itemsFromLinesTextarea();
      if (!items.length) { alert('Please provide one-per-line items.'); return; }

      const block = buildCopiesFromItems(items, n1, !!sepChk.checked);
      appendToDocumentWithTrailingBlankBlock(block);
    }

    // ---- Modal open/close
    function openModal() {
      try { (closeBtn || {}).blur?.(); } catch {}
      modal.style.display = 'flex';
      setTimeout(() => fieldInput?.focus(), 0);
    }
    function closeModal() { modal.style.display = 'none'; }

    // ---- Bindings (replace → rebind for single-fire)
    openBtn.addEventListener('click', openModal, { once: false });
    applyCBBtn.addEventListener('click', () => { applyFromCopyBoard(); closeModal(); }, { once: false });
    applyLinesBtn.addEventListener('click', () => { applyFromLines(); closeModal(); }, { once: false });
    closeBtn?.addEventListener('click', closeModal, { once: false });

    modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });
    document.addEventListener('keydown', (e) => {
      if (modal.style.display === 'flex' && e.key === 'Escape') closeModal();
    });
  });
})();
</script>
<script id="copy-field-across-set-plugin">
/**
 * Copy Current Field Across Set — Hotkey: Ctrl/Cmd + K
 * - Detects which tuple & field the caret is in.
 * - Copies that field's value and writes it into the same field index
 *   for every tuple of the current set (contiguous non-blank lines).
 * - If the destination field is quoted, we auto-quote the value (and escape single quotes).
 * - Uses app helpers when available; otherwise falls back to robust internal logic.
 */
(function () {
  document.addEventListener('DOMContentLoaded', () => {
    if (window.__copy_field_across_init__) return;
    window.__copy_field_across_init__ = true;

    const editor = window.textArea || document.getElementById('textArea');
    if (!editor) return console.warn('[CopyFieldAcross] textarea not found');

    // ---------- Helper: join fields into a tuple string ----------
    const joinFields = (parts) => {
      if (typeof window.joinFields === 'function') return window.joinFields(parts);
      return '(' + parts.join(', ') + ')';
    };

    // ---------- Helper: expand to set bounds (contiguous non-blank lines) ----------
    function getLineIndexAndColumn(text, pos) {
      if (typeof window.getLineIndexAndColumn === 'function') return window.getLineIndexAndColumn(text, pos);
      const lines = text.split(/\r?\n/);
      let acc = 0;
      for (let i = 0; i < lines.length; i++) {
        const len = lines[i].length + 1; // +1 newline
        if (pos <= acc + len - 1) return { lines, lineIndex: i, column: pos - acc };
        acc += len;
      }
      return { lines, lineIndex: lines.length - 1, column: lines.at(-1)?.length ?? 0 };
    }
    function expandToSetBounds(lines, anchorIdx) {
      if (typeof window.expandToSetBounds === 'function') {
        const r = window.expandToSetBounds(lines, anchorIdx, anchorIdx);
        return { start: r.start, end: r.end }; // end exclusive (per your helper)
      }
      let s = anchorIdx, e = anchorIdx;
      while (s > 0 && lines[s - 1].trim() !== '') s--;
      while (e < lines.length - 1 && lines[e + 1].trim() !== '') e++;
      return { start: s, end: e + 1 };
    }

    // ---------- Tuple + field parsing ----------
    const findAllTuplesInLineSmart = (line) => {
      if (typeof window.findAllTuplesInLineSmart === 'function') return window.findAllTuplesInLineSmart(line);
      // Fallback: naive matcher for (...) blocks; relies on your robust helper when available.
      const r = [];
      let i = 0;
      while (i < line.length) {
        const open = line.indexOf('(', i);
        if (open === -1) break;
        let depth = 0, j = open;
        for (; j < line.length; j++) {
          if (line[j] === '(') depth++;
          else if (line[j] === ')') {
            depth--;
            if (depth === 0) { j++; break; }
          }
        }
        if (depth === 0) {
          const raw = line.slice(open, j);
          r.push({ open, close: j, raw });
          i = j;
        } else {
          break;
        }
      }
      return r;
    };

    // Split tuple into fields WITH spans (start/end within tupleRaw)
    // Handles single-quoted fields ('' for escaped apostrophe) and commas outside quotes.
    function splitFieldsWithSpans(tupleRaw) {
      // If app has a robust splitter that returns plain strings, we’ll adapt to spans.
      if (typeof window.splitFieldsRobust === 'function') {
        const arr = window.splitFieldsRobust(tupleRaw); // array of field strings
        // Build spans by locating fields progressively (best-effort, stable if joinFields uses ", ").
        let cursor = 0;
        const parts = [];
        for (let i = 0; i < arr.length; i++) {
          const needle = arr[i].trim();
          // Search forward for the next occurrence bounded by commas or parens
          // Simple scan: skip leading spaces, commas, parens
          while (cursor < tupleRaw.length && /\s|,|\(|\)/.test(tupleRaw[cursor])) cursor++;
          let start = cursor;
          // Expand until we hit a comma at the same paren depth (here within tupleRaw only)
          let inQuote = false;
          for (; cursor < tupleRaw.length; cursor++) {
            const ch = tupleRaw[cursor];
            if (ch === "'" && (!inQuote || tupleRaw[cursor + 1] !== "'")) inQuote = !inQuote;
            if (!inQuote && ch === ',') break;
            if (!inQuote && ch === ')') break;
          }
          let end = cursor;
          parts.push({ text: tupleRaw.slice(start, end).trim(), start, end });
          // Move past comma if present
          if (tupleRaw[cursor] === ',') cursor++;
        }
        return annotateQuoted(parts);
      }

      // Local robust parser
      const parts = [];
      // Strip outer parens if present for easier indexing
      let bodyStart = 0, bodyEnd = tupleRaw.length;
      if (tupleRaw.trim().startsWith('(')) {
        bodyStart = tupleRaw.indexOf('(') + 1;
        bodyEnd   = tupleRaw.lastIndexOf(')');
      }
      if (bodyEnd < bodyStart) { bodyStart = 0; bodyEnd = tupleRaw.length; }
      const s = tupleRaw.slice(bodyStart, bodyEnd);
      let i = 0, start = 0, inQ = false;
      while (i <= s.length) {
        const ch = s[i];
        const atEnd = i === s.length;
        if (!inQ && (ch === ',' || atEnd)) {
          const raw = s.slice(start, atEnd ? i : i).trim();
          parts.push({ text: raw, start: bodyStart + start, end: bodyStart + (atEnd ? i : i) });
          start = i + 1;
          i++;
          continue;
        }
        if (ch === "'") {
          if (inQ) {
            // check doubled quote escape
            if (s[i + 1] === "'") { i += 2; continue; }
            inQ = false; i++; continue;
          } else { inQ = true; i++; continue; }
        }
        i++;
      }
      return annotateQuoted(parts);

      function annotateQuoted(parts) {
        return parts.map(p => {
          const t = p.text.trim();
          const quoted = t.startsWith("'") && t.endsWith("'");
          const inner = quoted ? t.slice(1, -1).replace(/''/g, "'") : t;
          return { ...p, quoted, text: t, inner };
        });
      }
    }

    // ---------- Core operation ----------
    function copyCurrentFieldAcrossSet() {
      const content = editor.value.replace(/\r/g, '');
      const caret   = editor.selectionStart ?? 0;
      const { lines, lineIndex, column } = getLineIndexAndColumn(content, caret);

      // Identify current tuple and field under caret
      const line = lines[lineIndex] ?? '';
      const tuples = findAllTuplesInLineSmart(line);
      if (!tuples.length) return; // not inside a tuple line — do nothing

      // Find the tuple containing the caret
      const absOffsetOfLine = (() => {
        let off = 0;
        for (let i = 0; i < lineIndex; i++) off += (lines[i].length + 1);
        return off;
      })();
      const caretAbs = absOffsetOfLine + column;

      let tupleIdx = -1;
      for (let i = 0; i < tuples.length; i++) {
        const t = tuples[i];
        const openAbs = absOffsetOfLine + t.open;
        const closeAbs = absOffsetOfLine + t.close;
        if (caretAbs >= openAbs && caretAbs <= closeAbs) { tupleIdx = i; break; }
      }
      if (tupleIdx === -1) return; // caret not inside any tuple

      // Determine field index within that tuple
      const tCaret = tuples[tupleIdx];
      const partsWithSpans = splitFieldsWithSpans(tCaret.raw);
      const caretInTuple = caretAbs - (absOffsetOfLine + tCaret.open);
      let fieldIdx = -1;
      for (let i = 0; i < partsWithSpans.length; i++) {
        const p = partsWithSpans[i];
        if (caretInTuple >= p.start - tCaret.open && caretInTuple <= p.end - tCaret.open) {
          fieldIdx = i; break;
        }
      }
      if (fieldIdx === -1) return; // not in any field

      const src = partsWithSpans[fieldIdx]; // {text, inner, quoted}
      const srcInner = src.quoted ? src.inner : src.text;

      // Expand to current set
      const { start, end } = expandToSetBounds(lines, lineIndex);

      // Build new lines for the set
      const newLines = lines.slice(start, end).map((ln) => {
        if (!ln.trim()) return ln;
        const tps = findAllTuplesInLineSmart(ln);
        if (!tps.length) return ln;

        let out = ln;
        for (let k = tps.length - 1; k >= 0; k--) {
          const t = tps[k];
          const before = out.slice(0, t.open);
          const after  = out.slice(t.close);
          // Prefer app splitter; fallback to local spans splitter (returning plain strings for writing)
          let parts;
          if (typeof window.splitFieldsRobust === 'function') {
            parts = window.splitFieldsRobust(t.raw).slice();
          } else {
            parts = splitFieldsWithSpans(t.raw).map(p => p.text);
          }
          if (fieldIdx < 0 || fieldIdx >= parts.length) {
            out = before + t.raw + after; // unchanged
            continue;
          }

          // Respect destination quoting style
          const destRaw = parts[fieldIdx].trim();
          const destQuoted = destRaw.startsWith("'") && destRaw.endsWith("'");
          parts[fieldIdx] = destQuoted
            ? `'${String(srcInner).replace(/'/g, "''")}'`
            : String(srcInner);

          out = before + joinFields(parts) + after;
        }
        return out;
      });

      // Splice back into document
      const head = lines.slice(0, start).join('\n');
      const body = newLines.join('\n');
      const tail = lines.slice(end).join('\n');
      const glue1 = start > 0 ? '\n' : '';
      const glue2 = end < lines.length ? '\n' : '';
      editor.value = head + glue1 + body + glue2 + tail;
    }

    // ---------- Hotkey binding ----------
    function isMac() { return /Mac|iPod|iPhone|iPad/.test(navigator.platform); }
    editor.addEventListener('keydown', (e) => {
      const meta = isMac() ? e.metaKey : e.ctrlKey;
      if (meta && (e.key === 'k' || e.key === 'K')) {
        e.preventDefault();
        e.stopPropagation();
        copyCurrentFieldAcrossSet();
      }
    }, { passive: false });
  });
})();
</script>
<script id="error-handling-plugin">
/**
 * Error Handling — v3 (WORKING)
 * Changes requested:
 *  - Accept backslash-escaped apostrophes inside quoted strings: \'  (no error #2)
 *  - Keep strict SQL doubled-quote escaping valid: '' (no error #2)
 *  - Flag FORWARD slash before apostrophe as wrong escape: /' (error #3)
 *
 * Modal:   #error-handling-modal
 * List:    #ehList
 * Order (strict):
 *   (1) Unquoted string field
 *   (2) Unescaped apostrophe inside quoted field (must be '' OR \")
 *   (3) Wrong slash escape inside quoted field (detect /')
 *   (4) Field count majority (skipped if any (1) exists)
 */
(() => {
  document.addEventListener('DOMContentLoaded', () => {
    // SINGLE-FIRE GUARD
    if (window.__eh_single_init__) return;
    window.__eh_single_init__ = true;

    const modal     = document.getElementById('error-handling-modal');
    const listEl    = document.getElementById('ehList');
    const summary   = document.getElementById('ehSummary');
    const btnRescan = document.getElementById('ehRescanBtn');
    const btnClose  = document.getElementById('ehCloseBtn');
    const btnOpen   = document.getElementById('mnuErrorHandling');
    const editor    = window.textArea || document.getElementById('textArea');

    if (!modal || !listEl || !editor) return;

    // Debounce (correct syntax)
    let debounceTimer = null, scanning = false;
    const debounce = (fn, ms) => (...args) => {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => fn(...args), ms);
    };

    // Prefer app tuple finder; otherwise fallback
    const appFind = (line) => (typeof window.findAllTuplesInLineSmart === 'function')
      ? window.findAllTuplesInLineSmart(line)
      : null;

    function fallbackFind(line){
      const tuples = [];
      let inQ = false;
      for (let i = 0; i < line.length; i++){
        const ch = line[i];
        if (ch === "'"){
          if (inQ){ if (line[i+1] === "'") { i++; } else { inQ = false; } }
          else { inQ = true; }
        } else if (!inQ && ch === '('){
          const start = i; let j = i+1; let depth = 1; let q = false;
          for (; j < line.length; j++){
            const c = line[j];
            if (c === "'"){
              if (q){ if (line[j+1] === "'") { j++; } else { q = false; } }
              else { q = true; }
            } else if (!q){
              if (c === '(') depth++;
              else if (c === ')'){ depth--; if (depth === 0){ tuples.push({ open:start, close:j+1, raw: line.slice(start, j+1) }); i = j; break; } }
            }
          }
        }
      }
      return tuples;
    }

    const findAllTuples = (line) => appFind(line) ?? fallbackFind(line);

    // Utils
    const getLines = () => (editor.value || '').replace(/\r/g,'').split('\n');
    const isNumericLiteral = (s) => /^-?\d+(?:\.\d+)?$/.test(s);
    const isNullishLiteral = (s) => /^(null)$/i.test(s);

    function escapeHtml(s){
      return String(s)
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/\"/g,'&quot;')
        .replace(/'/g,'&#39;');
    }
    function push(arr, msg, lineIndex, tupleNo, fieldNo){ arr.push({ msg, lineIndex, tupleNo, fieldNo }); }

    // Quote-aware field parser → [{ raw, trimmed, quoted, innerRaw }]
    function parseFieldsWithMeta(tupleRaw){
      const open = tupleRaw.indexOf('(');
      const close = tupleRaw.lastIndexOf(')');
      if (open === -1 || close === -1 || close <= open) return [];
      const inner = tupleRaw.slice(open+1, close);

      const out = [];
      let buf = '';
      let inQ = false;
      for (let i = 0; i < inner.length; i++){
        const ch = inner[i];
        if (ch === "'"){
          if (inQ){
            if (inner[i+1] === "'") { buf += "''"; i++; }
            else { inQ = false; buf += "'"; }
          } else { inQ = true; buf += "'"; }
        } else if (!inQ && ch === ','){
          const raw = buf.trim();
          const quoted = raw.startsWith("'") && raw.endsWith("'");
          const innerRaw = quoted ? raw.slice(1, -1) : raw;
          out.push({ raw, trimmed: raw, quoted, innerRaw });
          buf = '';
        } else { buf += ch; }
      }
      const rawFinal = buf.trim();
      if (rawFinal.length || inner.endsWith(',')){
        const quoted = rawFinal.startsWith("'") && rawFinal.endsWith("'");
        const innerRaw = quoted ? rawFinal.slice(1, -1) : rawFinal;
        out.push({ raw: rawFinal, trimmed: rawFinal, quoted, innerRaw });
      }
      return out;
    }

    // Rule (2): Lone apostrophe detection
    // Accepts either doubled quotes '' OR a backslash escape before the apostrophe
    // (Handles odd/even backslashes correctly.)
    function hasUnescapedApostropheSQL_AllowBackslash(innerRaw){
      for (let i = 0; i < innerRaw.length; i++){
        const ch = innerRaw[i];
        if (ch !== "'") continue;

        // SQL doubled quote check: '' → skip both and continue
        if (innerRaw[i+1] === "'") { i++; continue; }

        // Backslash-escape check: count consecutive backslashes immediately before this apostrophe
        let bs = 0, j = i - 1;
        while (j >= 0 && innerRaw[j] === '\\') { bs++; j--; }
        if (bs % 2 === 1) { // odd → apostrophe is escaped by backslash
          continue;
        }

        // Otherwise this is a lone apostrophe → unescaped
        return true;
      }
      return false;
    }

    function scan(){
      const lines = getLines();
      const err1 = [], err2 = [], err3 = [];
      const counts = [];

      for (let li = 0; li < lines.length; li++){
        const line = lines[li];
        if (!line.trim()) continue;
        const tuples = findAllTuples(line);
        if (!tuples.length) continue;

        for (let ti = 0; ti < tuples.length; ti++){
          const t = tuples[ti];
          const fields = parseFieldsWithMeta(t.raw);
          if (!fields.length) continue;

          counts.push({ count: fields.length, lineIndex: li });

          for (let fi = 0; fi < fields.length; fi++){
            const f = fields[fi];
            const raw = f.trimmed;

            // (1) Unquoted string (non-numeric, non-null, non-empty, not quoted)
            if (!isNumericLiteral(raw) && !isNullishLiteral(raw) && raw !== '' && !f.quoted){
              push(err1, `Unquoted string field at field ${fi+1}`, li, ti+1, fi+1);
              continue;
            }

            if (f.quoted){
              // (2) Unescaped apostrophe (now allows \')
              if (hasUnescapedApostropheSQL_AllowBackslash(f.innerRaw)){
                push(err2, `Unescaped apostrophe in field ${fi+1}`, li, ti+1, fi+1);
              }
              // (3) Wrong slash escape — forward slash before apostrophe
              if (/\/'/.test(f.innerRaw)){
                push(err3, `Wrong slash escape (/' ) in field ${fi+1}`, li, ti+1, fi+1);
              }
            }
          }
        }
      }

      // (4) Majority field count (skip if any err1)
      const err4 = [];
      if (err1.length === 0 && counts.length){
        const tally = new Map();
        for (const c of counts) tally.set(c.count, (tally.get(c.count)||0)+1);
        let mode = null, hits = -1;
        for (const [cnt, n] of tally) { if (n > hits) { hits = n; mode = cnt; } }
        for (const c of counts) if (c.count !== mode) err4.push({ msg:`Field count error (found ${c.count}, expected ${mode})`, lineIndex:c.lineIndex });
      }

      return { err1, err2, err3, err4 };
    }

    function render({ err1, err2, err3, err4 }){
      listEl.innerHTML = '';
      const ordered = [...err1, ...err2, ...err3, ...err4];
      if (!ordered.length){
        if (summary) summary.textContent = 'No errors found';
        const li = document.createElement('li');
        li.className = 'eh-item';
        li.innerHTML = `<span class="eh-badge">OK</span>
                        <div class="eh-msg">No problems detected.</div>
                        <div class="eh-loc"></div>`;
        listEl.appendChild(li);
        return;
      }
      if (summary) summary.textContent = `${ordered.length} error${ordered.length===1?'':'s'}`;
      for (const it of ordered){
        const li = document.createElement('li');
        li.className = 'eh-item';
        li.innerHTML = `<span class="eh-badge error">Error</span>
                        <div class="eh-msg">${escapeHtml(it.msg)}</div>
                        <div class="eh-loc">${it.lineIndex!=null ? `line ${it.lineIndex+1}` : ''}${it.tupleNo?` · tuple ${it.tupleNo}`:''}${it.fieldNo?` · field ${it.fieldNo}`:''}</div>`;
        listEl.appendChild(li);
      }
    }

    const runScan = debounce(() => {
      if (scanning) return;
      scanning = true;
      try { render(scan()); }
      finally { scanning = false; }
    }, 140);

    // Wire controls
    const openModal  = () => { runScan(); modal.style.display = 'flex'; };
    const closeModal = () => { modal.style.display = 'none'; };

    if (btnOpen)   btnOpen.addEventListener('click', openModal);
    if (btnRescan) btnRescan.addEventListener('click', runScan);
    if (btnClose)  btnClose.addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });

    // Hotkey (as documented): Ctrl+Shift+U
    document.addEventListener('keydown', (e) => {
      const meta = e.ctrlKey || e.metaKey;
      if (meta && e.shiftKey && (e.key === 'u' || e.key === 'U')){
        e.preventDefault();
        openModal();
      }
    });
  });
})();
</script>
</body>
</html>
