<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>SQL Notepad</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root {
    --bg:#0f172a;
    --bg2:#0b1327;
    --panel:#0d1326;
    --editor:#0b1020;
    --fg:#e5e7eb;
    --muted:#94a3b8;
    --border:#1f2a44;
    --accent:#d9534f;
    --accent-hover:#c9302c;
    --pill:#111827;
  }
  [data-theme="light"] {
    --bg:#f8fafc;
    --bg2:#eef2f7;
    --panel:#ffffff;
    --editor:#ffffff;
    --fg:#0f172a;
    --muted:#475569;
    --border:#d1d5db;
    --accent:#0ea5e9;
    --accent-hover:#0284c7;
    --pill:#e5e7eb;
  }

  * { box-sizing: border-box; }
  html, body { height: 100%; margin: 0; }
  body {
    font-family: Arial, sans-serif;
    display: grid;
    grid-template-rows: auto auto 1fr;
    background: var(--bg);
    color: var(--fg);
  }

  header {
    padding: 16px 20px;
    background: var(--bg);
    border-bottom: 1px solid var(--border);
  }
  header h1 { margin: 0 0 6px; font-size: 20px; }
  /* Keep vertical space where the paragraph used to be */
  header p { margin: 0; font-size: 14px; color: var(--muted); min-height: 1.4em; }
  kbd {
    background: var(--pill);
    border: 1px solid var(--border);
    border-bottom-width: 2px;
    border-radius: 6px;
    padding: 2px 6px;
    font-family: inherit;
    font-size: 12px;
    color: var(--fg);
  }

  .bar {
    display:flex; gap:8px; align-items:center; padding:8px 20px;
    background: var(--bg2); color: var(--fg);
    border-bottom:1px solid var(--border);
    flex-wrap: wrap;
  }
  .bar .right {
    margin-left:auto; display:flex; gap:8px; align-items:center; flex-wrap:nowrap;
    white-space:nowrap;
  }
  .pill {
    background: var(--pill);
    padding: 4px 8px;
    border-radius: 999px;
    font-size: 12px;
    border: 1px solid var(--border);
  }
  .bar button {
    padding:8px 10px; font-size:14px; cursor:pointer; border:none; color:white;
    background: var(--accent); border-radius:8px;
  }
  .bar button.secondary {
    background: transparent; color: var(--fg);
    border: 1px solid var(--border);
  }
  .bar button:hover { background: var(--accent-hover); }
  .bar button.secondary:hover { background: var(--panel); }

  .wrap {
    display:grid; grid-template-columns: 300px 1fr; gap:0; height: 100%;
  }
  .wrap.board-hidden { grid-template-columns: 1fr; }
  aside.panel {
    background: var(--panel); border-right:1px solid var(--border);
    display:flex; flex-direction:column;
  }
  aside.panel.hidden { display:none; }
  aside.panel h2 { margin: 12px 12px 4px; font-size:14px; color: var(--fg); font-weight:600; }
  aside.panel small { margin: 0 12px 8px; color: var(--muted); }
  #board {
    margin: 0 12px 12px; flex:1; resize:none; width: calc(100% - 24px);
    background: var(--editor); color: var(--fg); border:1px solid var(--border);
    border-radius:8px; padding:10px;
    font-family: ui-monospace, Menlo, Consolas, monospace; font-size:13px; line-height:1.4;
  }
  .panel .row { display:flex; gap:8px; padding:0 12px 12px; }
  .panel .row button { flex:1; }

  textarea#textArea {
    width: 100%; height: 100%;
    font-size: 16px; padding: 14px; border: none; outline: none;
    background: var(--editor); color: var(--fg);
    font-family: ui-monospace, Menlo, Consolas, monospace;
  }

  /* Modal shared styles */
  .overlay {
    position: fixed; inset: 0; background: rgba(0,0,0,0.5);
    display: none; align-items: center; justify-content: center; z-index: 9999;
  }
  .dialog {
    width: 720px; max-width: 95%; padding: 16px;
    border-radius: 12px; background: var(--panel); color: var(--fg);
    border: 1px solid var(--border); font-family: Arial, sans-serif;
    box-shadow: 0 10px 30px rgba(0,0,0,0.35);
  }
  .dialog .title { font-size: 16px; font-weight: 700; margin-bottom: 6px; }
  .dialog .hint { font-size: 13px; color: var(--muted); margin-bottom: 10px; }
  .dialog .row { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:12px; }
  .dialog label { font-size: 14px; display:flex; align-items:center; gap:6px; }
  .dialog input[type="number"], .dialog select {
    padding: 8px; border-radius: 8px; border: 1px solid var(--border);
    background: var(--editor); color: var(--fg);
  }
  .dialog .btns { display:flex; gap:8px; justify-content:flex-end; margin-top: 8px; }
  .dialog button {
    padding:10px 12px; border-radius:8px; cursor:pointer;
    border:1px solid var(--border); background: var(--bg2); color: var(--fg);
  }
  .dialog button.primary { border:none; background: var(--accent); color:#fff; }
  .dialog button.primary:hover { background: var(--accent-hover); }

  .divider { height:1px; background: var(--border); margin: 12px 0; }

  .icon { display:inline-flex; align-items:center; gap:6px; }
  .icon svg { width:16px; height:16px; vertical-align:middle; }

  .about-list { line-height: 1.6; font-size: 14px; color: var(--fg); }
  .about-list kbd { font-size: 12px; }
</style>
</head>
<body data-theme="dark">
  <header>
    <h1>SQL Notepad</h1>
    <!-- keep the vertical space, but no inline help text -->
    <p>&nbsp;</p>
  </header>

  <div class="bar">
    <span class="pill" id="countPill">Copy Board: 0 items</span>
    <span class="pill" id="setCountPill">Set: 0 items</span>
    <button id="clearBtn"      class="secondary" title="Clear the Copy Board">Clear Copy Board</button>
    <button id="importBtn"     class="secondary" title="Import text from system clipboard">Import Clipboard</button>

    <button id="tokenizeBtn"   title="Replace last field in every tuple with a unique token">Tokenizer</button>
    <button id="nthFieldRemover" title="Remove the n’th field (1-based) from every tuple">Remove n’th Field</button>
    <button id="mathButton"    title="Open math tools for field operations">Math</button>

    <div class="right">
      <button id="toggleBoardBtn" class="secondary" title="Hide/Show Copy Board">Hide Copy Board</button>
      <button id="themeToggleBtn" class="secondary" title="Toggle theme">Light Theme</button>

      <!-- Help button (book icon) -->
      <button id="helpBtn" class="secondary" title="About / Help">
        <span class="icon">
          <!-- book icon -->
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
               stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
            <path d="M4 4h16v15H6.5A2.5 2.5 0 0 0 4 21.5z"></path>
          </svg>
          Help
        </span>
      </button>

      <button id="settingsBtn" class="secondary" title="Settings">
        <span class="icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
               stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06a2 2 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09c.17 0 .35-.03.51-.1.61-.25 1-.85 1-1.51V9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06.06c.51.51 1.23.66 1.82.33H9c.66 0 1.26-.39 1.51-1V3a2 2 0 0 1 4 0v.09c.25.61.85 1 1.51 1h.09c.59.33 1.31.18 1.82-.33l.06-.06a2 2 0 1 1 2.83 2.83l-.06.06c-.51.51-.66 1.23-.33 1.82V9c0 .66.39 1.26 1 1.51.16.07.34.1.51.1H21a2 2 0 0 1 0 4h-.09c-.17 0-.35.03-.51.1-.61.25-1 .85-1 1.51z"></path>
          </svg>
          Settings
        </span>
      </button>
    </div>
  </div>

  <div class="wrap" id="mainWrap">
    <aside class="panel" id="leftPanel">
      <h2>Copy Board</h2>
      <small>Paste here (CSV, lines, or whitespace). Edits update the queue.</small>
      <textarea id="board" placeholder='Examples:
alpha, "New York", bravo
or one
per
line'></textarea>
      <div class="row">
        <button id="dedupeBtn" class="secondary">Dedupe</button>
        <button id="shuffleBtn" class="secondary">Shuffle</button>
      </div>
    </aside>

    <textarea id="textArea" placeholder="Paste or type SQL here…"></textarea>
  </div>

  <!-- Remove n’th Field Modal -->
  <div class="overlay" id="nth-remover-modal">
    <div class="dialog">
      <div class="title">Remove n’th Field</div>
      <div class="hint">Enter a <b>1-based</b> field index (1 = first field). Removes that field from all tuples.</div>
      <div class="row">
        <label>Field #
          <input type="number" id="nthIndexInput" min="1" value="1" style="width:90px;">
        </label>
      </div>
      <div class="btns">
        <button id="nthCancelBtn">Cancel</button>
        <button id="nthApplyBtn" class="primary">Remove Field</button>
      </div>
    </div>
  </div>

  <!-- Math Modal -->
  <div class="overlay" id="math-modal">
    <div class="dialog">
      <div class="title">SQL Field Math</div>

      <div class="hint">Result: <b>Target = Number (op) Source</b> · Fields are <b>1-based</b> · Flip → <b>Source (op) Number</b></div>
      <div class="row" id="interfieldRow"></div>
      <div class="btns">
        <button id="applyInterfieldBtn" class="primary">Apply Interfield</button>
      </div>

      <div class="divider"></div>

      <div class="hint">Result: <b>Field = Field (op) Number</b> · Fields are <b>1-based</b> · Optional Flip → <b>Number (op) Field</b></div>
      <div class="row" id="fieldRow"></div>
      <div class="btns">
        <button id="applyFieldBtn" class="primary">Apply Field</button>
      </div>

      <div class="divider"></div>

      <div class="hint">Result: <b>Target = Field Ⓐ (op) Field Ⓑ</b> · Fields are <b>1-based</b></div>
      <div class="row" id="fieldFieldRow"></div>
      <div class="btns">
        <button id="applyFieldFieldBtn" class="primary">Apply Field Ⓐ (op) Field Ⓑ → Target</button>
        <button id="mathCloseBtn">Close</button>
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div class="overlay" id="settings-modal">
    <div class="dialog">
      <div class="title">Settings</div>
      <div class="hint">Personalize editor behaviors.</div>
      <div class="row">
        <label>
          <input type="checkbox" id="clearTokenOnDup">
          Clear last field on duplicate (<kbd>Ctrl</kbd>+<kbd>D</kbd>)
        </label>
      </div>
      <div class="btns">
        <button id="settingsCloseBtn" class="primary">Done</button>
      </div>
    </div>
  </div>

  <!-- About / Help Modal -->
  <div class="overlay" id="about-modal">
    <div class="dialog">
      <div class="title">About SQL Notepad</div>
      <div class="hint">Keyboard shortcuts & features</div>
      <div class="about-list">
        <ul>
          <li><kbd>Ctrl</kbd>+<kbd>B</kbd> – collect selection to Copy Board (removes it from editor)</li>
          <li><kbd>Ctrl</kbd>+<kbd>I</kbd> – dump Copy Board items into the n’th field across tuples</li>
          <li><kbd>Ctrl</kbd>+<kbd>D</kbd> – duplicate current line (down). If enabled in <em>Settings</em>, clears the <em>last field</em> on the duplicate</li>
          <li><kbd>Ctrl</kbd>+<kbd>R</kbd> – remove current line, crimping content upward</li>
          <li><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>V</kbd> – import clipboard into Copy Board</li>
          <li><b>Tokenizer</b> – fills only empty last fields (<code>''</code> or <code>' '</code>) with unique tokens</li>
          <li><b>Remove n’th Field</b> – removes a 1-based field index from every tuple</li>
          <li><b>Math</b> – Interfield (Number & Field), Field Math (Field & Number), and Field vs Field → Target</li>
          <li><b>Copy Board</b> – accepts CSV, lines, or whitespace; includes Dedupe and Shuffle utilities</li>
        </ul>
      </div>
      <div class="btns">
        <button id="aboutCloseBtn" class="primary">Close</button>
      </div>
    </div>
  </div>

<script>
/* ============================
   Persistent UI state (theme, panel, settings)
============================ */
const THEME_KEY = 'sqlFieldDump.theme';
const BOARD_VIS_KEY = 'sqlFieldDump.boardCollapsed';
const SETTINGS_KEY = 'sqlFieldDump.settings';

function loadSettings() {
  try {
    const raw = localStorage.getItem(SETTINGS_KEY);
    return raw ? JSON.parse(raw) : { clearTokenOnDuplicate: false }; // OFF by default ✅
  } catch { return { clearTokenOnDuplicate: false }; }              // OFF by default ✅
}
function saveSettings(s) {
  try { localStorage.setItem(SETTINGS_KEY, JSON.stringify(s)); } catch {}
}
let SETTINGS = loadSettings();

function applyTheme(theme) {
  document.body.setAttribute('data-theme', theme);
  const themeBtn = document.getElementById('themeToggleBtn');
  if (themeBtn) themeBtn.textContent = (theme === 'dark') ? 'Light Theme' : 'Dark Theme';
}
function toggleTheme() {
  const current = document.body.getAttribute('data-theme') || 'dark';
  const next = current === 'dark' ? 'light' : 'dark';
  applyTheme(next);
  localStorage.setItem(THEME_KEY, next);
}
(function initTheme() {
  const saved = localStorage.getItem(THEME_KEY);
  applyTheme(saved || 'dark');
})();

function applyBoardVisibility(collapsed) {
  const wrap = document.getElementById('mainWrap');
  const panel = document.getElementById('leftPanel');
  const btn = document.getElementById('toggleBoardBtn');
  if (collapsed) {
    wrap.classList.add('board-hidden');
    panel.classList.add('hidden');
    if (btn) btn.textContent = 'Show Copy Board';
  } else {
    wrap.classList.remove('board-hidden');
    panel.classList.remove('hidden');
    if (btn) btn.textContent = 'Hide Copy Board';
  }
}
function toggleBoard() {
  const collapsed = localStorage.getItem(BOARD_VIS_KEY) === 'true';
  const next = !collapsed;
  applyBoardVisibility(next);
  localStorage.setItem(BOARD_VIS_KEY, String(next));
}
(function initBoardVis() {
  const collapsed = localStorage.getItem(BOARD_VIS_KEY) === 'true';
  applyBoardVisibility(collapsed);
})();

document.getElementById('themeToggleBtn').addEventListener('click', toggleTheme);
document.getElementById('toggleBoardBtn').addEventListener('click', toggleBoard);

/* ============================
   Elements & Copy Board state
============================ */
const collectedItems = [];
const textArea   = document.getElementById('textArea');
const boardArea  = document.getElementById('board');
const countPill  = document.getElementById('countPill');
const parsePill  = document.getElementById('parsePill');

function updateBoardView() {
  if (boardArea) boardArea.value = collectedItems.join('\n');
  if (countPill) {
    countPill.textContent = `Copy Board: ${collectedItems.length} item${collectedItems.length===1?'':'s'}`;
  }
}
function setParseModeLabel(mode) {
  if (parsePill) parsePill.textContent = `Parsing: ${mode}`;
}

/* ============================
   CSV-aware tokenization
============================ */
function hasCsvCommaOutsideQuotes(s) {
  let inQ = false;
  for (let i = 0; i < s.length; i++) {
    const ch = s[i];
    if (ch === '"') {
      if (inQ && s[i+1] === '"') { i++; }
      else { inQ = !inQ; }
    } else if (!inQ && ch === ',') {
      return true;
    }
  }
  return false;
}
function csvSplit(s) {
  const out = [];
  let buf = '';
  let inQ = false;
  for (let i = 0; i < s.length; i++) {
    const ch = s[i];
    if (ch === '"') {
      if (inQ && s[i+1] === '"') { buf += '"'; i++; }
      else { inQ = !inQ; }
    } else if (ch === ',' && !inQ) {
      out.push(buf.trim());
      buf = '';
    } else {
      buf += ch;
    }
  }
  out.push(buf.trim());
  return out.map(v => {
    if (v.startsWith('"') && v.endsWith('"')) return v.slice(1, -1);
    return v;
  }).filter(Boolean);
}
function tokenizeAuto(input) {
  const text = input.replace(/\r/g, '');
  if (hasCsvCommaOutsideQuotes(text)) {
    setParseModeLabel('CSV');
    const lines = text.split('\n').filter(l => l.trim().length);
    const items = [];
    for (const line of lines) items.push(...csvSplit(line));
    return items.filter(Boolean);
  }
  if (text.includes('\n')) {
    setParseModeLabel('Lines');
    return text.split('\n').map(s => s.trim()).filter(Boolean);
  }
  setParseModeLabel('Whitespace');
  return text.split(/\s+/).map(s => s.trim()).filter(Boolean);
}
function pushItemsAuto(input) {
  const items = tokenizeAuto(input);
  if (items.length) {
    collectedItems.push(...items);
    updateBoardView();
  }
}
function syncFromBoard() {
  const items = tokenizeAuto(boardArea.value);
  collectedItems.length = 0;
  collectedItems.push(...items);
  updateBoardView();
}
boardArea.addEventListener('input', syncFromBoard);

/* ============================
   Buttons
============================ */
const clearBtn     = document.getElementById('clearBtn');
const importBtn    = document.getElementById('importBtn');
const dedupeBtn    = document.getElementById('dedupeBtn');
const shuffleBtn   = document.getElementById('shuffleBtn');
const tokenizeBtn  = document.getElementById('tokenizeBtn');

clearBtn.addEventListener('click', () => {
  collectedItems.length = 0;
  updateBoardView();
});
importBtn.addEventListener('click', async () => {
  try {
    const txt = await navigator.clipboard.readText();
    pushItemsAuto(txt);
  } catch {
    alert('Clipboard read failed. Your browser may not allow it on this page.');
  }
});
dedupeBtn.addEventListener('click', () => {
  const seen = new Set(), next = [];
  for (const it of collectedItems) if (!seen.has(it)) { seen.add(it); next.push(it); }
  collectedItems.length = 0; collectedItems.push(...next); updateBoardView();
});
shuffleBtn.addEventListener('click', () => {
  for (let i = collectedItems.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [collectedItems[i], collectedItems[j]] = [collectedItems[j], collectedItems[i]];
  }
  updateBoardView();
});

/* ============================
   Caret/line utilities
============================ */
function getLineIndexAndColumn(text, caretPos) {
  const lines = text.split(/\r?\n/);
  let acc = 0;
  for (let i = 0; i < lines.length; i++) {
    const len = lines[i].length;
    if (caretPos <= acc + len) {
      return { lines, lineIndex: i, column: caretPos - acc };
    }
    acc += len + 1; // +1 for '\n'
  }
  return { lines, lineIndex: lines.length - 1, column: lines[lines.length - 1].length };
}

/* ============================
   Robust tuple parsing
============================ */
function findAllTuplesInLineSmart(line) {
  const tuples = [];
  let inQuote = false;

  for (let i = 0; i < line.length; i++) {
    const ch = line[i];

    if (ch === "'") {
      if (inQuote) {
        if (line[i - 1] === '\\') {
          // escaped
        } else if (line[i + 1] === "'") {
          i++;
        } else {
          inQuote = false;
        }
      } else {
        inQuote = true;
      }
    } else if (ch === '\\' && inQuote) {
      i++;
    } else if (!inQuote && ch === '(') {
      const start = i;
      let j = i + 1;
      let depth = 1;
      let q = false;
      for (; j < line.length; j++) {
        const c2 = line[j];
        if (c2 === "'") {
          if (q) {
            if (line[j - 1] === '\\') {
              // escaped
            } else if (line[j + 1] === "'") {
              j++;
            } else {
              q = false;
            }
          } else {
            q = true;
          }
        } else if (c2 === '\\' && q) {
          j++;
        } else if (!q) {
          if (c2 === '(') depth++;
          else if (c2 === ')') {
            depth--;
            if (depth === 0) {
              tuples.push({ open: start, close: j + 1, raw: line.slice(start, j + 1) });
              i = j;
              break;
            }
          }
        }
      }
    }
  }
  return tuples;
}

function splitFieldsRobust(tupleRaw) {
  const inner = tupleRaw.slice(1, -1);
  const parts = [];
  let buf = '';
  let inQuote = false;

  for (let i = 0; i < inner.length; i++) {
    const ch = inner[i];

    if (ch === "'") {
      if (inQuote) {
        if (inner[i - 1] === '\\') {
          buf += ch;
        } else if (inner[i + 1] === "'") {
          buf += "''"; i++;
        } else {
          inQuote = false; buf += ch;
        }
      } else {
        inQuote = true; buf += ch;
      }
    } else if (ch === '\\' && inQuote) {
      buf += ch;
      if (i + 1 < inner.length) { buf += inner[i + 1]; i++; }
    } else if (!inQuote && ch === ',') {
      parts.push(buf.trim()); buf = '';
    } else {
      buf += ch;
    }
  }
  parts.push(buf.trim());
  return parts;
}
function joinFields(parts) { return '(' + parts.join(', ') + ')'; }
function isQuoted(str) { const t = str.trim(); return t.startsWith("'") && t.endsWith("'"); }

/* ============================
   Insert collected items (Ctrl+I)
============================ */
function countCommasBeforeIndexRobust(line, tupleOpen, indexInLine) {
  const start = tupleOpen + 1;
  const end   = Math.max(start, Math.min(indexInLine, line.length));
  let inQuote = false, commas = 0;

  for (let i = start; i < end; i++) {
    const ch = line[i];
    if (ch === "'") {
      if (inQuote) {
        if (line[i - 1] === '\\') {
          // escaped
        } else if (line[i + 1] === "'") {
          i++;
        } else {
          inQuote = false;
        }
      } else {
        inQuote = true;
      }
    } else if (ch === '\\' && inQuote) {
      i++;
    } else if (!inQuote && ch === ',') {
      commas++;
    }
  }
  return commas;
}

document.addEventListener('keydown', function (event) {
  // Collect: Ctrl+B  (free up Ctrl+A for Select All)
  if (event.ctrlKey && event.key.toLowerCase() === 'b' && document.activeElement === textArea) {
    event.preventDefault();

    const start = textArea.selectionStart;
    const end   = textArea.selectionEnd;
    if (start === end) return;

    const selectedText = textArea.value.substring(start, end);
    pushItemsAuto(selectedText);

    const before = textArea.value.substring(0, start);
    const after  = textArea.value.substring(end);
    textArea.value = before + after;
    textArea.setSelectionRange(start, start);
    return;
  }

  // Import: Ctrl+Shift+V
  if (event.ctrlKey && event.shiftKey && event.key.toLowerCase() === 'v' &&
      (document.activeElement === textArea || document.activeElement === boardArea)) {
    event.preventDefault();
    navigator.clipboard.readText().then(pushItemsAuto).catch(() => alert('Clipboard read failed.'));
    return;
  }

  // Dump: Ctrl+I
  if (event.ctrlKey && event.key.toLowerCase() === 'i' && document.activeElement === textArea) {
    event.preventDefault();
    if (collectedItems.length === 0) return;

    const caretPos = textArea.selectionStart;
    const info     = getLineIndexAndColumn(textArea.value, caretPos);
    const lines    = info.lines;
    const startLine= info.lineIndex;
    const column   = info.column;

    const tupOnCaret = findAllTuplesInLineSmart(lines[startLine])[0] || null;
    if (!tupOnCaret) return;

    let fieldIndex = 0;
    if (column <= tupOnCaret.open) fieldIndex = 0;
    else if (column >= tupOnCaret.close) {
      const parts = splitFieldsRobust(tupOnCaret.raw);
      fieldIndex = Math.max(0, parts.length - 1);
    } else {
      fieldIndex = countCommasBeforeIndexRobust(lines[startLine], tupOnCaret.open, column);
    }

    let used = 0;
    for (let li = startLine; li < lines.length && used < collectedItems.length; li++) {
      const line = lines[li];
      if (line.trim() === '') break;

      const tuples = findAllTuplesInLineSmart(line);
      if (!tuples.length) continue;

      const t = tuples[0];
      const before = line.slice(0, t.open);
      const after  = line.slice(t.close);

      const parts = splitFieldsRobust(t.raw);
      if (fieldIndex < 0 || fieldIndex >= parts.length) continue;

      const target = parts[fieldIndex];
      const value  = collectedItems[used++];

      parts[fieldIndex] = isQuoted(target) ? `'${String(value).replace(/'/g, "''")}'`
                                           : String(value);

      lines[li] = before + joinFields(parts) + after;
    }

    textArea.value = lines.join('\n');
    textArea.setSelectionRange(caretPos, caretPos);
    updateBoardView();
    return;
  }

  // Duplicate line down: Ctrl+D  (insert AFTER the current line)
  if (event.ctrlKey && event.key.toLowerCase() === 'd' && document.activeElement === textArea) {
    event.preventDefault();
    const pos = textArea.selectionStart;
    const { lines, lineIndex, column } = getLineIndexAndColumn(textArea.value, pos);
    const srcLine = lines[lineIndex];

    // Prepare the duplicate (optionally clear LAST FIELD in every tuple on the NEW duplicate)
    let dup = srcLine;
    if (SETTINGS.clearTokenOnDuplicate) {
      dup = clearLastFieldInAllTuples(dup);
    }

    // Insert the new duplicate AFTER the original line
    lines.splice(lineIndex + 1, 0, dup);
    textArea.value = lines.join('\n');

    // Move caret to the duplicate at the same column
    let startOfNew = 0;
    for (let i = 0; i <= lineIndex; i++) startOfNew += lines[i].length + 1; // after original\n
    const newCaret = startOfNew + Math.min(column, lines[lineIndex + 1].length);
    textArea.setSelectionRange(newCaret, newCaret);
    return;
  }

  // Remove current line: Ctrl+R (crimp upward)
  if (event.ctrlKey && event.key.toLowerCase() === 'r' && document.activeElement === textArea) {
    event.preventDefault();
    const pos = textArea.selectionStart;
    const { lines, lineIndex } = getLineIndexAndColumn(textArea.value, pos);
    if (!lines.length) return;

    // Remove the current line and crimp content upward
    lines.splice(lineIndex, 1);

    // Caret at start of the line now occupying this index
    const newIndex = Math.min(lineIndex, Math.max(0, lines.length - 1));
    let acc = 0;
    for (let i = 0; i < newIndex; i++) acc += lines[i].length + 1;

    textArea.value = lines.join('\n');
    textArea.setSelectionRange(acc, acc);
    return;
  }
});

/* ============================
   Tokenizer (only fill empty last field)
============================ */
function generateToken(length) {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
  let token = '';
  for (let i = 0; i < length; i++) token += chars.charAt(Math.floor(Math.random() * chars.length));
  return token;
}
function getUniqueToken(existingContent, length) {
  let token;
  do { token = generateToken(length); } while (existingContent.includes(token));
  return token;
}
function isEmptyQuotedField(str) {
  const t = String(str).trim();
  if (!(t.startsWith("'") && t.endsWith("'"))) return false;
  const inner = t.slice(1, -1).replace(/''/g, "'");
  return inner.trim().length === 0;
}
function replaceLastFieldWithQuotedTokenIfEmpty(tupleRaw, token) {
  const parts = splitFieldsRobust(tupleRaw);
  if (!parts.length) return tupleRaw;
  const last = parts[parts.length - 1];
  if (!isEmptyQuotedField(last)) return tupleRaw;
  parts[parts.length - 1] = `'${String(token).replace(/'/g, "''")}'`;
  return joinFields(parts);
}
document.getElementById('tokenizeBtn').addEventListener('click', () => {
  if (!textArea) return;
  let content = textArea.value;
  const lines = content.split(/\r?\n/);

  for (let li = 0; li < lines.length; li++) {
    const line = lines[li];
    if (!line.trim()) continue;

    const tuples = findAllTuplesInLineSmart(line);
    if (!tuples.length) continue;

    let newLine = line;
    for (let k = tuples.length - 1; k >= 0; k--) {
      const t = tuples[k];
      const candidateToken = getUniqueToken(content, 12);

      const before = newLine.slice(0, t.open);
      const after  = newLine.slice(t.close);
      const replacedTuple = replaceLastFieldWithQuotedTokenIfEmpty(t.raw, candidateToken);

      if (replacedTuple !== t.raw) {
        newLine = before + replacedTuple + after;

        const docPrefixLen = lines.slice(0, li).join('\n').length + (li > 0 ? 1 : 0);
        const beforeDoc = content.slice(0, docPrefixLen);
        const afterDoc  = content.slice(docPrefixLen + line.length);
        content = beforeDoc + newLine + afterDoc;
      }
    }
    lines[li] = newLine;
  }
  textArea.value = lines.join('\n');
});

/* ============================
   Remove n’th Field (1-based UI)
============================ */
const nthModal      = document.getElementById('nth-remover-modal');
const nthInput      = document.getElementById('nthIndexInput');
const nthApplyBtn   = document.getElementById('nthApplyBtn');
const nthCancelBtn  = document.getElementById('nthCancelBtn');
document.getElementById('nthFieldRemover').addEventListener('click', () => {
  nthModal.style.display = 'flex';
  setTimeout(() => nthInput.focus(), 0);
});
nthCancelBtn.addEventListener('click', () => nthModal.style.display = 'none');
nthModal.addEventListener('click', (e) => { if (e.target === nthModal) nthCancelBtn.click(); });

function removeFieldInTuple(tupleRaw, fieldIndex0) {
  const parts = splitFieldsRobust(tupleRaw);
  if (fieldIndex0 < 0 || fieldIndex0 >= parts.length) return tupleRaw;
  parts.splice(fieldIndex0, 1);
  return joinFields(parts);
}
function removeFieldFromAllTuplesInLine(line, fieldIndex0) {
  const tuples = findAllTuplesInLineSmart(line);
  if (!tuples.length) return line;
  let out = line;
  for (let i = tuples.length - 1; i >= 0; i--) {
    const t = tuples[i];
    const before = out.slice(0, t.open);
    const after  = out.slice(t.close);
    const replaced = removeFieldInTuple(t.raw, fieldIndex0);
    out = before + replaced + after;
  }
  return out;
}
function removeFieldAcrossDocument(fieldIndex0) {
  const lines = textArea.value.split(/\r?\n/);
  for (let i = 0; i < lines.length; i++) {
    lines[i] = removeFieldFromAllTuplesInLine(lines[i], fieldIndex0);
  }
  textArea.value = lines.join('\n');
}
nthApplyBtn.addEventListener('click', () => {
  const idx1 = Number(nthInput.value);
  if (!Number.isInteger(idx1) || idx1 < 1) { alert('Enter an integer ≥ 1.'); return; }
  removeFieldAcrossDocument(idx1 - 1);
  nthModal.style.display = 'none';
});
nthInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') nthApplyBtn.click();
  else if (e.key === 'Escape') nthCancelBtn.click();
});

/* ============================
   Math Popup (Interfield + Field + Field-vs-Field)
============================ */
const mathModal = document.getElementById('math-modal');
const interfieldRow = document.getElementById('interfieldRow');
const fieldRow = document.getElementById('fieldRow');
const fieldFieldRow = document.getElementById('fieldFieldRow');
const applyInterfieldBtn = document.getElementById('applyInterfieldBtn');
const applyFieldBtn = document.getElementById('applyFieldBtn');
const applyFieldFieldBtn = document.getElementById('applyFieldFieldBtn');
const mathCloseBtn = document.getElementById('mathCloseBtn');

function mk(labelText, el) {
  const lab = document.createElement('label');
  lab.textContent = labelText + ' ';
  lab.appendChild(el);
  return lab;
}
function makeNumberInput(val, min, width) {
  const el = document.createElement('input');
  el.type = 'number'; if (min != null) el.min = String(min);
  if (val != null) el.value = String(val);
  if (width) el.style.width = width;
  return el;
}
function makeSelect(options) {
  const el = document.createElement('select');
  options.forEach(v => { const o = document.createElement('option'); o.value = v; o.textContent = v; el.appendChild(o); });
  return el;
}
function makeRoundingSelect() { return makeSelect(['none','up','down']); }

// Interfield controls (Target = Number (op) Source [or flipped])
const if_target = makeNumberInput(1, 1, '80px');
const if_op     = makeSelect(['+','-','*','/']);
const if_source = makeNumberInput(2, 1, '80px');
const if_num    = (() => { const n = makeNumberInput(1, null, '120px'); n.step = 'any'; return n; })();
const if_round  = makeRoundingSelect();
const if_flip   = document.createElement('input'); if_flip.type='checkbox';

interfieldRow.appendChild(mk('Target Field', if_target));
interfieldRow.appendChild(mk('Operation', if_op));
interfieldRow.appendChild(mk('Source Field', if_source));
interfieldRow.appendChild(mk('Number', if_num));
interfieldRow.appendChild(mk('Rounding', if_round));
const if_flipWrap = document.createElement('label'); if_flipWrap.appendChild(if_flip); if_flipWrap.appendChild(document.createTextNode(' Flip Order'));
interfieldRow.appendChild(if_flipWrap);

// Field Math controls (Field = Field (op) Number [or flipped])
const fm_field = makeNumberInput(1, 1, '80px');
const fm_op    = makeSelect(['+','-','*','/']);
const fm_num   = (() => { const n = makeNumberInput(1, null, '120px'); n.step = 'any'; return n; })();
const fm_round = makeRoundingSelect();
const fm_flip  = document.createElement('input'); fm_flip.type='checkbox';

fieldRow.appendChild(mk('Field', fm_field));
fieldRow.appendChild(mk('Operation', fm_op));
fieldRow.appendChild(mk('Number', fm_num));
fieldRow.appendChild(mk('Rounding', fm_round));
const fm_flipWrap = document.createElement('label'); fm_flipWrap.appendChild(fm_flip); fm_flipWrap.appendChild(document.createTextNode(' Flip Order'));
fieldRow.appendChild(fm_flipWrap);

// Field Ⓐ (op) Field Ⓑ into Target controls
const ff_target = makeNumberInput(1, 1, '80px');
const ff_op     = makeSelect(['+','-','*','/']);
const ff_a      = makeNumberInput(1, 1, '80px');
const ff_b      = makeNumberInput(2, 1, '80px');
const ff_round  = makeRoundingSelect();

fieldFieldRow.appendChild(mk('Target Field', ff_target));
fieldFieldRow.appendChild(mk('Operation', ff_op));
fieldFieldRow.appendChild(mk('Field Ⓐ', ff_a));
fieldFieldRow.appendChild(mk('Field Ⓑ', ff_b));
fieldFieldRow.appendChild(mk('Rounding', ff_round));

// Open/close modal
document.getElementById('mathButton').addEventListener('click', () => {
  mathModal.style.display = 'flex';
  setTimeout(() => if_target.focus(), 0);
});
mathCloseBtn.addEventListener('click', () => mathModal.style.display = 'none');
mathModal.addEventListener('click', (e) => { if (e.target === mathModal) mathCloseBtn.click(); });

// Apply logic
function applyMathAcrossDocument(opts) {
  const { targetIdx0, sourceIdx0, op, constant, rounding, flipOrder } = opts;
  const lines = textArea.value.split(/\r?\n/);

  for (let li = 0; li < lines.length; li++) {
    let line = lines[li];
    if (!line.trim()) continue;

    const tuples = findAllTuplesInLineSmart(line);
    if (!tuples.length) continue;

    let newLine = line;
    for (let k = tuples.length - 1; k >= 0; k--) {
      const t = tuples[k];
      const parts = splitFieldsRobust(t.raw);
      if (targetIdx0 < 0 || targetIdx0 >= parts.length) continue;
      if (sourceIdx0 < 0 || sourceIdx0 >= parts.length) continue;

      const sourceRaw = parts[sourceIdx0].trim();
      const targetRaw = parts[targetIdx0].trim();

      if (isQuoted(sourceRaw)) continue;
      const sourceNum = parseFloat(sourceRaw);
      if (!isFinite(sourceNum)) continue;

      let result;
      if (!flipOrder) {
        switch (op) {
          case '+': result = constant + sourceNum; break;
          case '-': result = constant - sourceNum; break;
          case '*': result = constant * sourceNum; break;
          case '/': if (sourceNum === 0) continue; result = constant / sourceNum; break;
        }
      } else {
        switch (op) {
          case '+': result = sourceNum + constant; break;
          case '-': result = sourceNum - constant; break;
          case '*': result = sourceNum * constant; break;
          case '/': if (constant === 0) continue; result = sourceNum / constant; break;
        }
      }

      if (rounding === 'up')   result = Math.ceil(result);
      if (rounding === 'down') result = Math.floor(result);

      parts[targetIdx0] = isQuoted(targetRaw) ? `'${result}'` : String(result);

      const before = newLine.slice(0, t.open);
      const after  = newLine.slice(t.close);
      newLine = before + joinFields(parts) + after;
    }
    lines[li] = newLine;
  }
  textArea.value = lines.join('\n');
}

function applyFieldMathAcrossDocument(opts) {
  const { fieldIdx0, op, constant, rounding, flipOrder } = opts;
  const lines = textArea.value.split(/\r?\n/);

  for (let li = 0; li < lines.length; li++) {
    let line = lines[li];
    if (!line.trim()) continue;

    const tuples = findAllTuplesInLineSmart(line);
    if (!tuples.length) continue;

    let newLine = line;
    for (let k = tuples.length - 1; k >= 0; k--) {
      const t = tuples[k];
      const parts = splitFieldsRobust(t.raw);
      if (fieldIdx0 < 0 || fieldIdx0 >= parts.length) continue;

      const raw = parts[fieldIdx0].trim();
      if (isQuoted(raw)) continue;
      const fieldNum = parseFloat(raw);
      if (!isFinite(fieldNum)) continue;

      let result;
      if (!flipOrder) {
        switch (op) {
          case '+': result = fieldNum + constant; break;
          case '-': result = fieldNum - constant; break;
          case '*': result = fieldNum * constant; break;
          case '/': if (constant === 0) continue; result = fieldNum / constant; break;
        }
      } else {
        switch (op) {
          case '+': result = constant + fieldNum; break;
          case '-': result = constant - fieldNum; break;
          case '*': result = constant * fieldNum; break;
          case '/': if (fieldNum === 0) continue; result = constant / fieldNum; break;
        }
      }

      if (rounding === 'up')   result = Math.ceil(result);
      if (rounding === 'down') result = Math.floor(result);

      parts[fieldIdx0] = isQuoted(raw) ? `'${result}'` : String(result);

      const before = newLine.slice(0, t.open);
      const after  = newLine.slice(t.close);
      newLine = before + joinFields(parts) + after;
    }
    lines[li] = newLine;
  }
  textArea.value = lines.join('\n');
}

function applyFieldOpFieldToTargetAcrossDocument(opts) {
  const { targetIdx0, aIdx0, bIdx0, op, rounding } = opts;
  const lines = textArea.value.split(/\r?\n/);

  for (let li = 0; li < lines.length; li++) {
    let line = lines[li];
    if (!line.trim()) continue;

    const tuples = findAllTuplesInLineSmart(line);
    if (!tuples.length) continue;

    let newLine = line;
    for (let k = tuples.length - 1; k >= 0; k--) {
      const t = tuples[k];
      const parts = splitFieldsRobust(t.raw);
      if (targetIdx0 < 0 || targetIdx0 >= parts.length) continue;
      if (aIdx0 < 0 || aIdx0 >= parts.length) continue;
      if (bIdx0 < 0 || bIdx0 >= parts.length) continue;

      const aRaw = parts[aIdx0].trim();
      const bRaw = parts[bIdx0].trim();
      const targetRaw = parts[targetIdx0].trim();

      if (isQuoted(aRaw) || isQuoted(bRaw)) continue;
      const aNum = parseFloat(aRaw);
      const bNum = parseFloat(bRaw);
      if (!isFinite(aNum) || !isFinite(bNum)) continue;

      let result;
      switch (op) {
        case '+': result = aNum + bNum; break;
        case '-': result = aNum - bNum; break;
        case '*': result = aNum * bNum; break;
        case '/': if (bNum === 0) continue; result = aNum / bNum; break;
        default: continue;
      }

      if (rounding === 'up')   result = Math.ceil(result);
      if (rounding === 'down') result = Math.floor(result);

      parts[targetIdx0] = isQuoted(targetRaw) ? `'${result}'` : String(result);

      const before = newLine.slice(0, t.open);
      const after  = newLine.slice(t.close);
      newLine = before + joinFields(parts) + after;
    }
    lines[li] = newLine;
  }
  textArea.value = lines.join('\n');
}

applyInterfieldBtn.addEventListener('click', () => {
  const tgt1 = Number(if_target.value);
  const src1 = Number(if_source.value);
  const op   = String(if_op.value);
  const val  = Number(if_num.value);
  const rnd  = String(if_round.value);
  const flip = !!if_flip.checked;

  if (!Number.isInteger(tgt1) || tgt1 < 1) { alert('Target field must be an integer ≥ 1.'); return; }
  if (!Number.isInteger(src1) || src1 < 1) { alert('Source field must be an integer ≥ 1.'); return; }
  if (!isFinite(val)) { alert('Please enter a valid Number.'); return; }
  if (!['+','-','*','/'].includes(op)) { alert('Choose a valid operation.'); return; }
  if (!['none','up','down'].includes(rnd)) { alert('Choose a valid rounding mode.'); return; }

  applyMathAcrossDocument({
    targetIdx0: tgt1 - 1,
    sourceIdx0: src1 - 1,
    op, constant: val,
    rounding: rnd,
    flipOrder: flip
  });
});

applyFieldBtn.addEventListener('click', () => {
  const fld1 = Number(fm_field.value);
  const op   = String(fm_op.value);
  const val  = Number(fm_num.value);
  const rnd  = String(fm_round.value);
  const flip = !!fm_flip.checked;

  if (!Number.isInteger(fld1) || fld1 < 1) { alert('Field must be an integer ≥ 1.'); return; }
  if (!isFinite(val)) { alert('Please enter a valid Number.'); return; }
  if (!['+','-','*','/'].includes(op)) { alert('Choose a valid operation.'); return; }
  if (!['none','up','down'].includes(rnd)) { alert('Choose a valid rounding mode.'); return; }

  applyFieldMathAcrossDocument({
    fieldIdx0: fld1 - 1,
    op, constant: val,
    rounding: rnd,
    flipOrder: flip
  });
});

applyFieldFieldBtn.addEventListener('click', () => {
  const tgt1 = Number(ff_target.value);
  const a1   = Number(ff_a.value);
  const b1   = Number(ff_b.value);
  const op   = String(ff_op.value);
  const rnd  = String(ff_round.value);

  if (!Number.isInteger(tgt1) || tgt1 < 1) { alert('Target field must be an integer ≥ 1.'); return; }
  if (!Number.isInteger(a1) || a1 < 1) { alert('Field Ⓐ must be an integer ≥ 1.'); return; }
  if (!Number.isInteger(b1) || b1 < 1) { alert('Field Ⓑ must be an integer ≥ 1.'); return; }
  if (!['+','-','*','/'].includes(op)) { alert('Choose a valid operation.'); return; }
  if (!['none','up','down'].includes(rnd)) { alert('Choose a valid rounding mode.'); return; }

  applyFieldOpFieldToTargetAcrossDocument({
    targetIdx0: tgt1 - 1,
    aIdx0: a1 - 1,
    bIdx0: b1 - 1,
    op,
    rounding: rnd
  });
});

/* ============================
   Settings modal wiring
============================ */
const settingsModal = document.getElementById('settings-modal');
const settingsBtn   = document.getElementById('settingsBtn');
const settingsClose = document.getElementById('settingsCloseBtn');
const clearOnDupChk = document.getElementById('clearTokenOnDup');

function openSettings() {
  clearOnDupChk.checked = !!SETTINGS.clearTokenOnDuplicate;
  settingsModal.style.display = 'flex';
}
function closeSettings() {
  SETTINGS.clearTokenOnDuplicate = !!clearOnDupChk.checked;
  saveSettings(SETTINGS);
  settingsModal.style.display = 'none';
}
settingsBtn.addEventListener('click', openSettings);
settingsClose.addEventListener('click', closeSettings);
settingsModal.addEventListener('click', (e) => { if (e.target === settingsModal) closeSettings(); });
// Save immediately on change
clearOnDupChk.addEventListener('change', () => {
  SETTINGS.clearTokenOnDuplicate = !!clearOnDupChk.checked;
  saveSettings(SETTINGS);
});

/* ============================
   Helpers to clear LAST field in tuples (used by Ctrl+D)
============================ */
function clearLastFieldInTuple(tupleRaw) {
  const parts = splitFieldsRobust(tupleRaw);
  if (!parts.length) return tupleRaw;
  parts[parts.length - 1] = "''"; // always set to empty string
  return joinFields(parts);
}
function clearLastFieldInAllTuples(line) {
  const tuples = findAllTuplesInLineSmart(line);
  if (!tuples.length) return line;
  let out = line;
  for (let i = tuples.length - 1; i >= 0; i--) {
    const t = tuples[i];
    const before = out.slice(0, t.open);
    const after  = out.slice(t.close);
    const replaced = clearLastFieldInTuple(t.raw);
    out = before + replaced + after;
  }
  return out;
}

/* ============================
   About / Help modal
============================ */
const aboutModal = document.getElementById('about-modal');
const helpBtn    = document.getElementById('helpBtn');
const aboutClose = document.getElementById('aboutCloseBtn');

helpBtn.addEventListener('click', () => { aboutModal.style.display = 'flex'; });
aboutClose.addEventListener('click', () => { aboutModal.style.display = 'none'; });
aboutModal.addEventListener('click', (e) => { if (e.target === aboutModal) aboutClose.click(); });

/* ============================
   Init
============================ */
updateBoardView();
setParseModeLabel('Auto');
</script>
</body>
</html>
