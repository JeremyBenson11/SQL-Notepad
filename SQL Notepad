<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>SQL Notepad</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
:root {
  --bg:#0f172a;
  --bg2:#0b1327;
  --panel:#0d1326;
  --editor:#0b1020;
  --fg:#e5e7eb;
  --muted:#94a3b8;
  --border:#1f2a44;
  --accent:#d9534f;
  --accent-hover:#c9302c;
  --pill:#111827;
}
[data-theme="light"] {
  --bg:#f8fafc;
  --bg2:#eef2f7;
  --panel:#ffffff;
  --editor:#ffffff;
  --fg:#0f172a;
  --muted:#475569;
  --border:#d1d5db;
  --accent:#0ea5e9;
  --accent-hover:#0284c7;
  --pill:#e5e7eb;
}

* { box-sizing: border-box; }
html, body { height: 100%; }
body {
  font-family: Arial, sans-serif;
  display: grid;
  /* 4 rows: header, menubar, toolbar (.bar), content (.wrap) */
  grid-template-rows: auto auto auto 1fr;
  background: var(--bg);
  color: var(--fg);
  min-height: 100vh;
}

/* When interface is hidden, drop the bar row (header + menubar + content) */
body.interface-hidden { grid-template-rows: auto auto 1fr; }

header {
  padding: 16px 20px;
  background: var(--bg);
  border-bottom: 1px solid var(--border);
}
body.interface-hidden header { padding: 6px 12px; }
header h1 { margin: 0 0 6px; font-size: 20px; }
header p { margin: 0; font-size: 14px; color: var(--muted); min-height: 1.4em; }
kbd {
  background: var(--pill);
  border: 1px solid var(--border);
  border-bottom-width: 2px;
  border-radius: 6px;
  padding: 2px 6px;
  font-family: inherit;
  font-size: 12px;
  color: var(--fg);
}

/* ===== Toolbar (.bar) ===== */
.bar {
  grid-row: 3;                 /* sits on the 3rd (auto) row */
  display:flex; gap:8px; align-items:center;
  padding:8px 20px;
  background: var(--bg2); color: var(--fg);
  border-bottom:1px solid var(--border);
  height:auto;                 /* ensure intrinsic height */
  line-height:1.2;
  flex-wrap: wrap;
}
body.interface-hidden .bar { display:none; }

.bar .right {
  margin-left:auto; display:flex; gap:8px; align-items:center; flex-wrap:nowrap;
  white-space:nowrap;
}
.pill {
  background: var(--pill);
  padding: 4px 8px;
  border-radius: 999px;
  font-size: 12px;
  border: 1px solid var(--border);
}
.bar button {
  padding:8px 10px; font-size:14px; cursor:pointer; border:none; color:white;
  background: var(--accent); border-radius:8px;
}
.bar button.secondary {
  background: transparent; color: var(--fg);
  border: 1px solid var(--border);
}
.bar button:hover { background: var(--accent-hover); }
.bar button.secondary:hover { background: var(--panel); }

/* ===== Main wrap/content ===== */
.wrap {
  grid-row: 4;                 /* the filling row */
  display:grid; grid-template-columns: 300px 1fr; gap:0; height: 100%;
  min-height: 0; /* allow child to stretch correctly */
}
.wrap.board-hidden { grid-template-columns: 1fr; }

/* FIX: place .wrap on row 3 when interface is hidden so it fills the 3rd track */
body.interface-hidden .wrap { 
  grid-row: 3; 
  grid-template-columns: 1fr !important; 
}

aside.panel {
  background: var(--panel); border-right:1px solid var(--border);
  display:flex; flex-direction:column;
}
aside.panel.hidden { display:none; }
body.interface-hidden aside.panel { display:none !important; }
/* (grid columns are already collapsed above for hidden mode) */

aside.panel h2 { margin: 12px 12px 4px; font-size:14px; color: var(--fg); font-weight:600; }
aside.panel small { margin: 0 12px 8px; color: var(--muted); }
#board {
  margin: 0 12px 12px; flex:1; resize:none; width: calc(100% - 24px);
  background: var(--editor); color: var(--fg); border:1px solid var(--border);
  border-radius:8px; padding:10px;
  font-family: ui-monospace, Menlo, Consolas, monospace; font-size:13px; line-height:1.4;
}
.panel .row { display:flex; gap:8px; padding:0 12px 12px; }
.panel .row button { flex:1; }

textarea#textArea {
  width: 100%; height: 100%;
  font-size: 16px; padding: 14px; border: none; outline: none;
  background: var(--editor); color: var(--fg);
  font-family: ui-monospace, Menlo, Consolas, monospace;
}
body.interface-hidden textarea#textArea { margin-left: 12px; }

/* ===== Modal shared styles ===== */
.overlay {
  position: fixed; inset: 0; background: rgba(0,0,0,0.5);
  display: none; align-items: center; justify-content: center; z-index: 9999;
}
.dialog {
  width: 720px; max-width: 95%; padding: 16px;
  border-radius: 12px; background: var(--panel); color: var(--fg);
  border: 1px solid var(--border); font-family: Arial, sans-serif;
  box-shadow: 0 10px 30px rgba(0,0,0,0.35);
}
.dialog .title { font-size: 16px; font-weight: 700; margin-bottom: 6px; }
.dialog .hint { font-size: 13px; color: var(--muted); margin-bottom: 10px; }
.dialog .row { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:12px; }
.dialog label { font-size: 14px; display:flex; align-items:center; gap:6px; }
.dialog input[type="number"], .dialog select {
  padding: 8px; border-radius: 8px; border: 1px solid var(--border);
  background: var(--editor); color: var(--fg);
}
.dialog .btns { display:flex; gap:8px; justify-content:flex-end; margin-top: 8px; }
.dialog button {
  padding:10px 12px; border-radius:8px; cursor:pointer;
  border:1px solid var(--border); background: var(--bg2); color: var(--fg);
}
.dialog button.primary { border:none; background: var(--accent); color:#fff; }
.dialog button.primary:hover { background: var(--accent-hover); }

.divider { height:1px; background: var(--border); margin: 12px 0; }

.icon { display:inline-flex; align-items:center; gap:6px; }
.icon svg { width:16px; height:16px; vertical-align:middle; }

.about-list { line-height: 1.6; font-size: 14px; color: var(--fg); }
.about-list kbd { font-size: 12px; }

/* ===== Duplicate end token highlighter overlay ===== */
#highlightOverlay {
  position: fixed;
  inset: auto auto auto auto; /* set dynamically via JS to match the textarea */
  pointer-events: none;
  white-space: pre-wrap;
  word-break: break-word;
  overflow: hidden;
  z-index: 999; /* under modals, over editor */
  color: transparent; /* base text hidden */
}

/* Safety button to restore UI when hidden */
#showControlsBtn {
  position: fixed;
  top: 12px;
  right: 8px;
  z-index: 10000;
  display: none;
  background: var(--accent);
  color: #fff;
  border: none;
  border-radius: 8px;
  padding: 8px 10px;
  cursor: pointer;
  box-shadow: 0 4px 12px rgba(0,0,0,.25);
}

/* === Duplicate End Tokens Modal === */
#dupesListWrap { border:1px solid var(--border); border-radius:10px; background:var(--editor); }
#dupesHeader { display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:8px; }
#dupesCount { font-size:13px; color:var(--muted); }
#dupesSearch {
  width:240px; padding:8px 10px; border-radius:8px; border:1px solid var(--border);
  background:var(--bg2); color:var(--fg);
}
#dupesList {
  max-height: 360px; overflow:auto; padding:6px;
  border-top:1px dashed var(--border);
}
.dupeItem {
  display:flex; align-items:center; justify-content:space-between; gap:10px;
  padding:8px 10px; border-bottom:1px dashed var(--border);
}
.dupeItem:last-child { border-bottom:none; }
.dupeToken { font-family: ui-monospace, Menlo, Consolas, monospace; word-break:break-all; }
.dupeBadge {
  background: var(--pill); border:1px solid var(--border);
  border-radius:999px; padding:2px 8px; font-size:12px;
}
.dupeActions { display:flex; gap:6px; }
.dupeBtn {
  padding:6px 8px; border-radius:8px; cursor:pointer;
  border:1px solid var(--border); background:var(--bg2); color:var(--fg);
}
.dupeBtn:hover { background: var(--panel); }

/* ===== Scoped Menubar (kept from your version) ===== */
.menubar{
  background: var(--bg2);
  border-bottom: 1px solid var(--border);
  padding: 0 8px;
  position: sticky; top: 0;
  z-index: 150;
}
.appmenu-root{ list-style:none; margin:0; padding:0; display:flex; gap:6px; }
.appmenu-item{ position:relative; }
.appmenu-trigger{
  background:transparent; color:var(--fg);
  border:1px solid transparent;
  padding:6px 8px; border-radius:6px; cursor:pointer; font-size:13px;
}
.appmenu-trigger:hover, .appmenu-trigger:focus{
  background:var(--panel);
  border-color: var(--border);
  outline:none;
}

.appmenu{
  position:absolute; top:100%; left:0; min-width:190px;
  background:var(--panel); border:1px solid var(--border);
  border-radius:8px; padding:4px; margin-top:4px; display:none;
  box-shadow: 0 6px 16px rgba(0,0,0,.25);
  z-index: 160;
}
.appmenu.show{ display:block; }

.appmenu li{ list-style:none; }
.appmenu button[role="menuitem"]{
  display:block; width:100%; text-align:left;
  background:transparent; color:var(--fg); border:none;
  padding:6px 8px; border-radius:6px; cursor:pointer; font-size:13px;
}
.appmenu button[role="menuitem"]:hover{ background:var(--bg2); }

.appmenu-sep{ height:1px; background:var(--border); margin:4px; border-radius:1px; }

/* Nested submenu */
.appmenu-nested{ position:relative; }
.appmenu-trigger.nested{
  display:flex; justify-content:space-between; align-items:center; width:100%;
}
.appmenu-field{
  position:absolute;
  left:100%; top:0; margin-left:4px; min-width:190px;
  z-index: 170;
}

/* Mobile: stack */
@media (max-width:600px){
  .appmenu, .appmenu-field{
    position:fixed; left:12px; right:12px; top:auto; bottom:12px;
    margin:0; max-height:50vh; overflow:auto;
  }
}

.scopeInput{
  min-width:120px; max-width:220px;
  padding:8px 10px; border-radius:8px; border:1px solid var(--border);
  background: var(--editor); color: var(--fg); outline: none;
}
.scopeInput:empty:before{ content: attr(data-ph); color: var(--muted); }

/* List Extractor small tweaks (reuses .overlay and .dialog) */
#list-extractor-modal .title { margin-bottom: 6px; }
#list-extractor-modal .hint { margin-bottom: 8px; }
#le_result { white-space: pre; }

/* Field Swapper modal styles (scoped by #field-swapper-modal) */
  #field-swapper-modal .title { margin-bottom: 6px; }
  #field-swapper-modal .hint { margin-bottom: 8px; }

  .fs-list-wrap {
    border: 1px solid var(--border);
    background: var(--editor);
    border-radius: 10px;
    padding: 6px;
  }
  .fs-list {
    max-height: 320px;
    overflow: auto;
    margin: 0;
    padding: 0;
    list-style: none;
  }
  .fs-item {
    display: grid;
    grid-template-columns: 24px 64px 1fr;
    align-items: center;
    gap: 8px;
    padding: 8px;
    border-radius: 8px;
    border: 1px dashed transparent;
    user-select: none;
  }
  .fs-item + .fs-item { margin-top: 6px; }
  .fs-item[draggable="true"] { cursor: grab; }
  .fs-item.dragging { opacity: 0.6; }
  .fs-item.drop-before { border-color: var(--accent); }
  .fs-item.drop-after  { border-color: var(--accent); }

  .fs-handle {
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }
  .fs-num {
    font: 12px/1 ui-monospace, Menlo, Consolas, monospace;
    color: var(--muted);
    background: var(--pill);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 4px 8px;
    text-align: center;
  }
  .fs-name[contenteditable="true"] {
    min-height: 28px;
    padding: 6px 8px;
    border-radius: 8px;
    border: 1px solid var(--border);
    background: var(--bg2);
    outline: none;
  }
  .fs-name[contenteditable="true"]:empty:before {
    content: attr(data-ph);
    color: var(--muted);
  }
  
    /* Scoped to error-handling only */
  #error-handling-modal .dialog .title { margin-bottom: 6px; }
  #error-handling-modal #ehListWrap {
    border:1px solid var(--border);
    background: var(--editor);
    border-radius: 10px;
    max-height: 360px;
    overflow:auto;
    padding: 6px;
  }
  #error-handling-modal .eh-list {
    list-style: none;
    margin: 0;
    padding: 0;
  }
  #error-handling-modal .eh-item {
    display: grid;
    grid-template-columns: auto 1fr auto;
    align-items: start;
    gap: 10px;
    padding: 8px;
    border-bottom: 1px dashed var(--border);
  }
  #error-handling-modal .eh-item:last-child { border-bottom: none; }

  #error-handling-modal .eh-badge {
    border: 1px solid var(--border);
    background: var(--pill);
    border-radius: 999px;
    padding: 2px 8px;
    font-size: 12px;
    line-height: 1.4;
    white-space: nowrap;
  }
  #error-handling-modal .eh-badge.error { color: #fff; background: #b91c1c; border-color:#7f1d1d; }
  #error-handling-modal .eh-badge.warn  { color: #111; background: #fbbf24; border-color:#b45309; }

  #error-handling-modal .eh-msg {
    font-size: 14px;
    line-height: 1.45;
  }
  #error-handling-modal .eh-loc {
    font-size: 12px;
    color: var(--muted);
    white-space: nowrap;
  }

/* Append/Prepend (scoped) */
#append-prepend-modal .title { margin-bottom: 6px; }
#append-prepend-modal .hint { margin-bottom: 8px; }
#append-prepend-modal input[type="number"],
#append-prepend-modal input[type="text"],
#append-prepend-modal select {
  padding: 8px; border-radius: 8px; border: 1px solid var(--border);
  background: var(--editor); color: var(--fg);
}

/* Template Maker (scoped) */
#template-maker-modal .title { margin-bottom: 6px; }
#template-maker-modal .dialog .hint { margin-bottom: 10px; }

#field-paste-modal .title { margin-bottom: 6px; }
#field-paste-modal .hint { margin-bottom: 8px; }
#field-paste-modal input[type="number"],
#field-paste-modal input[type="text"]{
padding: 8px; border-radius: 8px; border: 1px solid var(--border);
background: var(--editor); color: var(--fg);
}

#set-field-modal .modal-scroll {
  max-height: 400px;   /* adjust to fit nicely */
  overflow-y: auto;
  padding-right: 6px;  /* space for scrollbar */
  margin-bottom: 12px; /* space before footer */
}

/* Math popup field pickers */
#math-modal .math-num {
  width: 90px;
  padding: 4px 6px;
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 13px;
}
#math-modal .math-op {
  width: 64px;
  padding: 4px 6px;
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 13px;
}
#math-modal .math-chk {
  margin-left: 8px;
  user-select: none;
  font-size: 13px;
}
#math-modal .row > * { margin-right: 6px; }

/* Show the safety button when hidden */
body.interface-hidden #showControlsBtn { display: inline-block; }


</style>
</head>
<body data-theme="light">
<script>
(function () {
  const KEY_SETTINGS = 'sqlFieldDump.settings';
  const KEY_THEME    = 'sqlFieldDump.theme';

  function readSettings() {
    let s = { theme: 'light' };
    try {
      const raw = localStorage.getItem(KEY_SETTINGS);
      if (raw) Object.assign(s, JSON.parse(raw));
      else {
        // legacy fallback
        const t = localStorage.getItem(KEY_THEME);
        if (t === 'dark' || t === 'light') s.theme = t;
      }
    } catch (_) {}
    return s;
  }

  function writeSettings(s) {
    try { localStorage.setItem(KEY_SETTINGS, JSON.stringify(s)); } catch (_) {}
  }

  function setThemeAttr(t) {
    const theme = (t === 'dark') ? 'dark' : 'light';
    // keep form controls (scrollbars, inputs) in sync
    document.documentElement.style.colorScheme = theme;
    const apply = () => document.body.setAttribute('data-theme', theme);
    if (document.body) apply(); else document.addEventListener('DOMContentLoaded', apply, { once: true });
  }

  // 1) Load persisted settings & apply before paint
  const SETTINGS = readSettings();
  setThemeAttr(SETTINGS.theme);

  // 2) Expose helpers for the rest of the app
  window.loadSettings = readSettings;
  window.saveSettings = writeSettings;
  window.applyTheme   = function (t) {
    const s = readSettings();
    s.theme = (t === 'dark') ? 'dark' : 'light';
    writeSettings(s);
    try { localStorage.setItem(KEY_THEME, s.theme); } catch (_) {} // keep legacy key updated
    setThemeAttr(s.theme);
  };
  window.SETTINGS = SETTINGS;

  // 3) If body renders before SETTINGS.theme, re-assert once DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    const curr = document.body.getAttribute('data-theme');
    if (curr !== SETTINGS.theme) setThemeAttr(SETTINGS.theme);
  }, { once: true });
})();
</script>
  <header>
    <h1>SQL Notepad</h1>
    <p>&nbsp;</p>
  </header>
  <!-- === Top Software Menu (scoped) === -->
<nav class="menubar" aria-label="App menu">
  <ul class="appmenu-root">
    <li class="appmenu-item">
      <button class="appmenu-trigger" data-menu="file">File</button>
      <ul class="appmenu appmenu-file" role="menu">
        <li><button id="mnuNewDoc"      role="menuitem">New</button></li>
        <li><button id="mnuImportBoard" role="menuitem">Import to Copy Board</button></li>
        <li><button id="mnuClearBoard"  role="menuitem">Clear Copy Board</button></li>
        <li class="appmenu-sep" aria-hidden="true"></li>
        <li><button id="mnuToggleBoard" role="menuitem">Hide/Show Copy Board</button></li>
        <li><button id="mnuToggleUI"    role="menuitem">Toggle Interface (Ctrl+S)</button></li>
      </ul>
    </li>

    <li class="appmenu-item">
      <button class="appmenu-trigger" data-menu="tools">Tools</button>
      <ul class="appmenu appmenu-tools" role="menu">
        <li><button id="mnuTokenizer" role="menuitem">Tokenizer</button></li>
        <li><button id="mnuMath"      role="menuitem">Math</button></li>

        <!-- Nested submenu: Field ▸ -->
        <li class="appmenu-nested">
          <button class="appmenu-trigger nested" data-menu="field">Field ▸</button>
          <ul class="appmenu appmenu-field" role="menu">
            <li><button id="mnuFieldAdd"    role="menuitem">Add Field</button></li>
            <li><button id="mnuFieldRemove" role="menuitem">Remove Field</button></li>
            <li><button id="mnuFieldSet"    role="menuitem">Set Field</button></li>
			<li><button id="mnuFieldSwapper" role="menuitem">Swapper</button></li>
			<li><button id="mnuFieldAppendPrepend" role="menuitem">Append/Prepend</button></li>
			<li><button id="mnuFieldPaste" role="menuitem">Paste</button></li>
          </ul>
        </li>

        <li class="appmenu-sep" aria-hidden="true"></li>
        <li><button id="mnuListExtractor" role="menuitem">List Extractor</button></li>
		<li><button id="mnuTemplateMaker" role="menuitem">Template Maker</button></li>
      </ul>
    </li>

    <li class="appmenu-item">
      <button class="appmenu-trigger" data-menu="help">Help</button>
      <ul class="appmenu appmenu-help" role="menu">
        <li><button id="mnuHelp" role="menuitem">Help</button></li>
      </ul>
    </li>

    <li class="appmenu-item">
      <button class="appmenu-trigger" data-menu="about">About</button>
      <ul class="appmenu appmenu-about" role="menu">
        <li><button id="mnuAbout" role="menuitem">About</button></li>
      </ul>
    </li>
  </ul>
</nav>
  <div class="bar">
    <span class="pill" id="countPill">Copy Board: 0 items</span>
    <span class="pill" id="rowsCountPill">Set: 0 rows</span>
	<span class="pill" id="setNumPill">Set: 0 #</span>
    <button id="importBtn" class="secondary" title="Import text from system clipboard">Import Clipboard</button>
	
    <button id="tokenizeBtn"   title="Replace last field in every tuple with a unique token">Tokenizer</button>
    <button id="nthFieldRemover" title="Remove the n’th field (1-based) from every tuple">Remove Field</button>
    <button id="addFieldBtn" title="Add a new field across all tuples">Add Field</button>
    <button id="mathButton"    title="Open math tools for field operations">Math</button>

    <div class="right">
      <button id="toggleBoardBtn" class="secondary" title="Hide/Show Copy Board">Hide Copy Board</button>
      <!-- Help button (book icon) -->
      <button id="helpBtn" class="secondary" title="About / Help">
        <span class="icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
               stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
            <path d="M4 4h16v15H6.5A2.5 2.5 0 0 0 4 21.5z"></path>
          </svg>
          Help
        </span>
      </button>

      <button id="settingsBtn" class="secondary" title="Settings">
        <span class="icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
               stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06a2 2 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09c.17 0 .35-.03 .51-.1 .61-.25 1-.85 1-1.51V9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06 .06c.51 .51 1.23 .66 1.82 .33H9c.66 0 1.26-.39 1.51-1V3a2 2 0 0 1 4 0v.09c.25 .61 .85 1 1.51 1h.09c.59 .33 1.31 .18 1.82-.33l.06-.06a2 2 0 1 1 2.83 2.83l-.06 .06c-.51 .51-.66 1.23-.33 1.82V9c0 .66 .39 1.26 1 1.51 .16 .07 .34 .1 .51 .1H21a2 2 0 0 1 0 4h-.09c-.17 0-.35 .03-.51 .1-.61 .25-1 .85-1 1.51z"></path>
          </svg>
          Settings
        </span>
      </button>
    </div>
  </div>

  <div class="wrap" id="mainWrap">
    <aside class="panel" id="leftPanel">
      <h2>Copy Board</h2>
      <small>Paste here (CSV, lines, or whitespace). Edits update the queue.</small>
      <textarea id="board" placeholder='Examples:
alpha, "New York", bravo
or one
per
line'></textarea>
      <div class="row">
        <button id="dedupeBtn" class="secondary">Dedupe</button>
        <button id="shuffleBtn" class="secondary">Shuffle</button>
      </div>
    </aside>

    <textarea id="textArea" placeholder="Paste or type SQL here…"></textarea>
  </div>

  <!-- Highlighter overlay & safety show-controls button -->
  <div id="highlightOverlay" aria-hidden="true"></div>
  <button id="showControlsBtn" title="Show Controls">Show Controls</button>

  <!-- Remove n’th Field Modal -->
  <div class="overlay" id="nth-remover-modal">
    <div class="dialog">
      <div class="title">Remove n’th Field</div>
      <div class="hint">Enter a <b>1-based</b> field index (1 = first field). Removes that field from all tuples.</div>
      <div class="row">
        <label>Field #
          <input type="number" id="nthIndexInput" min="1" value="1" style="width:90px;">
        </label>
      </div>
      <div class="btns">
        <button id="nthCancelBtn">Cancel</button>
        <button id="nthApplyBtn" class="primary">Remove Field</button>
      </div>
    </div>
  </div>

  <!-- Add Field Modal -->
  <div class="overlay" id="add-field-modal">
    <div class="dialog">
      <div class="title">Add Field</div>
      <div class="hint">Choose field type and where to insert it. Fields are <b>1-based</b>.</div>
      <div class="row">
        <label><input type="radio" name="newFieldType" value="number" checked> Number (0)</label>
        <label><input type="radio" name="newFieldType" value="string"> String ('')</label>
      </div>
      <div class="row">
        <label>Insert after field #
          <input type="number" id="addAfterInput" min="0" value="0" style="width:90px;">
        </label>
        <small class="hint">Use 0 to insert at the beginning.</small>
      </div>
      <div class="btns">
        <button id="addFieldCancelBtn">Cancel</button>
        <button id="addFieldApplyBtn" class="primary">Add Field</button>
      </div>
    </div>
  </div>

  <!-- Math Modal -->
  <div class="overlay" id="math-modal">
    <div class="dialog">
      <div class="title">SQL Field Math</div>

      <div class="hint">Result: <b>Target = Number (op) Source</b> · Fields are <b>1-based</b> · Flip → <b>Source (op) Number</b></div>
      <div class="row" id="interfieldRow"></div>
      <div class="btns">
        <button id="applyInterfieldBtn" class="primary">Apply</button>
      </div>

      <div class="divider"></div>

      <div class="hint">Result: <b>Field = Field (op) Number</b> · Fields are <b>1-based</b> · Optional Flip → <b>Number (op) Field</b></div>
      <div class="row" id="fieldRow"></div>
      <div class="btns">
        <button id="applyFieldBtn" class="primary">Apply</button>
      </div>

      <div class="divider"></div>

      <div class="hint">Result: <b>Target = Field Ⓐ (op) Field Ⓑ</b> · Fields are <b>1-based</b></div>
      <div class="row" id="fieldFieldRow"></div>
      <div class="btns">
        <button id="applyFieldFieldBtn" class="primary">Apply</button>
        <button id="mathCloseBtn">Close</button>
      </div>

      <div class="divider"></div>

      <div class="title" style="font-size:14px; margin:0;">Apply to</div>
      <div class="row">
        <label><input type="checkbox" id="mathScopeSet" checked> Current set</label>
        <label><input type="checkbox" id="mathScopeDoc"> Whole document</label>
      </div>
    </div>
  </div>
<!-- Set Field Modal -->
<div class="overlay" id="set-field-modal">
  <div class="dialog">
    <div class="title">Set Field</div>
    <div class="hint">Fields are <b>1-based</b>. Apply to the current set (located at caret) or the whole document.</div>

    <!-- Scrollable tools area -->
    <div class="modal-scroll" style="max-height:400px; overflow-y:auto; padding-right:6px; margin-bottom:12px;">

      <!-- Apply scope -->
      <div class="divider"></div>
      <div class="title" style="font-size:14px; margin:0;">Apply to</div>
      <div class="row">
        <div id="setScopeInput" class="scopeInput" contenteditable="true" data-ph="doc or 1, 2, 3…">doc</div>
        <small class="hint" style="margin-top:11px;">Type <b>doc</b> for whole document, or a number of set (sets = rows separated by blank lines).</small>
      </div>

      <div class="divider"></div>

      <!-- Op A: target = X when Y = value -->
      <div class="title" style="font-size:14px;margin-bottom:6px;">Target field = value when other field equals</div>
      <div class="row">
        <label>Target field
          <input type="number" id="sf_target_when" min="1" value="1" style="width:90px;">
        </label>
        <label>Value type
          <select id="sf_val_when_type">
            <option value="string">String</option>
            <option value="number">Number</option>
          </select>
        </label>
        <label>Value
          <input type="text" id="sf_val_when" placeholder="'' or 0">
        </label>
        <label>When field
          <input type="number" id="sf_cond_field" min="1" value="1" style="width:90px;">
        </label>
        <label>Equals type
          <select id="sf_cond_type">
            <option value="string">String</option>
            <option value="number">Number</option>
          </select>
        </label>
        <label>Equals
          <input type="text" id="sf_cond_value" placeholder="match value">
        </label>
      </div>
      <div class="btns">
        <button id="sf_apply_when" class="primary">Apply</button>
      </div>

      <div class="divider"></div>

      <!-- Op B: target = X (unconditional) -->
      <div class="title" style="font-size:14px;margin-bottom:6px;">Target field = value (unconditional)</div>
      <div class="row">
        <label>Target field
          <input type="number" id="sf_target_all" min="1" value="1" style="width:90px;">
        </label>
        <label>Value type
          <select id="sf_val_all_type">
            <option value="string">String</option>
            <option value="number">Number</option>
          </select>
        </label>
        <label>Value
          <input type="text" id="sf_val_all" placeholder="'' or 0">
        </label>
      </div>
      <div class="btns">
        <button id="sf_apply_all" class="primary">Apply</button>
      </div>

      <div class="divider"></div>

      <!-- Op C: fields X..Y replaced with a string -->
      <div class="title" style="font-size:14px;margin-bottom:6px;">Fields X to Y replaced with string field</div>
      <div class="row">
        <label>From field
          <input type="number" id="sf_span_start" min="1" value="1" style="width:90px;">
        </label>
        <label>To field
          <input type="number" id="sf_span_end" min="1" value="2" style="width:90px;">
        </label>
        <label>Replacement string
          <input type="text" id="sf_span_text" placeholder="new value">
        </label>
      </div>
      <div class="btns">
        <button id="sf_apply_span" class="primary">Apply</button>
      </div>

      <div class="divider"></div>

      <!-- Op D: increment sequence tool -->
      <div class="title" style="font-size:14px;margin-bottom:6px;">Increment sequence into field</div>
      <div class="hint">Sets the chosen field in each row to a running number starting at <b>Start number</b>. Applies to the chosen scope (doc or set #).</div>
      <div class="row">
        <label>Field #
          <input type="number" id="sf_inc_field" min="1" value="1" style="width:90px;">
        </label>
        <label>Start number
          <input type="number" id="sf_inc_start" value="1" style="width:120px;">
        </label>
        <label>
          <input type="checkbox" id="sf_inc_continue">
          Continue across sets
        </label>
      </div>
      <div class="btns">
        <button id="sf_apply_inc" class="primary">Apply</button>
      </div>

    </div><!-- /.modal-scroll -->

    <!-- Fixed footer -->
    <div class="btns">
      <button id="sf_close">Close</button>
    </div>
  </div>
</div>
  <!-- Settings Modal -->
  <div class="overlay" id="settings-modal">
    <div class="dialog">
      <div class="title">Settings</div>
      <div class="hint">Personalize editor behaviors.</div>

      <div class="row">
		<label>
		  <input type="checkbox" id="clearLastField">
		  Clear last field on Ctrl+D duplicate line
		</label>
      </div>

      <div class="row">
        <label>
          <input type="checkbox" id="tokenizerReplaceAll">
          Tokenizer: replace <b>all</b> last fields (not just empty)
        </label>
      </div>

      <div class="divider"></div>

      <div class="title" style="font-size:14px; margin:0;">Token Style</div>
      <div class="hint">Affects <em>Tokenizer</em> and <em>Ctrl+G</em> token generation.</div>
      <div class="row">
        <label>Style
          <select id="tokenStyle">
            <option value="alnum">Alpha-numeric (A-z, 0-9)</option>
            <option value="alpha">Alpha only (A-z)</option>
            <option value="upper">Uppercase (A-Z)</option>
            <option value="lower">Lowercase (a-z)</option>
          </select>
        </label>
        <label>Length
          <input type="number" id="tokenLength" min="4" max="64" value="12" style="width:90px;">
        </label>
      </div>

      <div class="divider"></div>

      <div class="title" style="font-size:14px; margin:0;">Theme</div>
      <div class="row">
        <label>Theme
          <select id="themeSelect">
            <option value="light">Light</option>
            <option value="dark">Dark</option>
          </select>
        </label>
      </div>

      <div class="btns">
        <button id="settingsCloseBtn" class="primary">Done</button>
      </div>
    </div>
  </div>

  <!-- About / Help Modal -->
  <div class="overlay" id="about-modal">
    <div class="dialog">
      <div class="title">About SQL Notepad</div>
      <div class="hint">Keyboard shortcuts & features</div>
      <div class="about-list">
        <ul>
          <li><kbd>Ctrl</kbd>+<kbd>B</kbd> – collect selection to Copy Board (removes it from editor)</li>
          <li><kbd>Ctrl</kbd>+<kbd>I</kbd> – dump Copy Board items into the n’th field across tuples (field dump)</li>
          <li><kbd>Ctrl</kbd>+<kbd>G</kbd> – insert a unique random token at the caret</li>
          <li><kbd>Ctrl</kbd>+<kbd>D</kbd> – duplicate current line (down). If enabled in <em>Settings</em>, clears the <em>last field</em> on the duplicate</li>
          <li><kbd>Ctrl</kbd>+<kbd>R</kbd> – remove current line, crimping content upward</li>
		  <li><kbd>Ctrl</kbd>+<kbd>K</kbd> – Copy current field across all tuples in set</li>
          <li><kbd>Ctrl</kbd>+<kbd>Z</kbd>/<kbd>Ctrl</kbd>+<kbd>Y</kbd> – undo/redo snapshots (10-depth ring)</li>
		  <li><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>E</kbd> – Open duplicate token report</li>
		  <li><kbd>Ctrl</kbd>+<kbd>S</kbd> – toggle interface visibility (safety button also available)</li>
          <li><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>V</kbd> – import clipboard into Copy Board</li>
          <li><b>Tokenizer</b> – fills only empty last fields (<code>''</code> or <code>' '</code>) with unique tokens; optionally replace <em>all</em> last fields via <em>Settings</em></li>
          <li><b>Remove n’th Field</b> – removes a 1-based field index from every tuple</li>
          <li><b>Add Field</b> – inserts Number (<code>0</code>) or String (<code>''</code>) after the specified field index</li>
          <li><b>Math</b> – Interfield (Number & Field), Field Math (Field & Number), and Field vs Field → Target</li>
          <li><b>Copy Board</b> – accepts CSV, lines, or whitespace; includes Dedupe and Shuffle utilities. Item in double quotes will maintain comma.</li>
        </ul>
      </div>
      <div class="btns">
        <button id="aboutCloseBtn" class="primary">Close</button>
      </div>
    </div>
  </div>
  <!-- About Modal -->
<div class="overlay" id="about-info-modal">
  <div class="dialog">
    <div class="title">About SQL Notepad</div>
    <div class="hint">Software information</div>
    <div class="about-list">
      <p><b>Purpose:</b> This software is used to edit tuples with various tools and functions.</p>
      <p><b>Known limitation:</b> It will double escape sometimes, watch your escaped apostrophes.</p>
      <p><b>License:</b> This is MIT licensed software. Use for personal or any commercial uses.</p>
      <p><b>Credits:</b> Created by Jeremy Benson using GPT5. Created in 2025.</p>
      <p><b>Disclaimer:</b> Use at your own risk and be watchful of data.</p>
    </div>

    <div class="btns">
      <button id="aboutInfoCloseBtn" class="primary">Close</button>
    </div>
  </div>
</div>
<!-- Error Handling Modal -->
<div class="overlay" id="error-handling-modal" aria-modal="true" role="dialog">
  <div class="dialog">
    <div class="title">Error Handling</div>
    <div class="hint">Scan the current document for errors and warnings. Results are grouped as a scrollable list.</div>

    <div id="ehSummary" class="pill" style="display:inline-block; margin-bottom:8px;">—</div>

    <div id="ehListWrap">
      <ul id="ehList" class="eh-list" aria-live="polite"></ul>
    </div>

    <div class="btns" style="margin-top:10px;">
      <button id="ehRescanBtn" class="secondary">Rescan</button>
      <button id="ehCloseBtn" class="primary">Close</button>
    </div>
  </div>
</div>
<!-- Duplicate End Tokens Modal -->
<div class="overlay" id="dupes-modal" aria-hidden="true">
  <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="dupesTitle">
    <div class="title" id="dupesTitle">Duplicate End Field Tokens</div>
    <div class="hint">Shows each end-field token that appears in <b>2+</b> tuples. List is de-duplicated.</div>

    <div id="dupesListWrap">
      <div id="dupesHeader" style="padding:8px 10px;">
        <span id="dupesCount">Scanning…</span>
        <input id="dupesSearch" type="text" placeholder="Filter tokens…">
      </div>
      <div id="dupesList" role="list"></div>
    </div>

    <div class="btns" style="margin-top:12px;">
      <button id="dupesCopyAllBtn" class="dupeBtn">Copy All</button>
      <button id="dupesCloseBtn" class="primary">Close</button>
    </div>
  </div>
</div>
<!-- List Extractor Modal -->
<div class="overlay" id="list-extractor-modal" aria-hidden="true">
  <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="listExtractorTitle">
    <div class="title" id="listExtractorTitle">List Extractor</div>
    <div class="hint">Build a CSV list from a specific field across <b>doc</b> or a set number.</div>

    <div class="divider"></div>

    <!-- Scope (same pattern as Set Field modal) -->
    <div class="title" style="font-size:14px; margin:0;">Scope</div>
    <div class="row">
      <div id="listScopeInput" class="scopeInput" contenteditable="true" data-ph="doc or 1, 2, 3…">doc</div>
      <small class="hint" style="margin-top:11px;">Type <b>doc</b> for the whole document, or a 1-based set number.</small>
    </div>

    <div class="divider"></div>

    <!-- Field + output options -->
    <div class="row">
      <label>Field #
        <input type="number" id="le_field" min="1" value="1" style="width:90px;">
      </label>

      <label>Output
        <select id="le_output_mode">
          <option value="csv">Comma-separated (single line)</option>
          <option value="lines">One per line</option>
        </select>
      </label>

      <label>
        <input type="checkbox" id="le_trim" checked>
        Trim values
      </label>

      <label>
        <input type="checkbox" id="le_unique">
        Unique only
      </label>
    </div>

    <div class="divider"></div>

    <!-- Results -->
    <div class="row" style="width:100%;">
      <textarea id="le_result" readonly
        style="width:100%; min-height:160px; resize:vertical; background:var(--editor); color:var(--fg); border:1px solid var(--border); border-radius:8px; padding:10px; font-family: ui-monospace, Menlo, Consolas, monospace; font-size:13px;"></textarea>
    </div>

    <div class="row" style="justify-content:space-between; align-items:center;">
      <span id="le_count" class="hint">0 items</span>
      <div class="btns" style="margin:0;">
        <button id="le_copyBtn" class="dupeBtn">Copy</button>
        <button id="le_closeBtn" class="primary">Close</button>
      </div>
    </div>
  </div>
</div>
<!-- Field Swapper Modal -->
<div class="overlay" id="field-swapper-modal" aria-hidden="true">
  <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="fsTitle">
    <div class="title" id="fsTitle">Field Swapper</div>
    <div class="hint">
      Drag to reorder. Double-click a name to edit. Applies to the whole document.
    </div>

    <div class="fs-list-wrap">
      <ul class="fs-list" id="fsList" aria-label="Field order"></ul>
    </div>

    <div class="btns" style="margin-top:12px;">
      <button id="fsCancelBtn">Cancel</button>
      <button id="fsApplyBtn" class="primary">Apply Order to Document</button>
    </div>
  </div>
</div>
<!-- Append/Prepend Modal -->
<div class="overlay" id="append-prepend-modal" aria-modal="true" role="dialog">
  <div class="dialog">
    <div class="title">Append / Prepend</div>
    <div class="hint">Operate across the entire document. If the chosen source/string is empty, that tuple is skipped.</div>

    <!-- A) Target = Target [Append/Prepend] × Field -->
    <div class="title" style="font-size:14px;margin:8px 0 6px;">A) Target field ⟵ target [Append/Prepend] × field</div>
    <div class="row">
      <label>Target field
        <input type="number" id="ap_target_field_f" min="1" value="1" style="width:90px;">
      </label>
      <label>Operation
        <select id="ap_op_f">
          <option value="append">Append</option>
          <option value="prepend">Prepend</option>
        </select>
      </label>
      <label>× Field
        <input type="number" id="ap_source_field" min="1" value="2" style="width:90px;">
      </label>
    </div>
    <div class="btns">
      <button id="ap_apply_field" class="primary">Apply Field → Target</button>
    </div>

    <div class="divider"></div>

    <!-- B) Target = Target [Append/Prepend] × String -->
    <div class="title" style="font-size:14px;margin:8px 0 6px;">B) Target field ⟵ target [Append/Prepend] × string</div>
    <div class="row">
      <label>Target field
        <input type="number" id="ap_target_field_s" min="1" value="1" style="width:90px;">
      </label>
      <label>Operation
        <select id="ap_op_s">
          <option value="append">Append</option>
          <option value="prepend">Prepend</option>
        </select>
      </label>
      <label>× String
        <input type="text" id="ap_string_input" placeholder="leave empty to skip">
      </label>
    </div>
    <div class="btns">
      <button id="ap_apply_string" class="primary">Apply String → Target</button>
      <button id="ap_close_btn">Close</button>
    </div>
  </div>
</div>
<!-- Template Maker Modal -->
<div class="overlay" id="template-maker-modal" aria-modal="true" role="dialog">
  <div class="dialog">
    <div class="title">Template Maker</div>

    <!-- Shared options -->
    <div class="row" style="margin-bottom:6px;">
      <label>Field # (1-based)
        <input type="number" id="tmFieldIndex" min="1" value="1" style="width:100px;">
      </label>
      <label style="margin-left:8px;">
        <input type="checkbox" id="tmSepBlank" checked>
        Add blank line between copies
      </label>
    </div>

    <!-- Method 1 -->
    <div class="hint" style="margin-top:6px;"><b>Method 1 — Use Copy Board (CSV-aware)</b></div>
    <div class="hint">
      The <b>current set</b> becomes a <b>working template</b>. Keep caret at end of last tuple
      A copy is created for each item in the <b>Copy Board</b>, and that item is placed in the chosen
      <b>n’th field</b> of <em>every row</em> in that copy. All copies are appended to the end of the document.
    </div>
    <div class="btns" style="margin-top:8px;">
      <button id="tmApplyCBBtn" class="primary">Make Templates from Copy Board</button>
    </div>

    <div class="divider"></div>

    <!-- Method 2 -->
    <div class="hint"><b>Method 2 — One-per-line list</b></div>
    <div class="hint" style="margin-bottom:6px;">
      <i>Note:</i> Copy Board uses a CSV list. Place a <b>one-per-line</b> list here to maintain commas inside a field item.
    </div>
    <div class="row" style="margin-bottom:0;">
      <textarea id="tmListAlt" placeholder="one item per line…" style="width:100%;min-height:120px;background:var(--editor);color:var(--fg);border:1px solid var(--border);border-radius:8px;padding:10px;font-family: ui-monospace, Menlo, Consolas, monospace;line-height:1.4;"></textarea>
    </div>
    <div class="row">
      <small class="hint">
        Tip: The set is the block of non-blank lines around your caret. If the field index is larger than the row’s field count,
        that row is skipped (keeps the original row).
      </small>
    </div>
    <div class="btns">
      <button id="tmApplyLinesBtn" class="primary">Make Templates from Lines</button>
      <button id="tmCloseBtn">Close</button>
    </div>
  </div>
</div>
<!-- 2) MODAL (can be placed alongside your other modals) -->
<div class="overlay" id="field-paste-modal" aria-modal="true" role="dialog">
  <div class="dialog">
    <div class="title">Field → Paste</div>
    <div class="hint">Choose a mode, set scope (<code>doc</code> or set #), and provide a literal field list. <b>Literals are inserted verbatim</b>.</div>
    <div class="row" style="gap:12px;align-items:center;flex-wrap:wrap">
      <label style="display:flex;align-items:center;gap:6px">
        <input type="radio" name="fp_mode" id="fp_mode_insert" value="insert" checked>
        Insert after #
      </label>
      <input type="number" id="fp_after" min="0" value="0" style="width:90px;">
      <label style="display:flex;align-items:center;gap:6px;margin-left:16px">
        <input type="radio" name="fp_mode" id="fp_mode_overwrite" value="overwrite">
        Overwrite fields X–Y
      </label>
      <input type="number" id="fp_from" min="1" value="1" style="width:90px;">
      <span>to</span>
      <input type="number" id="fp_to" min="1" value="1" style="width:90px;">
      <label style="margin-left:16px">Scope
        <input type="text" id="fp_scope" placeholder="doc or set #" style="width:140px;">
      </label>
    </div>
    <div class="row">
      <label style="flex:1">Literal to insert / overwrite with
        <input type="text" id="fp_value" placeholder="e.g. 'apple', 'resources', 'JUlakjdfEEzaA'" style="width:100%">
      </label>
    </div>
    <div class="hint">For <b>Insert</b>: value is inserted as a single field verbatim. For <b>Overwrite</b>: you may provide <em>one or more fields</em> separated by commas (outside quotes) — they replace X..Y. Backslashes and sequences like <code>\'</code> are preserved.</div>
    <div class="btns">
      <button id="fp_cancel">Cancel</button>
      <button id="fp_apply" class="primary">Apply</button>
    </div>
  </div>
</div>
</div>
<!-- =============================
Tools → Field → Paste Modal
============================= -->
<div class="overlay" id="field-paste-modal" aria-modal="true" role="dialog">
  <div class="dialog">
    <div class="title">Field → Paste</div>
    <div class="hint">Choose a mode, set scope (<code>doc</code> or set #), and provide a literal field list. <b>Literals are inserted verbatim</b>.</div>

    <div class="row" style="gap:12px;align-items:center;flex-wrap:wrap">
      <label style="display:flex;align-items:center;gap:6px">
        <input type="radio" name="fp_mode" id="fp_mode_insert" value="insert" checked>
        Insert after #
      </label>
      <input type="number" id="fp_after" min="0" value="0" style="width:90px;">

      <label style="display:flex;align-items:center;gap:6px;margin-left:16px">
        <input type="radio" name="fp_mode" id="fp_mode_overwrite" value="overwrite">
        Overwrite fields X–Y
      </label>
      <input type="number" id="fp_from" min="1" value="1" style="width:90px;">
      <span>to</span>
      <input type="number" id="fp_to" min="1" value="1" style="width:90px;">

      <label style="margin-left:16px">Scope
        <input type="text" id="fp_scope" placeholder="doc or set #" style="width:140px;">
      </label>
    </div>

    <div class="row">
      <label style="flex:1">Literal to insert / overwrite with
        <input type="text" id="fp_value" placeholder="e.g. 'apple', 'resources', 'JUlakjdfEEzaA'" style="width:100%">
      </label>
    </div>
    <div class="hint">For <b>Insert</b>: value is inserted as a single field verbatim. For <b>Overwrite</b>: you may provide <em>one or more fields</em> separated by commas (outside quotes) — they replace X..Y. Backslashes and sequences like <code>\'</code> are preserved.</div>
    <div class="btns">
      <button id="fp_cancel">Cancel</button>
      <button id="fp_apply" class="primary">Apply</button>
    </div>
  </div>
</div>
</div>
<!-- Helpers: tuple parsing + editor line utilities -->
<script id="helpers-duplicate-line-lib">
(function(){
  const H = {};

  H.getCurrentLineBounds = function(text, caret){
    const start = text.lastIndexOf("\n", Math.max(0, caret - 1)) + 1;
    const endNL = text.indexOf("\n", caret);
    const end = endNL === -1 ? text.length : endNL;
    return { start, end };
  };

  H.setCaretPreserveColumn = function(textarea, originalStart, originalLine, column){
    const newLineStart = originalStart + originalLine.length + 1; // after newline
    const newPos = newLineStart + Math.min(column, originalLine.length);
    textarea.selectionStart = textarea.selectionEnd = newPos;
    textarea.focus();
  };

  // SQL tuple parser: supports '' and \' in single-quoted strings; ignores commas inside strings
  H.parseSqlTupleLine = function(line){
    const leadingMatch = line.match(/^\s*/);
    const leading = leadingMatch ? leadingMatch[0] : "";
    const afterLead = line.slice(leading.length);

    const openIdxRel = afterLead.indexOf("(");
    if (openIdxRel === -1) return { ok:false };

    const openIdx = leading.length + openIdxRel;
    const s = line;
    let i = openIdx + 1;
    let inStr = false;
    let fields = [];
    let cur = "";

    function pushField(){ fields.push(cur.trim()); cur = ""; }

    for (; i < s.length; i++){
      const ch = s[i];

      if (inStr){
        if (ch === "\\"){
          if (i + 1 < s.length){
            cur += ch + s[i+1];
            i++;
            continue;
          }
        }
        if (ch === "'"){
          if (s[i+1] === "'"){
            cur += "''";
            i++;
            continue;
          } else {
            cur += ch;
            inStr = false;
            continue;
          }
        }
        cur += ch;
        continue;
      }

      if (ch === "'"){ inStr = true; cur += ch; continue; }
      if (ch === ","){ pushField(); continue; }
      if (ch === ")"){ pushField(); break; }

      cur += ch;
    }

    if (i >= s.length) return { ok:false };

    const closeIdx = i;
    const suffix = s.slice(closeIdx + 1);

    function reconstructed(newFields){
      return `${leading}(${newFields.join(", ")})${suffix}`;
    }

    return { ok:true, fields, leading, openIdx, closeIdx, suffix, reconstructed };
  };

  H.clearLastFieldSmart = function(fields){
    if (!fields.length) return fields;
    const f = fields[fields.length - 1].trim();
    const isLikelyString = f.startsWith("'") && f.endsWith("'");
    const isNumeric = /^[+-]?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?$/.test(f);

    if (isLikelyString){ fields[fields.length - 1] = "''"; }
    else if (isNumeric){ fields[fields.length - 1] = "0"; }
    else if (/^NULL$/i.test(f)){ fields[fields.length - 1] = "''"; }
    else { fields[fields.length - 1] = "''"; }
    return fields;
  };

  // Core duplicator
  H.duplicateCurrentLineInTextarea = function(ta, { clearLast } = { clearLast:false }){
    const text = ta.value;
    const caret = ta.selectionStart;
    const { start, end } = H.getCurrentLineBounds(text, caret);
    const line = text.slice(start, end);
    const column = caret - start;

    let duplicateLine = line;
    if (clearLast){
      const parsed = H.parseSqlTupleLine(line);
      if (parsed.ok){
        const fieldsCopy = parsed.fields.slice();
        H.clearLastFieldSmart(fieldsCopy);
        duplicateLine = parsed.reconstructed(fieldsCopy);
      }
    }

    const before = text.slice(0, end);
    const after  = text.slice(end);
    const insertion = (text[end] === "\n" ? "" : "\n") + duplicateLine;
    ta.value = before + insertion + after;

    H.setCaretPreserveColumn(ta, start, line, column);
  };

  // Expose
  window.DupHelpers = H;
})();
</script>
<script id="feature-duplicate-line-hotfix">
(function(){
  const ta = document.getElementById('textArea');
  if (!ta) return;

  // checkbox from Settings
  const isClearLastEnabled = () => {
    const cb = document.getElementById('clearLastField');
    return !!(cb && cb.checked);
  };

  // use your helpers (already loaded in helpers-duplicate-line-lib)
  const H = window.DupHelpers || {};
  const parseTuple = H.parseSqlTupleLine || null;

  // map absolute caret to (lines, lineIndex, column)
  function getLineIndexAndColumn(text, pos){
    const lines = text.split(/\r?\n/);
    let acc = 0;
    for (let i = 0; i < lines.length; i++){
      const len = lines[i].length + 1; // include newline
      if (pos <= acc + len - 1){
        return { lines, lineIndex: i, column: pos - acc };
      }
      acc += len;
    }
    return { lines, lineIndex: lines.length - 1, column: lines.at(-1)?.length ?? 0 };
  }

  // clear only if the last field is a quoted string; numbers unchanged
  function clearLastFieldIfString(line){
    if (!parseTuple) return line;
    const p = parseTuple(line);
    if (!p.ok || !p.fields.length) return line;

    const i = p.fields.length - 1;
    const last = String(p.fields[i]).trim();
    const isQuoted = last.startsWith("'") && last.endsWith("'");
    const isNumeric = /^[+-]?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?$/.test(last);

    if (isQuoted){
      p.fields[i] = "''";      // empty string
      return p.reconstructed(p.fields);
    }
    // number or other → leave as-is
    return line;
  }

  function duplicateCurrentLine(){
    const pos = ta.selectionStart ?? 0;
    const { lines, lineIndex, column } = getLineIndexAndColumn(ta.value, pos);
    const srcLine = lines[lineIndex];

    let dup = srcLine;
    if (isClearLastEnabled()){
      dup = clearLastFieldIfString(dup); // uses parser that handles '' and \'
    }

    // ALWAYS put duplicate on a NEW physical line below
    lines.splice(lineIndex + 1, 0, dup);
    ta.value = lines.join('\n');

    // caret → same column on the new duplicate line
    let startOfNew = 0;
    for (let i = 0; i <= lineIndex; i++) startOfNew += lines[i].length + 1;
    const newCaret = startOfNew + Math.min(column, lines[lineIndex + 1].length);
    ta.setSelectionRange(newCaret, newCaret);

    // optional hooks present in your app
    try { window.pushSnapshot?.(); } catch(_) {}
    try { window.updateRowsCountPill?.(); } catch(_) {}
  }

  // Ctrl+D (capture) — style matches your current file
  document.addEventListener('keydown', function(e){
    const k = (e.key || '').toLowerCase();
    const isOurCombo = (k === 'd' && e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey);
    if (!isOurCombo) return;
    if (document.activeElement !== ta) return;

    e.preventDefault();
    e.stopPropagation();
    if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();

    duplicateCurrentLine();
  }, true);
})();
</script>
<script id="feature-set-pills-update">
(function(){
  const ta = document.getElementById("textArea");
  const rowsPill = document.getElementById("rowsCountPill");
  const setPill  = document.getElementById("setNumPill");
  if (!ta || !rowsPill || !setPill) return;

  // --- Split content into sets at fully blank lines
  function splitIntoSetsByBlankLine(text){
    const lines = text.split("\n");
    const sets = [];
    let cur = [];
    let startLine = 0;

    function pushSet(endLine){
      sets.push({ startLine, endLine, lines: cur.slice() });
      cur = [];
    }

    for (let i = 0; i < lines.length; i++){
      const ln = lines[i];
      if (ln.trim() === ""){
        if (cur.length) pushSet(i - 1);
        startLine = i + 1;
      } else {
        cur.push(ln);
      }
    }
    if (cur.length) pushSet(lines.length - 1);

    // Map each original line index to a set index
    const lineIndexToSet = new Array(lines.length).fill(-1);
    for (let s = 0; s < sets.length; s++){
      const { startLine, endLine } = sets[s];
      for (let i = startLine; i <= endLine; i++){
        lineIndexToSet[i] = s;
      }
    }
    // For blank lines, map to prior set if any
    for (let i = 0; i < lines.length; i++){
      if (lineIndexToSet[i] === -1){
        lineIndexToSet[i] = i > 0 ? lineIndexToSet[i - 1] : -1;
      }
    }
    return { sets, lineIndexToSet, totalLines: lines.length };
  }

  // --- Convert physical lines of a set into logical tuple rows
  // Handles: strings in single quotes with '' or \' escapes; parentheses depth outside strings
  function logicalRowsFromSetLines(lines){
    const rows = [];
    let buf = "";
    let depth = 0;
    let seenOpen = false;
    let inStr = false;

    function flush(){
      const t = buf.trim();
      if (t) rows.push(t);
      buf = "";
      depth = 0;
      seenOpen = false;
      inStr = false;
    }

    for (let li = 0; li < lines.length; li++){
      const s = lines[li];
      if (buf) buf += "\n";
      buf += s;

      for (let i = 0; i < s.length; i++){
        const ch = s[i];

        if (inStr){
          if (ch === "\\"){ // backslash escape: skip next char
            i++;
            continue;
          }
          if (ch === "'"){
            if (i + 1 < s.length && s[i + 1] === "'"){
              i++; // doubled apostrophe escape
              continue;
            } else {
              inStr = false; // end string
              continue;
            }
          }
          continue; // ignore tuple chars inside strings
        } else {
          if (ch === "'"){ inStr = true; continue; }
          if (ch === "("){ seenOpen = true; depth++; continue; }
          if (ch === ")"){
            if (depth > 0) depth--;
            if (depth === 0 && seenOpen){
              // Completed one tuple row (even if trailing chars exist)
              flush();
            }
            continue;
          }
        }
      }
    }

    if (buf.trim()) flush(); // leftover (possibly incomplete) row
    return rows;
  }

  // --- Map caret to line index
  function caretToLineIndex(text, caret){
    let count = 0;
    for (let i = 0; i < caret; i++){
      if (text.charCodeAt(i) === 10) count++; // '\n'
    }
    return count;
  }

  function computeAndRender(){
    const text = ta.value;
    const caret = ta.selectionStart ?? 0;

    const { sets, lineIndexToSet } = splitIntoSetsByBlankLine(text);
    const caretLine = caretToLineIndex(text, caret);
    let setIdx = lineIndexToSet[caretLine];
    if (setIdx < 0) setIdx = 0; // fallback when document empty

    const displaySet = sets.length ? (setIdx + 1) : 0;

    let rowCount = 0;
    if (sets[setIdx]){
      const logical = logicalRowsFromSetLines(sets[setIdx].lines);
      rowCount = logical.filter(r => r.trim() !== "").length;
    }

    rowsPill.textContent = `Set: ${rowCount} rows`;
    setPill.textContent  = `Set: ${displaySet} #`;
  }

  // Update on edits and caret moves
  ta.addEventListener("input", computeAndRender);
  ta.addEventListener("click", computeAndRender);
  ta.addEventListener("keyup", computeAndRender);
  document.addEventListener("selectionchange", function(){
    if (document.activeElement === ta) computeAndRender();
  });

  // Initial paint
  computeAndRender();
})();
</script>
<script id="menubar-popups">
(function(){
  // ===== Utilities
  const qsa = (sel, root=document) => Array.from(root.querySelectorAll(sel));
  const isEl = (x) => x && x.nodeType === 1;

  // Find the <ul> menu that a trigger controls (assumes it's the nextElementSibling)
  function menuForTrigger(btn){
    if (!isEl(btn)) return null;
    let next = btn.nextElementSibling;
    if (isEl(next) && next.matches(".appmenu, .appmenu-field")) return next;
    return null;
  }

  // Top-level <li.appmenu-item> for a trigger
  function topItemOf(trigger){
    return trigger?.closest(".appmenu-item") || null;
  }

  // Close ALL menus
  function closeAll(){
    qsa(".appmenu, .appmenu-field").forEach(ul => {
      ul.style.display = "none";
      ul.removeAttribute("data-open");
    });
    qsa(".appmenu-trigger").forEach(btn => {
      btn.setAttribute("aria-expanded", "false");
      btn.classList.remove("is-open");
    });
  }

  // Close all menus except one branch (e.g., keep a submenu open)
  function closeAllExcept(keep){
    qsa(".appmenu, .appmenu-field").forEach(ul => {
      if (ul === keep) return;
      if (keep && ul.contains(keep)) return;          // keep ancestors of keep
      if (keep && keep.contains(ul)) return;          // keep descendants of keep
      ul.style.display = "none";
      ul.removeAttribute("data-open");
    });
    qsa(".appmenu-trigger").forEach(btn => {
      const m = menuForTrigger(btn);
      const shouldStay =
        m === keep || (keep && (m && (m.contains(keep) || keep.contains(m))));
      btn.setAttribute("aria-expanded", shouldStay ? "true" : "false");
      btn.classList.toggle("is-open", !!shouldStay);
    });
  }

  // Open a specific trigger's menu
  function openMenu(trigger){
    const menu = menuForTrigger(trigger);
    if (!menu) return;
    // close others at same level
    const root = document.querySelector(".menubar");
    const sameLevelMenus = qsa(".appmenu, .appmenu-field", root).filter(ul => {
      // different branch = close
      return !(menu === ul || menu.contains(ul) || ul.contains(menu));
    });
    sameLevelMenus.forEach(ul => { ul.style.display = "none"; ul.removeAttribute("data-open"); });

    trigger.setAttribute("aria-expanded", "true");
    trigger.classList.add("is-open");
    menu.style.display = "block";
    menu.setAttribute("data-open", "true");
    ensureInViewport(menu);
  }

  // Toggle a trigger's menu
  function toggleMenu(trigger){
    const menu = menuForTrigger(trigger);
    if (!menu) return;
    const isOpen = menu.getAttribute("data-open") === "true" || menu.style.display === "block";
    if (isOpen){
      // Close this branch only
      menu.style.display = "none";
      menu.removeAttribute("data-open");
      trigger.setAttribute("aria-expanded", "false");
      trigger.classList.remove("is-open");
    } else {
      openMenu(trigger);
    }
  }

  // Slight nudge to keep dropdowns onscreen horizontally
  function ensureInViewport(menu){
    const r = menu.getBoundingClientRect();
    const pad = 8;
    if (r.right > window.innerWidth - pad){
      const shift = r.right - (window.innerWidth - pad);
      menu.style.left = (menu.offsetLeft - shift) + "px";
    }
    if (menu.classList.contains("appmenu-field")){
      // submenus open to the right; if overflowing, flip to left
      const rr = menu.getBoundingClientRect();
      if (rr.right > window.innerWidth - pad){
        menu.style.left = "auto";
        menu.style.right = "100%";
        menu.style.marginLeft = "0";
        menu.style.marginRight = "4px";
      } else {
        menu.style.right = "auto";
      }
    }
  }

  // ===== Mouse: clicks on triggers
  document.addEventListener("click", (e)=>{
    const btn = e.target.closest(".appmenu-trigger");
    if (btn){
      e.preventDefault();
      e.stopPropagation();
      toggleMenu(btn);
      return;
    }
    // Clicked outside any menu → close all
    if (!e.target.closest(".menubar")){
      closeAll();
    }
  });

  // ===== Hover for nested submenus (keeps style-only feel)
  // Open submenu when hovering its trigger; close when leaving its li
  qsa(".appmenu-nested").forEach(li=>{
    const trig = li.querySelector(".appmenu-trigger.nested");
    const sub  = li.querySelector(".appmenu-field");
    if (!trig || !sub) return;

    li.addEventListener("mouseenter", ()=>{
      // keep parent branch open
      trig.setAttribute("aria-expanded", "true");
      trig.classList.add("is-open");
      sub.style.display = "block";
      sub.setAttribute("data-open", "true");
      ensureInViewport(sub);
    });
    li.addEventListener("mouseleave", ()=>{
      sub.style.display = "none";
      sub.removeAttribute("data-open");
      trig.setAttribute("aria-expanded", "false");
      trig.classList.remove("is-open");
    });
  });

  // ===== Keyboard support
  // Open/close with Enter/Space; Escape closes all; Arrow navigation between top-level menus
  document.addEventListener("keydown", (e)=>{
    const active = document.activeElement;
    const isTrigger = active && active.classList && active.classList.contains("appmenu-trigger");

    // Escape → close all
    if (e.key === "Escape"){
      closeAll();
      return;
    }

    // Enter/Space on a trigger → toggle
    if (isTrigger && (e.key === "Enter" || e.key === " ")){
      e.preventDefault();
      toggleMenu(active);
      return;
    }

    // Arrow navigation between top-level triggers
    if (isTrigger && (e.key === "ArrowRight" || e.key === "ArrowLeft")){
      e.preventDefault();
      const top = active.closest(".menubar");
      const triggers = qsa(".appmenu-root > .appmenu-item > .appmenu-trigger", top);
      const idx = triggers.indexOf(active);
      if (idx !== -1){
        const nextIdx = e.key === "ArrowRight"
          ? (idx + 1) % triggers.length
          : (idx - 1 + triggers.length) % triggers.length;
        triggers[nextIdx].focus();
        // If a menu is already open, keep the bar “rolling” by opening the next one
        const anyOpen = qsa(".appmenu[data-open='true'], .appmenu-field[data-open='true']").length > 0;
        if (anyOpen){
          openMenu(triggers[nextIdx]);
        }
      }
      return;
    }

    // ArrowDown on a trigger → open its menu
    if (isTrigger && e.key === "ArrowDown"){
      e.preventDefault();
      openMenu(active);
      // Focus first item inside if you like (style-only right now we skip focusing)
      return;
    }
  });

  // Close on window resize (prevents odd positioning after layout changes)
  window.addEventListener("resize", closeAll);

  // Accessibility attributes (light touch)
  qsa(".appmenu-trigger").forEach(btn=>{
    btn.setAttribute("aria-haspopup", "true");
    btn.setAttribute("aria-expanded", "false");
  });

})();
</script>
<script id="feature-help-settings-popups">
(function(){
  // ===== helpers =====
  function $(id){ return document.getElementById(id); }
  function openOverlay(overlay){
    if (!overlay) return;
    overlay.style.display = "flex";
    overlay.setAttribute("data-open","true");
    overlay.removeAttribute("aria-hidden");

    // focus first focusable control in dialog
    const dlg = overlay.querySelector(".dialog");
    const focusable = dlg && dlg.querySelector(
      "button, [href], input, select, textarea, [tabindex]:not([tabindex='-1'])"
    );
    if (focusable) focusable.focus();

    // optional: prevent background scroll
    document.documentElement.style.overflow = "hidden";
  }
  function closeOverlay(overlay){
    if (!overlay) return;
    overlay.style.display = "none";
    overlay.removeAttribute("data-open");
    overlay.setAttribute("aria-hidden","true");
    // restore scroll when no overlays open
    if (document.querySelectorAll('.overlay[data-open="true"]').length === 0){
      document.documentElement.style.overflow = "";
    }
  }
  function bindOpen(btn, overlay){
    if (!btn || !overlay) return;
    btn.addEventListener("click", (e)=>{
      e.preventDefault();
      openOverlay(overlay);
    });
  }
  function bindClose(btn, overlay){
    if (!btn || !overlay) return;
    btn.addEventListener("click", (e)=>{
      e.preventDefault();
      closeOverlay(overlay);
    });
  }

  // ===== get elements =====
  const settingsBtn        = $("settingsBtn");
  const helpBtn            = $("helpBtn");
  const mnuHelp            = $("mnuHelp");
  const mnuAbout           = $("mnuAbout");

  const settingsOverlay    = $("settings-modal");
  const helpOverlay        = $("about-modal");       // “About / Help Modal” in your file
  const aboutInfoOverlay   = $("about-info-modal");  // “Software information” modal

  const settingsCloseBtn   = $("settingsCloseBtn");
  const aboutCloseBtn      = $("aboutCloseBtn");
  const aboutInfoCloseBtn  = $("aboutInfoCloseBtn");

  // ===== wire openers =====
  bindOpen(settingsBtn, settingsOverlay);
  bindOpen(helpBtn,     helpOverlay);      // toolbar help button → Help modal
  bindOpen(mnuHelp,     helpOverlay);      // menubar Help → Help modal
  bindOpen(mnuAbout,    aboutInfoOverlay); // menubar About → About/Info modal

  // ===== wire closers =====
  bindClose(settingsCloseBtn, settingsOverlay);
  bindClose(aboutCloseBtn,    helpOverlay);
  bindClose(aboutInfoCloseBtn,aboutInfoOverlay);

  // click outside dialog (on backdrop) closes
  [settingsOverlay, helpOverlay, aboutInfoOverlay].forEach(ov=>{
    if (!ov) return;
    ov.addEventListener("click", (e)=>{
      // close only if click is on the backdrop, not inside .dialog
      if (e.target === ov) closeOverlay(ov);
    });
  });

  // ESC closes the top-most open overlay
  document.addEventListener("keydown", (e)=>{
    if (e.key !== "Escape") return;
    const openOverlays = Array.from(document.querySelectorAll('.overlay[data-open="true"]'));
    if (!openOverlays.length) return;
    // last one in DOM order is "top" enough for our case
    closeOverlay(openOverlays[openOverlays.length - 1]);
  });

  // optional: close menus when a modal opens (if you’re using the menubar JS)
  document.addEventListener("click", (e)=>{
    const opener = e.target.closest("#settingsBtn, #helpBtn, #mnuHelp, #mnuAbout");
    if (opener){
      // if you used the menubar script earlier, this will close any open menus:
      document.querySelectorAll(".appmenu, .appmenu-field").forEach(m=> m.style.display="none");
      document.querySelectorAll(".appmenu-trigger").forEach(b=> { b.classList.remove("is-open"); b.setAttribute("aria-expanded","false"); });
    }
  });
})();
</script>
<!-- Duplicate line: always below + setting-aware string clear (no external deps) -->
<script id="feature-duplicate-line-hotkey">
(function(){
  const ta = document.getElementById('textArea');
  if (!ta) return;

  // -- setting: checkbox controls whether we clear the last field if it's a string
  const isClearLastEnabled = () => {
    const cb = document.getElementById('clearLastField');
    return !!(cb && cb.checked);
  };

  // Parse a single SQL tuple on this line.
  // Supports: leading spaces, (...) with suffix, strings in single quotes with '' and \' escapes.
  function parseSqlTupleLine(line){
    const leadingMatch = line.match(/^\s*/);
    const leading = leadingMatch ? leadingMatch[0] : "";
    const afterLead = line.slice(leading.length);

    const openRel = afterLead.indexOf("(");
    if (openRel === -1) return { ok:false };

    const openIdx = leading.length + openRel;
    const s = line;
    let i = openIdx + 1;
    let inStr = false;
    let cur = "";
    let fields = [];

    function push(){ fields.push(cur.trim()); cur=""; }

    for (; i < s.length; i++){
      const ch = s[i];

      if (inStr){
        if (ch === "\\"){ if (i+1 < s.length){ cur += ch + s[i+1]; i++; continue; } }
        if (ch === "'"){
          if (s[i+1] === "'"){ cur += "''"; i++; continue; } // doubled apostrophe
          cur += ch; inStr = false; continue;
        }
        cur += ch; continue;
      }

      if (ch === "'"){ inStr = true; cur += ch; continue; }
      if (ch === ","){ push(); continue; }
      if (ch === ")"){ push(); break; }
      cur += ch;
    }

    if (i >= s.length) return { ok:false };

    const closeIdx = i; // index of ')'
    const suffix = s.slice(closeIdx + 1);

    function reconstructed(newFields){
      return `${leading}(${newFields.join(", ")})${suffix}`;
    }

    return { ok:true, fields, reconstructed };
  }

  // Apply the “clear last if string” rule to the line (numbers unchanged)
  function clearLastFieldIfString(line){
    const p = parseSqlTupleLine(line);
    if (!p.ok || !p.fields.length) return line;

    const lastIdx = p.fields.length - 1;
    const last = String(p.fields[lastIdx]).trim();

    const isQuoted = last.startsWith("'") && last.endsWith("'");
    const isNumeric = /^[+-]?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?$/.test(last);

    if (isQuoted){
      p.fields[lastIdx] = "''";       // strings become empty ''
    } else if (isNumeric){
      // numbers: do nothing
    } else {
      // non-string, non-number: do nothing per your rule
    }
    return p.reconstructed(p.fields);
  }

  // Robust line/column from caret; returns start/end (end excludes newline) and afterLineBreak
  function lineInfo(text, pos){
    const start = text.lastIndexOf("\n", Math.max(0, pos - 1)) + 1;
    const nlIdx = text.indexOf("\n", start);
    const end = (nlIdx === -1 ? text.length : nlIdx);
    const afterLineBreak = (nlIdx === -1 ? end : nlIdx + 1);
    return { start, end, afterLineBreak };
  }

  function duplicateCurrentLine(){
    const text = ta.value;
    const caret = ta.selectionStart ?? 0;
    const { start, end, afterLineBreak } = lineInfo(text, caret);
    const srcLine = text.slice(start, end); // no trailing newline
    const col = caret - start;

    let dup = srcLine;
    if (isClearLastEnabled()){
      dup = clearLastFieldIfString(dup);
    }

    // Insert strictly AFTER the line's newline, so the duplicate is always on a new line below
    const before = text.slice(0, afterLineBreak);
    const after  = text.slice(afterLineBreak);
    const insertion = dup + "\n";

    ta.value = before + insertion + after;

    // Move caret to duplicate line, same column (clamped)
    const newLineStart = before.length;
    const newPos = newLineStart + Math.min(col, dup.length);
    ta.setSelectionRange(newPos, newPos);
    ta.focus();

    // Optional hooks if you have them:
    try { window.pushSnapshot?.(); } catch(_) {}
    try { window.updateRowsCountPill?.(); } catch(_) {}
  }

  // Hotkey matcher (use Ctrl+Shift+D reliably; still attempts Ctrl+D where allowed)
  function isDupHotkey(e){
    const k = (e.key || '').toLowerCase();
    if (k !== 'd') return false;
    if (e.ctrlKey && e.shiftKey && !e.altKey && !e.metaKey) return true; // Ctrl+Shift+D
    if (e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey)  return true; // Ctrl+D (attempt)
    if (e.ctrlKey && e.altKey && !e.shiftKey && !e.metaKey)   return true; // Ctrl+Alt+D (backup)
    if (e.metaKey && !e.ctrlKey && !e.shiftKey && !e.altKey)  return true; // ⌘+D (attempt)
    return false;
  }

  // Intercept early to beat browser defaults
  document.addEventListener('keydown', function(e){
    if (document.activeElement !== ta) return;
    if (!isDupHotkey(e)) return;

    e.preventDefault();
    e.stopPropagation();
    if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();

    duplicateCurrentLine();
  }, true);
})();
</script>
<script id="feature-tokenizer">
(() => {
  const ta = document.getElementById("textArea");
  if (!ta) return;

  const H = window.DupHelpers || {};
  const parseTuple = H.parseSqlTupleLine;
  if (typeof parseTuple !== "function") return;

  // ===== Settings getters (from settings-core) =====
  const settings = {
    get replaceAll(){ return !!(window.AppSettings && window.AppSettings.tokReplaceAll); },
    get style(){ return (window.AppSettings && window.AppSettings.tokStyle) || "alnum"; },
    get len(){
      const n = (window.AppSettings && window.AppSettings.tokLen) || 12;
      return Math.max(4, Math.min(128, n|0));
    }
  };

  // ===== String helpers =====
  function isQuoted(field){ const f = field.trim(); return f.startsWith("'") && f.endsWith("'"); }
  function isQuotedEmptyOrSpaces(field){
    if (!isQuoted(field)) return false;
    return unescapeSingleQuoted(field).trim().length === 0;
  }
  function isNumeric(field){
    return /^[+-]?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?$/.test(field.trim());
  }
  function unescapeSingleQuoted(f){
    // drop surrounding quotes then unescape: \' -> ' and '' -> '
    let s = f.trim();
    if (s.length >= 2 && s[0] === "'" && s[s.length-1] === "'") s = s.slice(1, -1);
    s = s.replace(/\\'/g, "'").replace(/''/g, "'");
    return s;
  }
  function escapeForSqlSingle(s){
    return String(s).replace(/'/g, "''");
  }

  // ===== Token generators =====
  function randi(n){ return Math.floor(Math.random()*n); }
  function genAlnum(len){
    const A = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let out=""; for (let i=0;i<len;i++) out += A[randi(A.length)];
    return out;
  }
  function genAlpha(len){
    const A = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    let out=""; for (let i=0;i<len;i++) out += A[randi(A.length)];
    return out;
  }
  function genUpper(len){
    const A = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    let out=""; for (let i=0;i<len;i++) out += A[randi(A.length)];
    return out;
  }
  function genLower(len){
    const A = "abcdefghijklmnopqrstuvwxyz";
    let out=""; for (let i=0;i<len;i++) out += A[randi(A.length)];
    return out;
  }
  function genUUIDv4(){
    const hex = "0123456789abcdef";
    const h = n => Array.from({length:n}, () => hex[randi(16)]).join("");
    return `${h(8)}-${h(4)}-4${h(3)}-${(8+randi(4)).toString(16)}${h(3)}-${h(12)}`;
  }
  function makeToken(style, len){
    switch(style){
      case "alpha": return genAlpha(len);
      case "upper": return genUpper(len);
      case "lower": return genLower(len);
      case "uuid":  return genUUIDv4();
      case "alnum":
      default:      return genAlnum(len);
    }
  }

  // ===== Build a set of ALL existing tokens in the doc (unescaped values) =====
  function collectExistingTokens(text){
    // Match every single-quoted string, including ones with \' and ''
    const re = /'([^'\\]|\\.|'')*'/g;
    const set = new Set();
    let m;
    while ((m = re.exec(text)) !== null){
      set.add(unescapeSingleQuoted(m[0]));
    }
    return set;
  }

  // Generate a token that does not exist in the Set; add it to the Set immediately.
  function generateUniqueToken(existing, style, len){
    const MAX_TRIES = 2000;
    let tries = 0;
    while (tries++ < MAX_TRIES){
      const t = makeToken(style, len);
      if (!existing.has(t)){
        existing.add(t);
        return t;
      }
    }
    // extremely unlikely; expand the space and try again a few times
    for (let extra = 1; extra <= 3; extra++){
      for (let i=0; i<MAX_TRIES; i++){
        const t = makeToken(style, len + extra);
        if (!existing.has(t)){
          existing.add(t);
          return t;
        }
      }
    }
    // last resort: UUIDv4
    let uu;
    do { uu = genUUIDv4(); } while (existing.has(uu));
    existing.add(uu);
    return uu;
  }

  // ===== Core action =====
  function fillTokensInDocument(){
    const style = settings.style;
    const len   = settings.len;
    const replaceAll = settings.replaceAll;

    // 1) Build a global set of tokens already present anywhere in the document
    const existing = collectExistingTokens(ta.value);

    // 2) Process line-by-line
    const lines = ta.value.split(/\r?\n/);
    let changed = false;

    for (let i = 0; i < lines.length; i++){
      const line = lines[i];
      const p = parseTuple(line);
      if (!p || !p.ok || !p.fields.length) continue;

      const lastIdx = p.fields.length - 1;
      const last = p.fields[lastIdx];

      // numeric → never touch
      if (isNumeric(last)) continue;

      const shouldFillEmpty = isQuotedEmptyOrSpaces(last);
      const shouldReplace   = replaceAll && isQuoted(last) && !shouldFillEmpty;

      if (!shouldFillEmpty && !shouldReplace) continue;

      const token = generateUniqueToken(existing, style, len);
      p.fields[lastIdx] = `'${escapeForSqlSingle(token)}'`;

      const rebuilt = p.reconstructed(p.fields);
      if (rebuilt !== line){
        lines[i] = rebuilt;
        changed = true;
      }
    }

    if (changed){
      const caret = ta.selectionStart;
      ta.value = lines.join("\n");
      const pos = Math.min(caret, ta.value.length);
      ta.setSelectionRange(pos, pos);
      try { window.pushSnapshot?.(); } catch {}
      try { window.updateRowsCountPill?.(); } catch {}
    }
  }

  // ===== Wire controls =====
  function bind(id){
    const el = document.getElementById(id);
    if (!el) return;
    if (el._tokWired) return;
    el._tokWired = true;
    el.addEventListener("click", (e)=>{ e.preventDefault(); fillTokensInDocument(); });
  }
  bind("tokenizeBtn");   // toolbar
  bind("mnuTokenizer");  // menu item (Tools → Tokenizer)

  // optional command
  window.runTokenizer = fillTokensInDocument;
})();
</script>
<script id="feature-copyboard-ctrl-i-fix">
/* Ctrl+I — Paste Copy Board items into the field under the caret, row-by-row
   to the end of the current set. Quote-aware ('' and \').
*/
(() => {
  const editor = document.getElementById('textArea');
  const board  = document.getElementById('board');
  if (!editor) return;

  // ===== Prefer your real helpers; fall back if missing =====
  const splitFieldsRobust = (tupleRaw) =>
    (typeof window.splitFieldsRobust === 'function') ? window.splitFieldsRobust(tupleRaw) : fallbackSplitFields(tupleRaw);

  const joinFields = (parts) =>
    (typeof window.joinFields === 'function') ? window.joinFields(parts) : `(${parts.join(', ')})`;

  const enumerateSets = (lines) =>
    (typeof window.enumerateSets === 'function') ? window.enumerateSets(lines) : fallbackEnumerateSets(lines);

  const countCommas3 = (line, tupleOpen, indexInLine) =>
    (typeof window.countCommasBeforeIndexRobust === 'function')
      ? window.countCommasBeforeIndexRobust(line, tupleOpen, indexInLine)    // ✅ correct 3-arg call
      : naiveCount(line, tupleOpen, indexInLine);

  const findAllTuplesInLineSmart =
    (typeof window.findAllTuplesInLineSmart === 'function') ? window.findAllTuplesInLineSmart : findTuplesOnLineFallback;

  const isQuoted = (s) => { const t = String(s).trim(); return t.startsWith("'") && t.endsWith("'"); };
  const escapeSQL1 = (v) => String(v).replace(/'/g, "''");

  // ----- Fallbacks -----
  function fallbackSplitFields(tupleRaw){
    const inner = String(tupleRaw).slice(1, -1);
    const parts = []; let buf = ''; let inStr = false;
    for (let i=0;i<inner.length;i++){
      const ch = inner[i];
      if (inStr){
        if (ch === '\\'){ if (i+1<inner.length){ buf+=ch+inner[++i]; continue; } }
        if (ch === "'"){ if (inner[i+1] === "'"){ buf+="''"; i++; } else { buf+=ch; inStr=false; } continue; }
        buf += ch; continue;
      }
      if (ch === "'"){ inStr=true; buf+=ch; continue; }
      if (ch === ','){ parts.push(buf.trim()); buf=''; continue; }
      buf += ch;
    }
    parts.push(buf.trim());
    return parts;
  }

  function fallbackEnumerateSets(lines){
    const sets=[]; let i=0;
    while(i<lines.length){
      while(i<lines.length && lines[i].trim()==='') i++;
      if(i>=lines.length) break;
      const start=i;
      while(i<lines.length && lines[i].trim()!=='') i++;
      sets.push({start, end:i});
    }
    return sets;
  }

  function naiveCount(line, tupleOpen, indexInLine){
    const start = Math.max(0, (tupleOpen|0) + 1);
    return line.slice(start, Math.max(start, indexInLine|0)).split(',').length - 1;
  }

  // Simple tuple finder when your smart one isn’t present
  function findTuplesOnLineFallback(line){
    const out=[]; let inStr=false; let depth=0; let open=-1;
    for (let i=0;i<line.length;i++){
      const ch=line[i];
      if (inStr){
        if (ch==='\\'){ i++; continue; }
        if (ch==="'"){ if (line[i+1]==="'"){ i++; } else { inStr=false; } }
        continue;
      }
      if (ch==="'"){ inStr=true; continue; }
      if (ch==='('){ if (depth===0) open=i; depth++; continue; }
      if (ch===')'){ if (depth>0 && --depth===0 && open>=0){ out.push({open, close:i+1, raw:line.slice(open, i+1)}); open=-1; } }
    }
    return out;
  }

  // Utilities
  function lineIndexAndCol(text, caret){
    const lineStart = text.lastIndexOf('\n', Math.max(0, caret-1)) + 1;
    const nl = text.indexOf('\n', lineStart);
    const lineEnd = (nl === -1 ? text.length : nl);
    const lineIndex = text.slice(0, lineStart).split('\n').length - 1;
    return { lineIndex, col: caret - lineStart };
  }

  function currentSetBounds(lines, curLineIndex){
    const sets = enumerateSets(lines);
    for (const s of sets){ if (curLineIndex >= s.start && curLineIndex < s.end) return s; }
    return { start: curLineIndex, end: curLineIndex };
  }

  function setNthFieldInFirstTupleOfLine(line, fieldIndex0, newValue){
    const tuples = findAllTuplesInLineSmart(line);
    if (!tuples.length) return line;
    const t = tuples[0];
    const before = line.slice(0, t.open);
    const after  = line.slice(t.close);
    const parts  = splitFieldsRobust(t.raw);
    if (fieldIndex0 < 0 || fieldIndex0 >= parts.length) return line;
    const target = parts[fieldIndex0];
    parts[fieldIndex0] = isQuoted(target) ? `'${escapeSQL1(newValue)}'` : String(newValue);
    return before + joinFields(parts) + after;
  }

  function itemsFromCopyBoard(){
    if (Array.isArray(window.collectedItems) && window.collectedItems.length) return window.collectedItems.slice();
    if (!board) return [];
    if (typeof window.tokenizeAuto === 'function') return window.tokenizeAuto(board.value);
    return board.value.replace(/\r/g,'').split('\n').map(s=>s.trim()).filter(Boolean);
  }

  function pasteItemsAtCaretField(){
    const doc = editor.value.replace(/\r/g,'');
    const caret = editor.selectionStart ?? 0;
    const { lineIndex, col } = lineIndexAndCol(doc, caret);
    const lines = doc.split('\n');

    const currentLine = lines[lineIndex] ?? '';
    const tuplesOnLine = findAllTuplesInLineSmart(currentLine);
    if (!tuplesOnLine.length) return;

    const tuple = tuplesOnLine.find(T => col >= T.open && col <= T.close) || tuplesOnLine[0];

    // ✅ Pass ALL THREE args (line, tuple.open, caret) into your robust counter.
    const indexInLine = Math.min(Math.max(col, tuple.open+1), Math.max(tuple.open+1, tuple.close-1));
    const fieldIndex0 = countCommas3(currentLine, tuple.open, indexInLine);

    const { start, end } = currentSetBounds(lines, lineIndex);
    const items = itemsFromCopyBoard();
    if (!items.length) return;

    let k = 0;
    for (let i = Math.max(start, lineIndex); i < end && k < items.length; i++){
      const row = lines[i];
      if (!row.trim()) continue;
      if (!findAllTuplesInLineSmart(row).length) continue;
      lines[i] = setNthFieldInFirstTupleOfLine(row, fieldIndex0, items[k++]);
    }

    editor.value = lines.join('\n');

    // keep caret near where you were
    if (lineIndex < end - 1){
      let targetLine = Math.min(end - 1, lineIndex + Math.max(1, items.length));
      targetLine = Math.min(targetLine, end - 1);
      const before = lines.slice(0, targetLine).join('\n');
      const pos = before.length + (targetLine>0 ? 1 : 0) + Math.min(col, (lines[targetLine]||'').length);
      editor.setSelectionRange(pos, pos);
    }

    try { window.pushSnapshot?.(); } catch {}
    try { window.updateRowsCountPill?.(); } catch {}
  }

  // Capture-phase handler to beat and silence the old ones
  editor.addEventListener('keydown', (e) => {
    const key = String(e.key).toLowerCase();
    if ((e.ctrlKey || e.metaKey) && key === 'i'){
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation?.();
      pasteItemsAtCaretField();
    }
  }, true);
})();
</script>
<script id="copy-board-paste-fix">
/* Ensures pasting into #board always becomes one-per-line (CSV-aware) */
(function () {
  const board = document.getElementById('board');
  const pill  = document.getElementById('countPill');
  if (!board) return;

  // CSV → items (supports "quoted, items" with "" escapes)
  function csvToItems(text){
    const lines = String(text).split(/\r?\n/);
    const items = [];
    for (const rawLine of lines){
      const s = rawLine;
      let buf = '';
      let inQ = false;
      for (let i = 0; i < s.length; i++){
        const ch = s[i];
        if (inQ){
          if (ch === '"'){
            if (s[i+1] === '"'){ buf += '"'; i++; continue; } // "" -> literal "
            inQ = false;                                       // end quote
            continue;
          }
          buf += ch;
        } else {
          if (ch === '"'){ inQ = true; continue; }
          if (ch === ','){ items.push(buf.trim()); buf = ''; continue; }
          buf += ch;
        }
      }
      items.push(buf.trim());
    }
    // Strip empties
    return items.filter(x => x.length > 0);
  }

  function updateCount(){
    if (!pill) return;
    const count = board.value.split(/\r?\n/).filter(x => x.trim().length > 0).length;
    pill.textContent = `Copy Board: ${count} items`;
  }

  // Strongest paste hook: capture phase + stopImmediatePropagation
  board.addEventListener('paste', (e) => {
    const dt   = e.clipboardData || window.clipboardData;
    const text = dt && dt.getData ? dt.getData('text') : '';
    if (!text) return; // let default run if nothing

    e.preventDefault();
    e.stopPropagation?.();
    e.stopImmediatePropagation?.();

    const items = csvToItems(text);

    // Insert where the selection is, keep surrounding text
    const selStart = board.selectionStart ?? board.value.length;
    const selEnd   = board.selectionEnd ?? selStart;
    const before   = board.value.slice(0, selStart);
    const after    = board.value.slice(selEnd);

    const needsNLBefore = before.length && !before.endsWith('\n');
    const needsNLAfter  = after.length && !after.startsWith('\n') && items.length;

    const insertion = (needsNLBefore ? '\n' : '') + items.join('\n') + (needsNLAfter ? '\n' : '');
    board.value = before + insertion + after;

    // Caret after inserted block
    const pos = (before + insertion).length;
    board.setSelectionRange(pos, pos);

    updateCount();
  }, true); // ← capture=true

  // If anything else mutates #board afterward, keep the pill right
  board.addEventListener('input', updateCount);
  updateCount();
})();
</script>
<script id="copy-board-dedupe-shuffle">
(() => {
  // Reuse what you already have if present
  const board   = document.getElementById('board');
  const pill    = document.getElementById('countPill');
  const $       = (id) => document.getElementById(id);

  // Read items from the live queue (preferred) or from the textarea
  function readItems() {
    if (Array.isArray(window.collectedItems) && window.collectedItems.length) {
      return window.collectedItems.slice();
    }
    const text = (board?.value || '').replace(/\r/g, '');
    return text.split('\n').map(s => s.trim()).filter(Boolean);
  }

  // Write items back to whichever source we’re using
  function writeItems(items) {
    if (Array.isArray(window.collectedItems)) {
      window.collectedItems.length = 0;
      window.collectedItems.push(...items);
      // If your app exposes this, keep UI in sync
      if (typeof window.updateBoardView === 'function') {
        window.updateBoardView();
      } else if (board) {
        board.value = items.join('\n');
      }
    } else if (board) {
      board.value = items.join('\n');
    }
    updatePill();
  }

  function updatePill() {
    if (!pill) return;
    const n = readItems().length;
    pill.textContent = `Copy Board: ${n} items`;
  }

  // ---------- Actions ----------
  function dedupeBoard() {
    const items = readItems();
    const seen = new Set();
    const out = [];
    for (const it of items) {
      if (seen.has(it)) continue;
      seen.add(it);
      out.push(it);
    }
    writeItems(out);
  }

  function shuffleBoard() {
    const items = readItems();
    // Fisher–Yates
    for (let i = items.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [items[i], items[j]] = [items[j], items[i]];
    }
    writeItems(items);
  }

  // ---------- Wire buttons (and optional menu items) ----------
  const dedupeBtn  = $('dedupeBtn');
  const shuffleBtn = $('shuffleBtn');

  if (dedupeBtn)  dedupeBtn.addEventListener('click', e => { e.preventDefault(); dedupeBoard(); });
  if (shuffleBtn) shuffleBtn.addEventListener('click', e => { e.preventDefault(); shuffleBoard(); });

  // Optional menu IDs (hook up if they exist)
  const mnuDedupe  = $('mnuDedupeBoard');
  const mnuShuffle = $('mnuShuffleBoard');
  if (mnuDedupe)  mnuDedupe.addEventListener('click',  e => { e.preventDefault(); dedupeBoard(); });
  if (mnuShuffle) mnuShuffle.addEventListener('click', e => { e.preventDefault(); shuffleBoard(); });

  // Keep pill correct if user types directly in the board
  if (board) board.addEventListener('input', updatePill);

  // Initial paint
  updatePill();
})();
</script>
<script id="ui-visibility-controls">
(() => {
  const BOARD_VIS_KEY  = 'sqlFieldDump.boardCollapsed';
  const UI_HIDDEN_KEY  = 'sqlFieldDump.interfaceHidden';

  const $ = (id) => document.getElementById(id);

  const wrap   = $('mainWrap');
  const panel  = $('leftPanel');
  const btn    = $('toggleBoardBtn');
  const showBtn= $('showControlsBtn');

  // ---- Copy Board visibility ----
  function applyBoardVisibility(collapsed) {
    if (!wrap || !panel) return;
    if (collapsed) {
      wrap.classList.add('board-hidden');
      panel.classList.add('hidden');
      if (btn) btn.textContent = 'Show Copy Board';
    } else {
      wrap.classList.remove('board-hidden');
      panel.classList.remove('hidden');
      if (btn) btn.textContent = 'Hide Copy Board';
    }
  }
  function toggleBoard() {
    const next = !(localStorage.getItem(BOARD_VIS_KEY) === 'true');
    localStorage.setItem(BOARD_VIS_KEY, String(next));
    applyBoardVisibility(next);
  }
  (function initBoard(){ applyBoardVisibility(localStorage.getItem(BOARD_VIS_KEY) === 'true'); })();

  // ---- Interface visibility (Ctrl+S) ----
  function applyInterfaceHidden(hidden){
    document.body.classList.toggle('interface-hidden', !!hidden);
    localStorage.setItem(UI_HIDDEN_KEY, hidden ? 'true' : 'false');
    // Safety button becomes visible via CSS when interface-hidden
    if (showBtn) showBtn.style.display = hidden ? 'inline-block' : 'none';
  }
  function toggleInterfaceHidden(){
    const next = !(localStorage.getItem(UI_HIDDEN_KEY) === 'true');
    applyInterfaceHidden(next);
  }
  (function initUIHidden(){ applyInterfaceHidden(localStorage.getItem(UI_HIDDEN_KEY) === 'true'); })();

  // ---- Wire buttons / menu items ----
  if (btn && !btn._wired){ btn._wired = true; btn.addEventListener('click', (e)=>{ e.preventDefault(); toggleBoard(); }); }
  const mnuToggleBoard = $('mnuToggleBoard');
  if (mnuToggleBoard && !mnuToggleBoard._wired){
    mnuToggleBoard._wired = true;
    mnuToggleBoard.addEventListener('click', (e)=>{ e.preventDefault(); toggleBoard(); });
  }

  const mnuToggleUI = $('mnuToggleUI');
  if (mnuToggleUI && !mnuToggleUI._wired){
    mnuToggleUI._wired = true;
    mnuToggleUI.addEventListener('click', (e)=>{ e.preventDefault(); toggleInterfaceHidden(); });
  }

  if (showBtn && !showBtn._wired){
    showBtn._wired = true;
    showBtn.addEventListener('click', (e)=>{ e.preventDefault(); applyInterfaceHidden(false); });
  }

  // ---- Keyboard: Ctrl+S anywhere ----
  document.addEventListener('keydown', (e) => {
    if ((e.ctrlKey || e.metaKey) && String(e.key).toLowerCase() === 's'){
      e.preventDefault();
      e.stopPropagation();
      toggleInterfaceHidden();
    }
  }, true); // capture to beat browser "save" on some platforms
})();
</script>
<script id="file-new-action">
(() => {
  const btnNew    = document.getElementById('mnuNewDoc');       // File ▸ New
  const editor    = window.textArea || document.getElementById('textArea');
  const boardArea = document.getElementById('board');

  if (!btnNew || !editor) return;

  // small helper to close any open menus/popups if your app exposes it
  const closeAll = () => { try { window.closeAllMenus?.(); } catch(_) {} };

  function clearCopyBoard() {
    if (Array.isArray(window.collectedItems)) {
      window.collectedItems.length = 0;
    }
    if (boardArea) boardArea.value = '';
    // keep the pill and UI in sync, using your existing hooks if present
    try { window.updateBoardView?.(); } catch(_) {}
    try { window.updateRowsCountPill?.(); } catch(_) {}
  }

  function doNew() {
    // clear editor
    editor.value = '';
    clearCopyBoard();

    // snapshot + any other app updates you keep
    try { window.pushSnapshot?.(); } catch(_) {}
    try { window.updateRowsCountPill?.(); } catch(_) {}
  }

  btnNew.addEventListener('click', () => {
    closeAll();
    // same UX as your previous file: confirm() gate before clearing
    // “editor + Copy Board” so counts don’t get out of sync
    if (!confirm('Clear the editor and the Copy Board?')) return;
    doNew();
  });
})();
</script>
<script id="file-copyboard-actions">
(() => {
  const board = document.getElementById('board');
  const pill  = document.getElementById('countPill');
  const mnuImport = document.getElementById('mnuImportBoard');
  const mnuClear  = document.getElementById('mnuClearBoard');

  if (!board || (!mnuImport && !mnuClear)) return;

  // --- CSV → items (handles "quoted, items" with "" escapes) ---
  function csvToItems(text){
    const lines = String(text).split(/\r?\n/);
    const items = [];
    for (const rawLine of lines){
      const s = rawLine;
      let buf = '';
      let inQ = false;
      for (let i = 0; i < s.length; i++){
        const ch = s[i];
        if (inQ){
          if (ch === '"'){
            if (s[i+1] === '"'){ buf += '"'; i++; continue; } // "" -> literal "
            inQ = false;                                      // end quote
            continue;
          }
          buf += ch;
        } else {
          if (ch === '"'){ inQ = true; continue; }
          if (ch === ','){ items.push(buf.trim()); buf = ''; continue; }
          buf += ch;
        }
      }
      items.push(buf.trim());
    }
    return items.filter(x => x.length > 0);
  }

  // --- Helpers to read/write board state ---
  function writeItemsToBoard(items){
    if (Array.isArray(window.collectedItems)){
      window.collectedItems.length = 0;
      window.collectedItems.push(...items);
    }
    if (board) board.value = items.join('\n');

    if (typeof window.updateBoardView === 'function') {
      window.updateBoardView();
    }
    updatePill();
  }

  function updatePill(){
    if (!pill) return;
    const n = (board.value.replace(/\r/g,'').split('\n').filter(x => x.trim().length > 0)).length;
    pill.textContent = `Copy Board: ${n} items`;
  }

  // --- Actions ---
  async function importFromClipboard(){
    try{
      const text = await navigator.clipboard.readText();
      if (!text) return;

      if (typeof window.pushItemsAuto === 'function') {
        // Your app’s smart importer (handles CSV/lines and quotes)
        window.pushItemsAuto(text);
        if (typeof window.updateBoardView === 'function') window.updateBoardView();
        updatePill();
      } else {
        // Fallback: CSV → one-per-line
        const items = csvToItems(text);
        writeItemsToBoard(items);
      }
    } catch {
      alert('Clipboard read failed. Make sure the page has clipboard permission.');
    }
  }

  function clearCopyBoardConfirmed(){
    if (!confirm('Clear the Copy Board?')) return;

    if (Array.isArray(window.collectedItems)) {
      window.collectedItems.length = 0;
    }
    board.value = '';
    if (typeof window.updateBoardView === 'function') window.updateBoardView();
    updatePill();
  }

  // --- Wire menu items ---
  if (mnuImport && !mnuImport._wired){
    mnuImport._wired = true;
    mnuImport.addEventListener('click', (e)=>{ e.preventDefault(); importFromClipboard(); });
  }
  if (mnuClear && !mnuClear._wired){
    mnuClear._wired = true;
    mnuClear.addEventListener('click', (e)=>{ e.preventDefault(); clearCopyBoardConfirmed(); });
  }

  // Keep pill accurate if user edits board manually
  board.addEventListener('input', updatePill);

  // Initial paint
  updatePill();
})();
</script>
<script id="feature-copyboard-ctrl-b">
(() => {
  const editor = document.getElementById('textArea');
  const board  = document.getElementById('board');
  const pill   = document.getElementById('countPill');
  if (!editor) return;

  // Append items (array of strings) to Copy Board and keep pill in sync.
  function appendToCopyBoard(items){
    if (!items || !items.length) return;

    // Prefer your array model if present
    if (Array.isArray(window.collectedItems)) {
      for (const it of items) window.collectedItems.push(it);
      if (typeof window.updateBoardView === 'function') {
        window.updateBoardView();
      } else if (board) {
        // Fallback to textarea rendering
        const cur = (board.value ?? '').replace(/\r/g, '');
        const needsNL = cur.length && !cur.endsWith('\n');
        board.value = cur + (needsNL ? '\n' : '') + items.join('\n');
      }
    } else if (board) {
      const cur = (board.value ?? '').replace(/\r/g, '');
      const needsNL = cur.length && !cur.endsWith('\n');
      board.value = cur + (needsNL ? '\n' : '') + items.join('\n');
    }

    // Update pill count
    try {
      const count = Array.isArray(window.collectedItems)
        ? window.collectedItems.filter(s => String(s).trim().length > 0).length
        : ((board?.value ?? '').replace(/\r/g,'').split('\n').filter(s => s.trim().length>0).length);
      if (pill) pill.textContent = `Copy Board: ${count} items`;
    } catch {}
  }

  // Turn current selection into items: keep commas, split only on newlines.
  function selectionToItems(){
    const start = editor.selectionStart ?? 0;
    const end   = editor.selectionEnd ?? 0;
    const sel   = editor.value.slice(start, end);
    if (!sel) return [];
    return sel.replace(/\r/g,'')
              .split('\n')
              .map(s => s.trim())
              .filter(Boolean);
  }

  // Remove selection from editor (to match “removes it from editor” behavior).
  function removeSelectionFromEditor(){
    const start = editor.selectionStart ?? 0;
    const end   = editor.selectionEnd ?? 0;
    if (start === end) return;
    const before = editor.value.slice(0, start);
    const after  = editor.value.slice(end);
    editor.value = before + after;
    // Place caret where the selection began
    editor.setSelectionRange(start, start);
  }

  // Hotkey: Ctrl/⌘ + B — collect selection → Copy Board, remove from editor
  document.addEventListener('keydown', (e) => {
    const key = String(e.key).toLowerCase();
    const isHotkey = key === 'b' && (e.ctrlKey || e.metaKey) && !e.shiftKey && !e.altKey;
    if (!isHotkey) return;
    if (document.activeElement !== editor) return;

    e.preventDefault();
    e.stopPropagation();
    if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();

    const items = selectionToItems();
    if (!items.length) return;
    appendToCopyBoard(items);
    removeSelectionFromEditor();

    // Keep any UI bits in sync
    try { window.pushSnapshot?.(); } catch {}
    try { window.updateRowsCountPill?.(); } catch {}
  }, true); // capture: try to beat browser/editor defaults
})();
</script>
<script id="tools-math">
(() => {
  // ---------- Safe element lookups & fallbacks ----------
  const ta =
    document.getElementById('textArea') ||
    document.querySelector('textarea#textArea, textarea.editor, textarea[name="textArea"], textarea');

  const mathModal =
    document.getElementById('math-modal') ||
    document.querySelector('#math-modal, .math-modal');

  const openBtn =
    document.getElementById('mathButton') ||
    document.querySelector('#mathButton, [data-open="math"]');

  const mnuMath =
    document.getElementById('mnuMath') ||
    document.querySelector('#mnuMath, [data-menu="math"]');

  const closeBtn =
    document.getElementById('mathCloseBtn') ||
    document.querySelector('#mathCloseBtn, [data-close="math"]');

  const rowInter =
    document.getElementById('interfieldRow') ||
    document.querySelector('#interfieldRow, [data-row="interfield"]');

  const rowField =
    document.getElementById('fieldRow') ||
    document.querySelector('#fieldRow, [data-row="field"]');

  const rowFF =
    document.getElementById('fieldFieldRow') ||
    document.querySelector('#fieldFieldRow, [data-row="fieldfield"]');

  const applyInterBtn =
    document.getElementById('applyInterfieldBtn') ||
    document.querySelector('#applyInterfieldBtn, [data-action="apply-interfield"]');

  const applyFieldBtn =
    document.getElementById('applyFieldBtn') ||
    document.querySelector('#applyFieldBtn, [data-action="apply-field"]');

  const applyFFBtn =
    document.getElementById('applyFieldFieldBtn') ||
    document.querySelector('#applyFieldFieldBtn, [data-action="apply-fieldfield"]');

  const scopeSet =
    document.getElementById('mathScopeSet') ||
    document.querySelector('#mathScopeSet, [data-scope="set"]');

  const scopeDoc =
    document.getElementById('mathScopeDoc') ||
    document.querySelector('#mathScopeDoc, [data-scope="doc"]');

  if (!ta || !mathModal || !rowInter || !rowField || !rowFF) return;

  // ---------- State cache so values survive rebuilds ----------
  const mathUIState = {
    inter_target: '1', inter_num: '1', inter_op: '+', inter_source: '1', inter_flip: false,
    fld_target: '1',  fld_left: '1',  fld_op: '+',  fld_num: '1',  fld_flip: false,
    ff_target: '1',   ff_a: '1',       ff_op: '+',   ff_b: '1'
  };
  function saveStateFromDOM() {
    [
      'inter_target','inter_num','inter_op','inter_source',
      'fld_target','fld_left','fld_op','fld_num',
      'ff_target','ff_a','ff_op','ff_b'
    ].forEach(id => { const el = document.getElementById(id); if (el) mathUIState[id] = String(el.value); });
    const iFlip = document.getElementById('inter_flip')?.querySelector('input');
    const fFlip = document.getElementById('fld_flip')?.querySelector('input');
    if (iFlip) mathUIState.inter_flip = !!iFlip.checked;
    if (fFlip) mathUIState.fld_flip   = !!fFlip.checked;
  }

  // ---------- Scope exclusivity (checkboxes behave like radios) ----------
  function wireScopeExclusivity(){
    if (!scopeSet || !scopeDoc) return;
    const ensureDefault = () => {
      if (!scopeSet.checked && !scopeDoc.checked) scopeSet.checked = true;
    };
    scopeSet.addEventListener('change', () => {
      if (scopeSet.checked) scopeDoc.checked = false;
      ensureDefault();
    });
    scopeDoc.addEventListener('change', () => {
      if (scopeDoc.checked) scopeSet.checked = false;
      ensureDefault();
    });
    ensureDefault();
  }

  // ---------- Tuple parsing (robust to quotes/escapes) ----------
  // Find the FIRST tuple "( ... )" in a line; returns {open, close, raw} inclusive of parens
  function findFirstTupleInLine(line) {
    const n = line.length;
    let i = line.indexOf('(');
    if (i === -1) return null;

    let depth = 0;
    let inSingle = false; // inside '...'
    for (let pos = i; pos < n; pos++) {
      const ch = line[pos];

      if (inSingle) {
        if (ch === "'") {
          // Handle doubled apostrophe '' and backslash-escaped \'
          const next = line[pos + 1];
          if (next === "'") { pos++; continue; }        // treat '' as escaped quote
          // If previous was backslash, we already skipped, but \'-style doesn't require special here
          inSingle = false;                              // end quote
        } else if (ch === '\\') {
          // skip escaped char
          pos++;
        }
        continue;
      }

      if (ch === "'") {
        inSingle = true;
        continue;
      }
      if (ch === '(') { depth++; continue; }
      if (ch === ')') {
        depth--;
        if (depth === 0) {
          const open = i;
          const close = pos + 1; // slice end is exclusive
          return { open, close, raw: line.slice(open, close) };
        }
      }
    }
    return null; // unbalanced
  }

  // Split fields at top-level commas, respecting single quotes + escapes
  function splitFieldsRobust(rawTuple) {
    // Expect "( ... )"
    let s = rawTuple.trim();
    if (s.startsWith('(') && s.endsWith(')')) s = s.slice(1, -1);

    const parts = [];
    let buf = '';
    let inSingle = false;

    for (let i = 0; i < s.length; i++) {
      const ch = s[i];
      if (inSingle) {
        buf += ch;
        if (ch === "'") {
          const next = s[i + 1];
          if (next === "'") { // doubled apostrophe
            buf += next; i++; continue;
          }
          inSingle = false; // close the quote
        } else if (ch === '\\') {
          const next = s[i + 1];
          if (next != null) { buf += next; i++; }
        }
        continue;
      }
      if (ch === "'") { inSingle = true; buf += ch; continue; }
      if (ch === ',') { parts.push(buf.trim()); buf = ''; continue; }
      buf += ch;
    }
    if (buf.length) parts.push(buf.trim());
    return parts;
  }

  function joinFields(parts) {
    return '(' + parts.join(', ') + ')';
  }

  // ---------- Number helpers ----------
  const isQuoted = (s)=> { const t = String(s).trim(); return t.startsWith("'") && t.endsWith("'"); };
  function parseNumField(f){
    const raw = String(f).trim();
    let core = raw;
    if (isQuoted(raw)) {
      core = raw.slice(1,-1).replace(/\\'/g,"'").replace(/''/g,"'");
    }
    const n = Number(core);
    return Number.isFinite(n) ? n : null;
  }
  function formatWithPreservedQuoting(example, value){
    if (isQuoted(example)) return `'${String(value).replace(/'/g,"''")}'`;
    return String(value);
  }
  function calc(a, op, b){
    switch(op){
      case '+': return a + b;
      case '-': return a - b;
      case '*': return a * b;
      case '/': return b === 0 ? NaN : a / b;
    }
    return NaN;
  }

  // ---------- Editor & scope ----------
  function getEditorLines(){ return ta.value.split(/\r?\n/); }
  function setEditorLines(lines){ ta.value = lines.join('\n'); }

  // “Set” = non-empty paragraph block
  function enumerateSets(lines){
    const sets=[]; let i=0;
    while(i<lines.length){
      while(i<lines.length && lines[i].trim()==='') i++;
      if(i>=lines.length) break;
      const start=i;
      while(i<lines.length && lines[i].trim()!=='') i++;
      sets.push({start,end:i});
    }
    return sets;
  }
  function caretSet(lines){
    const caret = ta.selectionStart || 0;
    const before = ta.value.slice(0, caret);
    const lineIdx = (before.match(/\n/g)||[]).length;
    const sets = enumerateSets(lines);
    for (const s of sets){ if (lineIdx >= s.start && lineIdx < s.end) return s; }
    return { start: Math.max(0, lineIdx), end: Math.max(0, lineIdx+1) };
  }
  function selectedRanges(){
    const lines = getEditorLines();
    const ranges = [];
    const cur = caretSet(lines);
    if (scopeSet?.checked) ranges.push(cur);
    if (scopeDoc?.checked){ for (const s of enumerateSets(lines)) ranges.push(s); }
    if (!ranges.length) ranges.push(cur);
    return { lines, ranges };
  }

  // Apply a mutator over FIRST tuple in each line within the chosen ranges
  function applyOverRanges(mutator){
    const { lines, ranges } = selectedRanges();
    let changed = false;

    for (const {start,end} of ranges){
      for (let li=start; li<end; li++){
        const line = lines[li];
        const t = findFirstTupleInLine(line);
        if (!t) continue;

        const before = line.slice(0, t.open);
        const after  = line.slice(t.close);
        const parts  = splitFieldsRobust(t.raw);

        const newParts = mutator(parts);
        if (!newParts) continue;

        const rebuilt = before + joinFields(newParts) + after;
        if (rebuilt !== line){
          lines[li] = rebuilt;
          changed = true;
        }
      }
    }

    if (changed) {
      setEditorLines(lines);
      try { window.pushSnapshot?.(); } catch {}
      try { window.updateRowsCountPill?.(); } catch {}
    }
  }

  // ---------- Inputs (no auto-reset; steppers work) ----------
  function mkFieldNumber(id, value='1'){
    const inp = document.createElement('input');
    inp.type = 'number'; inp.id = id; inp.min = '1'; inp.step = '1'; inp.value = String(value);
    inp.className = 'math-num';
    return inp;
  }
  function mkOpSelect(id, value='+'){
    const sel = document.createElement('select'); sel.id=id; sel.className='math-op';
    ['+','-','*','/'].forEach(op=>{
      const o=document.createElement('option'); o.value=op; o.textContent=op; if (op===value) o.selected=true;
      sel.appendChild(o);
    });
    return sel;
  }
  function mkNum(id,val='1'){
    const inp=document.createElement('input'); inp.type='number'; inp.id=id; inp.value=String(val); inp.step='any'; inp.className='math-num';
    return inp;
  }
  function mkChk(id,label,checked=false){
    const w=document.createElement('label'); w.className='math-chk';
    const c=document.createElement('input'); c.type='checkbox'; c.id=id; c.checked = !!checked;
    w.appendChild(c); w.appendChild(document.createTextNode(' '+label)); return w;
  }

  // ---------- Build rows (restore state) ----------
  function buildUI(){
    saveStateFromDOM();

    rowInter.innerHTML = '';
    rowField.innerHTML = '';
    rowFF.innerHTML    = '';

    // Interfield: Target = Number (op) Source · Flip
    {
      const target = mkFieldNumber('inter_target', mathUIState.inter_target);
      const num    = mkNum('inter_num',        mathUIState.inter_num);
      const op     = mkOpSelect('inter_op',    mathUIState.inter_op);
      const source = mkFieldNumber('inter_source', mathUIState.inter_source);
      const flip   = mkChk('inter_flip', 'Flip', mathUIState.inter_flip);

      rowInter.append(
        document.createTextNode('Target field'), target,
        document.createTextNode('Number'), num,
        op,
        document.createTextNode('Source field'), source,
        flip
      );
    }

    // Field math: Target = Field (op) Number · Flip
    {
      const target = mkFieldNumber('fld_target', mathUIState.fld_target);
      const left   = mkFieldNumber('fld_left',   mathUIState.fld_left);
      const op     = mkOpSelect('fld_op',       mathUIState.fld_op);
      const num    = mkNum('fld_num',           mathUIState.fld_num);
      const flip   = mkChk('fld_flip', 'Flip',  mathUIState.fld_flip);

      rowField.append(
        document.createTextNode('Target field'), target,
        document.createTextNode('Field'), left,
        op,
        document.createTextNode('Number'), num,
        flip
      );
    }

    // Field A vs Field B: Target = Field A (op) Field B
    {
      const target = mkFieldNumber('ff_target', mathUIState.ff_target);
      const a      = mkFieldNumber('ff_a',      mathUIState.ff_a);
      const op     = mkOpSelect('ff_op',        mathUIState.ff_op);
      const b      = mkFieldNumber('ff_b',      mathUIState.ff_b);

      rowFF.append(
        document.createTextNode('Target field'), target,
        document.createTextNode('Field A'), a,
        op,
        document.createTextNode('Field B'), b
      );
    }
  }

  // ---------- Utility ----------
  function toInt1(val, fallback=1){
    const n = Math.floor(Number(val));
    return Number.isFinite(n) && n>=1 ? n : fallback;
  }

  // ---------- Math apply (now definitely mutates the document) ----------
  // 1) Interfield — Target = Number (op) Source [flip: Source (op) Number]
  function applyInterfield(){
    saveStateFromDOM();
    const target1 = toInt1(mathUIState.inter_target);
    const num     = Number(mathUIState.inter_num);
    const op      = mathUIState.inter_op || '+';
    const source1 = toInt1(mathUIState.inter_source);
    const flip    = !!mathUIState.inter_flip;
    const ti = target1 - 1, si = source1 - 1;

    applyOverRanges((parts)=>{
      if (ti<0 || si<0 || ti>=parts.length || si>=parts.length) return null;
      const sN = parseNumField(parts[si]);
      if (sN === null || !Number.isFinite(num)) return null;

      const out = parts.slice();
      const targetWasQuoted = isQuoted(parts[ti]);
      const result = flip ? calc(sN, op, num) : calc(num, op, sN);
      if (!Number.isFinite(result)) return null;

      out[ti] = formatWithPreservedQuoting(targetWasQuoted ? "''" : '0', result);
      return out;
    });
  }

  // 2) Field math — Target = Field (op) Number [flip: Number (op) Field]
  function applyFieldMath(){
    saveStateFromDOM();
    const target1 = toInt1(mathUIState.fld_target);
    const left1   = toInt1(mathUIState.fld_left);
    const op      = mathUIState.fld_op || '+';
    const num     = Number(mathUIState.fld_num);
    const flip    = !!mathUIState.fld_flip;
    const ti = target1 - 1, li = left1 - 1;

    applyOverRanges((parts)=>{
      if (ti<0 || li<0 || ti>=parts.length || li>=parts.length) return null;
      const fN = parseNumField(parts[li]);
      if (fN === null || !Number.isFinite(num)) return null;

      const out = parts.slice();
      const targetWasQuoted = isQuoted(parts[ti]);
      const result = flip ? calc(num, op, fN) : calc(fN, op, num);
      if (!Number.isFinite(result)) return null;

      out[ti] = formatWithPreservedQuoting(targetWasQuoted ? "''" : '0', result);
      return out;
    });
  }

  // 3) Field A vs Field B — Target = A (op) B
  function applyFieldField(){
    saveStateFromDOM();
    const target1 = toInt1(mathUIState.ff_target);
    const a1      = toInt1(mathUIState.ff_a);
    const b1      = toInt1(mathUIState.ff_b);
    const op      = mathUIState.ff_op || '+';
    const ti = target1 - 1, ai = a1 - 1, bi = b1 - 1;

    applyOverRanges((parts)=>{
      if (ti<0 || ai<0 || bi<0 || ti>=parts.length || ai>=parts.length || bi>=parts.length) return null;
      const aN = parseNumField(parts[ai]);
      const bN = parseNumField(parts[bi]);
      if (aN === null || bN === null) return null;

      const out = parts.slice();
      const targetWasQuoted = isQuoted(parts[ti]);
      const result = calc(aN, op, bN);
      if (!Number.isFinite(result)) return null;

      out[ti] = formatWithPreservedQuoting(targetWasQuoted ? "''" : '0', result);
      return out;
    });
  }

  // ---------- Modal open/close ----------
  function openModal(){ wireScopeExclusivity(); buildUI(); mathModal.style.display = 'flex'; }
  function closeModal(){ saveStateFromDOM(); mathModal.style.display = 'none'; }

  // ---------- Wire buttons (with defensive fallbacks) ----------
  function wireOnce(el, evt, fn){ if (!el) return; if (el._wired) return; el._wired = true; el.addEventListener(evt, fn); }

  wireOnce(openBtn, 'click', (e)=>{ e.preventDefault(); openModal(); });
  wireOnce(mnuMath, 'click', (e)=>{ e.preventDefault(); openModal(); });
  wireOnce(closeBtn,'click', (e)=>{ e.preventDefault(); closeModal(); });

  wireOnce(applyInterBtn, 'click', (e)=>{ e.preventDefault(); applyInterfield(); });
  wireOnce(applyFieldBtn, 'click', (e)=>{ e.preventDefault(); applyFieldMath(); });
  wireOnce(applyFFBtn,    'click', (e)=>{ e.preventDefault(); applyFieldField(); });

})();
</script>
<script id="feature-add-field">
(() => {
  const $ = (id) => document.getElementById(id);

  // UI bits
  const editor          = $('textArea');
  const modal           = $('add-field-modal');     // Add Field modal
  const mnuAdd          = $('mnuFieldAdd');         // Tools → Field → Add Field
  const btnAddToolbar   = $('addFieldBtn');         // Toolbar "Add Field"
  const btnApply        = $('addFieldApplyBtn');
  const btnCancel       = $('addFieldCancelBtn');
  const inputAfter      = $('addAfterInput');
  const typeRadios      = () => [...document.querySelectorAll('input[name="newFieldType"]')];

  if (!editor || !modal || !btnApply || !btnCancel) return;

  // Reuse your overlay helpers if available (from feature-help-settings-popups)
  const openOverlay  = window.openOverlay  || ((ov)=>{ ov.style.display='flex'; ov.setAttribute('data-open','true'); });
  const closeOverlay = window.closeOverlay || ((ov)=>{ ov.style.display='none'; ov.removeAttribute('data-open'); });

  // === Tuple parsing (use your robust helpers if present) ===
  // We rely on DupHelpers.parseSqlTupleLine which handles '' and \' correctly and returns a reconstructor.
  const H = (window.DupHelpers || {});
  const parseTuple = H.parseSqlTupleLine;

  // Insert a new field into an array of fields at 1-based position `after`
  // where `after = 0` means insert at the beginning.
  function insertFieldArray(fields, after, kind){
    const idx = Math.max(0, Math.min(fields.length, after)); // clamp
    const val = (kind === 'number') ? '0' : "''";
    const out = fields.slice();
    out.splice(idx, 0, val);
    return out;
  }

  function applyAddFieldAcrossDocument(after, kind){
    const text = editor.value;
    const lines = text.split(/\r?\n/);
    let changed = false;

    for (let i = 0; i < lines.length; i++){
      const line = lines[i];
      const parsed = parseTuple ? parseTuple(line) : null;
      if (!parsed || !parsed.ok) continue;

      // parsed.fields is an array of the raw field tokens (including quotes where present)
      const newFields = insertFieldArray(parsed.fields, after, kind);
      const newLine = parsed.reconstructed(newFields);

      if (newLine !== line){
        lines[i] = newLine;
        changed = true;
      }
    }

    if (changed){
      editor.value = lines.join('\n');
      try { window.pushSnapshot?.(); } catch {}      // keep your undo/redo happy
      try { window.updateRowsCountPill?.(); } catch {} // keep UI counters up-to-date
    }
    return changed;
  }

  // === Wire openers ===
  function openModalAndFocus(){
    // default sensible focus
    openOverlay(modal);
    // Focus insert-after input
    setTimeout(() => { inputAfter?.focus(); inputAfter?.select?.(); }, 0);
  }

  if (mnuAdd && !mnuAdd._wired){
    mnuAdd._wired = true;
    mnuAdd.addEventListener('click', (e)=>{ e.preventDefault(); openModalAndFocus(); });
  }
  if (btnAddToolbar && !btnAddToolbar._wired){
    btnAddToolbar._wired = true;
    btnAddToolbar.addEventListener('click', (e)=>{ e.preventDefault(); openModalAndFocus(); });
  }

  // === Wire cancel/close ===
  if (btnCancel && !btnCancel._wired){
    btnCancel._wired = true;
    btnCancel.addEventListener('click', (e)=>{ e.preventDefault(); closeOverlay(modal); });
  }
  // click outside dialog to close
  if (!modal._backdropWired){
    modal._backdropWired = true;
    modal.addEventListener('click', (e)=>{ if (e.target === modal) closeOverlay(modal); });
  }
  // ESC to close if top-most
  if (!modal._escWired){
    modal._escWired = true;
    document.addEventListener('keydown', (e)=>{
      if (e.key !== 'Escape') return;
      const openTop = Array.from(document.querySelectorAll('.overlay[data-open="true"]')).pop();
      if (openTop === modal) closeOverlay(modal);
    });
  }

  // === Wire Apply ===
  if (btnApply && !btnApply._wired){
    btnApply._wired = true;
    btnApply.addEventListener('click', (e)=>{
      e.preventDefault();

      const after = parseInt(inputAfter?.value ?? '0', 10);
      const kind = (typeRadios().find(r => r.checked)?.value) || 'number';

      if (!Number.isFinite(after) || after < 0){
        alert('Insert-after must be 0 or greater (0 inserts at the beginning).');
        inputAfter?.focus();
        return;
      }

      const changed = applyAddFieldAcrossDocument(after, kind);
      if (!changed){
        // Optional UX: let user know nothing matched / no tuples found
        // but keep this quiet to avoid naggy toasts.
        // alert('No tuples were changed.');
      }
      closeOverlay(modal);
      editor.focus();
    });
  }
})();
</script>
<script id="feature-remove-nth-field">
(() => {
  // ---- Shortcuts ----
  const $  = (id) => document.getElementById(id);
  const $$ = (sel) => document.querySelector(sel);

  // Editor + UI
  const editor   = $('textArea');
  const mnuBtn   = $('mnuFieldRemove') || $$('[data-menu="field-remove"]');
  const tlbBtn   = $('nthFieldRemover') || $$('[data-button="field-remove"]');
  const modal    = $('nth-remover-modal');                // <-- actual modal ID
  const inpIdx   = $('nthIndexInput');
  const btnApply = $('nthApplyBtn');
  const btnCancel= $('nthCancelBtn');

  if (!editor || !modal || !inpIdx || !btnApply || !btnCancel) return;

  // Overlay helpers (reuse app if present)
  const openOverlay  = window.openOverlay  || ((ov)=>{ ov.style.display='flex'; ov.setAttribute('data-open','true'); });
  const closeOverlay = window.closeOverlay || ((ov)=>{ ov.style.display='none'; ov.removeAttribute('data-open'); });

  // ---- Tuple parsing (prefer your helper) ----
  const H = window.DupHelpers || {};
  const parseTuple = H.parseSqlTupleLine;

  // Fallback: find first tuple in a line, split/join CSV with quote-awareness
  function findFirstTupleInLine(line) {
    const n = line.length;
    let start = line.indexOf('(');
    if (start === -1) return null;
    let depth = 0, inS = false;
    for (let i = start; i < n; i++){
      const ch = line[i];
      if (inS){
        if (ch === "\\") { i++; continue; }
        if (ch === "'") {
          if (line[i+1] === "'") { i++; continue; }
          inS = false; continue;
        }
        continue;
      }
      if (ch === "'") { inS = true; continue; }
      if (ch === "(") { if (!depth) start = i; depth++; continue; }
      if (ch === ")") {
        depth--;
        if (!depth) return { open:start, close:i+1, raw:line.slice(start, i+1) };
      }
    }
    return null;
  }
  function splitFieldsRobust(raw){
    let s = raw.trim();
    if (s.startsWith('(') && s.endsWith(')')) s = s.slice(1,-1);
    const out = []; let buf = '', inS=false;
    for (let i=0;i<s.length;i++){
      const ch=s[i];
      if (inS){
        buf += ch;
        if (ch === "\\") { if (i+1<s.length){ buf+=s[++i]; } continue; }
        if (ch === "'"){ if (s[i+1]==="'"){ buf+=s[++i]; } else { inS=false; } }
        continue;
      }
      if (ch === "'"){ inS=true; buf+=ch; continue; }
      if (ch === ","){ out.push(buf.trim()); buf=''; continue; }
      buf+=ch;
    }
    if (buf) out.push(buf.trim());
    return out;
  }

  // Remove 1-based index from an array
  function removeFieldArray(fields, index1){
    const i0 = Math.floor(Number(index1)) - 1;
    if (!Number.isFinite(i0) || i0 < 0 || i0 >= fields.length) return null;
    const out = fields.slice();
    out.splice(i0, 1);
    return out;
  }

  // Apply across entire document
  function applyRemoveNth(index1){
    const lines = editor.value.split(/\r?\n/);
    let changed = false;

    for (let li=0; li<lines.length; li++){
      const line = lines[li];
      let parsed = parseTuple ? parseTuple(line) : null;

      if (!parsed || !parsed.ok){
        const tup = findFirstTupleInLine(line);
        if (!tup) continue;
        const fields = splitFieldsRobust(tup.raw);
        const newFields = removeFieldArray(fields, index1);
        if (!newFields) continue;
        lines[li] = line.slice(0, tup.open) + '(' + newFields.join(', ') + ')' + line.slice(tup.close);
        changed = true;
        continue;
      }

      const newFields = removeFieldArray(parsed.fields, index1);
      if (!newFields) continue;
      const newLine = parsed.reconstructed(newFields);
      if (newLine !== line){ lines[li] = newLine; changed = true; }
    }

    if (changed){
      editor.value = lines.join('\n');
      try { window.pushSnapshot?.(); } catch {}
      try { window.updateRowsCountPill?.(); } catch {}
    }
    return changed;
  }

  // ---- Open/Close wiring ----
  function openModal(){
    openOverlay(modal);
    setTimeout(()=>{ inpIdx.focus(); inpIdx.select?.(); }, 0);
  }
  function wireOnce(el, evt, fn){ if (!el || el._wired) return; el._wired = true; el.addEventListener(evt, fn); }

  wireOnce(mnuBtn, 'click', (e)=>{ e.preventDefault(); openModal(); });
  wireOnce(tlbBtn, 'click', (e)=>{ e.preventDefault(); openModal(); });

  wireOnce(btnCancel, 'click', (e)=>{ e.preventDefault(); closeOverlay(modal); });
  if (!modal._backdropWired){
    modal._backdropWired = true;
    modal.addEventListener('click', (e)=>{ if (e.target === modal) closeOverlay(modal); });
  }
  if (!modal._escWired){
    modal._escWired = true;
    document.addEventListener('keydown', (e)=>{
      if (e.key !== 'Escape') return;
      const openTop = Array.from(document.querySelectorAll('.overlay[data-open="true"]')).pop();
      if (openTop === modal) closeOverlay(modal);
    });
  }

  // ---- Apply button ----
  wireOnce(btnApply, 'click', (e)=>{
    e.preventDefault();
    const idx = Math.floor(Number((inpIdx.value || '').trim()));
    if (!Number.isFinite(idx) || idx < 1){
      alert('Field index must be a positive integer (1-based).');
      inpIdx.focus();
      return;
    }
    applyRemoveNth(idx);
    closeOverlay(modal);
    editor.focus();
  });
})();
</script>
<script id="feature-set-field">
(() => {
  // ---------- DOM helpers ----------
  const $  = (id) => document.getElementById(id);
  const $$ = (sel) => document.querySelector(sel);

  // Editor
  const editor =
    $('textArea') ||
    $$('textarea#textArea, textarea.editor, textarea[name="textArea"], textarea');

  // Modal + controls (with flexible fallbacks)
  const modal =
    $('set-field-modal') ||
    $$('#set-field-modal, .set-field-modal, [data-modal="set-field"], #setFieldModal');

  const mnuSet =
    $('mnuFieldSet') ||
    $$('#mnuFieldSet, [data-menu="field-set"], [data-action="field-set"]');

  const tlbBtn =
    $('setFieldBtn') ||
    $$('#setFieldBtn, [data-button="field-set"], [data-tool="field-set"]');

  const btnApply =
    $('setFieldApplyBtn') ||
    $$('#setFieldApplyBtn, [data-apply="field-set"]');

  const btnCancel =
    $('setFieldCancelBtn') ||
    $$('#setFieldCancelBtn, [data-cancel="field-set"]');

  const inpIndex =
    $('setFieldIndexInput') ||
    $$('#setFieldIndexInput, [name="setFieldIndex"], input[data-role="set-index"]');

  const inpValue =
    $('setFieldValueInput') ||
    $$('#setFieldValueInput, [name="setFieldValue"], input[data-role="set-value"]');

  // Optional scope checkboxes (inside this modal)
  const scopeSet = $('setScopeSet') || $$('#setScopeSet, [data-scope="set"]');
  const scopeDoc = $('setScopeDoc') || $$('#setScopeDoc, [data-scope="doc"]');

  if (!editor || !modal || !btnApply || !btnCancel || !inpIndex || !inpValue) return;

  // ---------- Overlay helpers ----------
  const openOverlay  = window.openOverlay  || ((ov)=>{ ov.style.display='flex'; ov.setAttribute('data-open','true'); });
  const closeOverlay = window.closeOverlay || ((ov)=>{ ov.style.display='none'; ov.removeAttribute('data-open'); });

  // ---------- Tuple parsing (prefer your app helpers; include robust fallback) ----------
  const H = window.DupHelpers || {};
  const parseTuple = H.parseSqlTupleLine; // should return { ok, fields, reconstructed(newFields) }

  // Fallback: find first tuple "( ... )" in a line respecting quotes/escapes
  function findFirstTupleInLine(line) {
    const n = line.length;
    let start = line.indexOf('(');
    if (start === -1) return null;
    let depth = 0, inS = false;
    for (let i = start; i < n; i++) {
      const ch = line[i];
      if (inS) {
        if (ch === "\\") { i++; continue; }
        if (ch === "'") {
          if (line[i+1] === "'") { i++; continue; } // doubled apostrophe
          inS = false; continue;
        }
        continue;
      }
      if (ch === "'") { inS = true; continue; }
      if (ch === "(") { if (!depth) start = i; depth++; continue; }
      if (ch === ")") {
        depth--;
        if (!depth) return { open:start, close:i+1, raw:line.slice(start, i+1) };
      }
    }
    return null;
  }
  // Split top-level CSV respecting single quotes ('' and \')
  function splitFieldsRobust(rawTuple) {
    let s = rawTuple.trim();
    if (s.startsWith('(') && s.endsWith(')')) s = s.slice(1,-1);
    const out=[]; let buf='', inS=false;
    for (let i=0;i<s.length;i++){
      const ch=s[i];
      if (inS){
        buf+=ch;
        if (ch==="\\"){ if (i+1<s.length){ buf+=s[++i]; } continue; }
        if (ch==="'"){ if (s[i+1]==="'"){ buf+=s[++i]; } else { inS=false; } }
        continue;
      }
      if (ch==="'"){ inS=true; buf+=ch; continue; }
      if (ch===','){ out.push(buf.trim()); buf=''; continue; }
      buf+=ch;
    }
    if (buf) out.push(buf.trim());
    return out;
  }
  function joinFields(parts){ return '(' + parts.join(', ') + ')'; }

  // ---------- Scope helpers (Current set vs Whole document) ----------
  function wireScopeExclusivity(){
    if (!scopeSet || !scopeDoc) return;
    const ensureDefault = ()=>{ if (!scopeSet.checked && !scopeDoc.checked) scopeSet.checked = true; };
    scopeSet.addEventListener('change', ()=>{ if (scopeSet.checked) scopeDoc.checked=false; ensureDefault(); });
    scopeDoc.addEventListener('change', ()=>{ if (scopeDoc.checked) scopeSet.checked=false; ensureDefault(); });
    ensureDefault();
  }

  function enumerateSets(lines){
    const sets=[]; let i=0;
    while(i<lines.length){
      while(i<lines.length && lines[i].trim()==='') i++;
      if(i>=lines.length) break;
      const start=i;
      while(i<lines.length && lines[i].trim()!=='') i++;
      sets.push({start,end:i});
    }
    return sets;
  }
  function caretSet(lines){
    const caret = editor.selectionStart || 0;
    const before = editor.value.slice(0, caret);
    const lineIdx = (before.match(/\n/g)||[]).length;
    const sets = enumerateSets(lines);
    for (const s of sets){ if (lineIdx>=s.start && lineIdx<s.end) return s; }
    return { start: Math.max(0,lineIdx), end: Math.max(0,lineIdx+1) };
  }
  function selectedRanges(){
    const lines = editor.value.split(/\r?\n/);
    const ranges = [];
    const cur = caretSet(lines);
    if (scopeSet?.checked) ranges.push(cur);
    if (scopeDoc?.checked){ for (const s of enumerateSets(lines)) ranges.push(s); }
    if (!ranges.length) ranges.push(cur); // default to current set if no checkboxes exist
    return { lines, ranges };
  }

  // ---------- Value formatting ----------
  function toSqlStringLiteral(s){
    // Always wrap in single quotes; escape ' as ''
    return `'${String(s).replace(/'/g,"''")}'`;
  }

  // ---------- Core apply: set field N to a value (number or string) ----------
  function setFieldInArray(fields, index1, kind, rawValue){
    const idx0 = Math.floor(Number(index1)) - 1;
    if (!Number.isFinite(idx0) || idx0 < 0 || idx0 >= fields.length) return null;

    let replacement;
    if (kind === 'number') {
      const num = Number(rawValue);
      if (!Number.isFinite(num)) return null; // ignore invalid numeric
      // Preserve prior quoting style on that field if it looked quoted
      const wasQuoted = /^\s*'.*'\s*$/.test(fields[idx0]);
      replacement = wasQuoted ? toSqlStringLiteral(num) : String(num);
    } else {
      // string: always single-quote with proper escaping
      replacement = toSqlStringLiteral(rawValue);
    }

    const out = fields.slice();
    out[idx0] = replacement;
    return out;
  }

  function applySetFieldAcrossScope(index1, kind, rawValue){
    const { lines, ranges } = selectedRanges();
    let changed = false;

    for (const {start,end} of ranges){
      for (let li=start; li<end; li++){
        const line = lines[li];

        // Prefer app helper; otherwise fallback parse
        const parsed = (typeof parseTuple === 'function') ? parseTuple(line) : null;

        if (parsed && parsed.ok){
          const newFields = setFieldInArray(parsed.fields, index1, kind, rawValue);
          if (!newFields) continue;
          const newLine = parsed.reconstructed(newFields);
          if (newLine !== line){ lines[li] = newLine; changed = true; }
          continue;
        }

        // Fallback path (first tuple on the line)
        const tup = findFirstTupleInLine(line);
        if (!tup) continue;
        const fields = splitFieldsRobust(tup.raw);
        const newFields = setFieldInArray(fields, index1, kind, rawValue);
        if (!newFields) continue;
        const rebuilt = line.slice(0, tup.open) + joinFields(newFields) + line.slice(tup.close);
        if (rebuilt !== line){ lines[li] = rebuilt; changed = true; }
      }
    }

    if (changed){
      editor.value = lines.join('\n');
      try { window.pushSnapshot?.(); } catch {}
      try { window.updateRowsCountPill?.(); } catch {}
    }
    return changed;
  }

  // ---------- Open/close ----------
  function openModal(){
    if (scopeSet && scopeDoc) wireScopeExclusivity();
    openOverlay(modal);
    // Focus index first; if empty, default to 1 for convenience
    setTimeout(()=>{
      if (inpIndex && (!inpIndex.value || Number(inpIndex.value) < 1)) inpIndex.value = '1';
      inpIndex?.focus(); inpIndex?.select?.();
    },0);
  }
  function wireOnce(el, evt, fn){ if (!el || el._wired) return; el._wired = true; el.addEventListener(evt, fn); }

  wireOnce(mnuSet, 'click', (e)=>{ e.preventDefault(); openModal(); });
  wireOnce(tlbBtn, 'click', (e)=>{ e.preventDefault(); openModal(); });

  wireOnce(btnCancel, 'click', (e)=>{ e.preventDefault(); closeOverlay(modal); });
  if (!modal._backdropWired){
    modal._backdropWired = true;
    modal.addEventListener('click', (e)=>{ if (e.target === modal) closeOverlay(modal); });
  }
  if (!modal._escWired){
    modal._escWired = true;
    document.addEventListener('keydown', (e)=>{
      if (e.key !== 'Escape') return;
      const openTop = Array.from(document.querySelectorAll('.overlay[data-open="true"]')).pop();
      if (openTop === modal) closeOverlay(modal);
    });
  }

  // ---------- Apply wiring ----------
  function getTypeSelection(){
    // radios: <input type="radio" name="setFieldType" value="number|string">
    const sel = document.querySelector('input[name="setFieldType"]:checked');
    const v = sel?.value?.toLowerCase();
    return (v === 'number' || v === 'string') ? v : 'string';
  }

  wireOnce(btnApply, 'click', (e)=>{
    e.preventDefault();

    const idx = Math.floor(Number((inpIndex.value || '').trim()));
    if (!Number.isFinite(idx) || idx < 1){
      alert('Field index must be a positive integer (1-based).');
      inpIndex.focus();
      return;
    }

    const kind = getTypeSelection(); // 'number' or 'string'
    const rawValue = (inpValue.value ?? '');

    const did = applySetFieldAcrossScope(idx, kind, rawValue);
    // Optional toast: if (!did) alert('No tuples were changed.');
    closeOverlay(modal);
    editor.focus();
  });
})();
</script>
<script id="feature-set-field-apply">
(() => {
  const $ = (id) => document.getElementById(id);

  // --- Core elements
  const ta = $('textArea');
  const modal = $('set-field-modal');
  const scopeBox = $('setScopeInput');

  // A) target = value when other field equals
  const sf_target_when   = $('sf_target_when');
  const sf_val_when_type = $('sf_val_when_type');
  const sf_val_when      = $('sf_val_when');
  const sf_cond_field    = $('sf_cond_field');
  const sf_cond_type     = $('sf_cond_type');
  const sf_cond_value    = $('sf_cond_value');
  const sf_apply_when    = $('sf_apply_when');

  // B) target = value (unconditional)
  const sf_target_all    = $('sf_target_all');
  const sf_val_all_type  = $('sf_val_all_type');
  const sf_val_all       = $('sf_val_all');
  const sf_apply_all     = $('sf_apply_all');

  // C) fields X..Y replaced with a single string field
  const sf_span_start    = $('sf_span_start');
  const sf_span_end      = $('sf_span_end');
  const sf_span_text     = $('sf_span_text');
  const sf_apply_span    = $('sf_apply_span');

  // D) increment sequence into field
  const sf_inc_field     = $('sf_inc_field');
  const sf_inc_start     = $('sf_inc_start');
  const sf_inc_cont      = $('sf_inc_continue');
  const sf_apply_inc     = $('sf_apply_inc');

  if (!ta || !modal || !scopeBox) return;

  // --- Use your robust parser (handles '' and \')
  const H = window.DupHelpers || {};
  const parseTuple = H.parseSqlTupleLine;

  // --- Utilities
  function toSqlStringLiteral(s) { return `'${String(s).replace(/'/g, "''")}'`; }
  function isQuoted(tok) { return /^\s*'.*'\s*$/.test(tok); }
  function trimQuotes(s) {
    const t = String(s).trim();
    if (t.startsWith("'") && t.endsWith("'")) {
      const inner = t.slice(1, -1);
      // unescape doubled apostrophes to a single apostrophe; preserve backslashes
      return inner.replace(/''/g, "'");
    }
    return t;
  }

  // Scope: "doc" or N (1-based set index). Sets are blocks of non-blank lines separated by a blank line.
  function splitIntoSets(lines) {
    const sets = [];
    let start = null;
    for (let i = 0; i < lines.length; i++) {
      const blank = lines[i].trim() === '';
      if (!blank && start === null) start = i;
      if ((blank || i === lines.length - 1) && start !== null) {
        const end = blank ? i - 1 : i; // inclusive
        sets.push({ start, end });
        start = null;
      }
    }
    return sets;
  }

  function getScopeRanges(lines) {
    const raw = (scopeBox.textContent || scopeBox.innerText || '').trim().toLowerCase();
    if (raw === 'doc' || raw === '') {
      return [{ start: 0, end: lines.length - 1 }]; // whole doc
    }
    const n = parseInt(raw, 10);
    if (!Number.isFinite(n) || n < 1) {
      // default to current set at caret
      const sets = splitIntoSets(lines);
      const caret = ta.selectionStart || 0;
      const caretLine = ta.value.slice(0, caret).split(/\r?\n/).length - 1;
      const s = sets.find(x => caretLine >= x.start && caretLine <= x.end);
      return s ? [s] : [{ start: 0, end: lines.length - 1 }];
    }
    const sets = splitIntoSets(lines);
    const s = sets[n - 1];
    return s ? [s] : [];
  }

  function writeBack(lines) {
    ta.value = lines.join('\n');
    try { window.pushSnapshot?.(); } catch {}
    try { window.updateRowsCountPill?.(); } catch {}
  }

  function setField(fields, index1, newToken) {
    const i0 = index1 - 1;
    if (i0 < 0 || i0 >= fields.length) return null;
    const next = fields.slice();
    next[i0] = newToken;
    return next;
  }

  // (number|string) value → SQL token, preserving quoting for numeric if original looked quoted
  function makeReplacementToken(kind, rawValue, originalTokenForStyle) {
    if (kind === 'number') {
      const num = Number(rawValue);
      if (!Number.isFinite(num)) return null;
      return isQuoted(originalTokenForStyle) ? toSqlStringLiteral(num) : String(num);
    }
    // string: always as a proper SQL string literal
    return toSqlStringLiteral(rawValue);
  }

  function applyAcrossRanges(modifier) {
    const lines = ta.value.split(/\r?\n/);
    const ranges = getScopeRanges(lines);
    let changed = false;

    for (const { start, end } of ranges) {
      for (let li = start; li <= end; li++) {
        const line = lines[li];
        const p = (typeof parseTuple === 'function') ? parseTuple(line) : { ok:false };
        if (!p || !p.ok) continue;

        const newFields = modifier(p.fields.slice());
        if (!newFields) continue;

        const newLine = p.reconstructed(newFields);
        if (newLine !== line) {
          lines[li] = newLine;
          changed = true;
        }
      }
    }

    if (changed) writeBack(lines);
    return changed;
  }

  // --------- A) Conditional set: target = value WHEN condField == condValue ---------
  function onApplyWhen() {
    const idxTarget = Math.floor(Number(sf_target_when.value));
    const kindVal   = (sf_val_when_type.value || 'string').toLowerCase();
    const rawVal    = sf_val_when.value ?? '';

    const idxCond   = Math.floor(Number(sf_cond_field.value));
    const kindCond  = (sf_cond_type.value || 'string').toLowerCase();
    const rawCond   = sf_cond_value.value ?? '';

    if (!Number.isFinite(idxTarget) || idxTarget < 1) return;
    if (!Number.isFinite(idxCond)   || idxCond   < 1) return;

    applyAcrossRanges((fields) => {
      const ti = idxTarget - 1, ci = idxCond - 1;
      if (ci >= fields.length || ti >= fields.length) return null;

      // compute field value for comparison
      let lhs; // value from the tuple at cond field
      const tok = fields[ci];
      if (kindCond === 'number') {
        const numS = isQuoted(tok) ? trimQuotes(tok) : tok.trim();
        const n = Number(numS);
        if (!Number.isFinite(n)) return null;
        lhs = n;
      } else {
        lhs = trimQuotes(tok);
      }

      // normalize RHS from input
      const rhs = (kindCond === 'number') ? Number(rawCond) : String(rawCond);
      if (kindCond === 'number' && !Number.isFinite(rhs)) return null;

      const isEqual = (lhs === rhs);

      if (isEqual) {
        const newTok = makeReplacementToken(kindVal, rawVal, fields[ti]);
        if (newTok == null) return null;
        const next = fields.slice();
        next[ti] = newTok;
        return next;
      }
      return fields;
    });
  }

  // --------- B) Unconditional set: target = value ---------
  function onApplyAll() {
    const idxTarget = Math.floor(Number(sf_target_all.value));
    const kindVal   = (sf_val_all_type.value || 'string').toLowerCase();
    const rawVal    = sf_val_all.value ?? '';
    if (!Number.isFinite(idxTarget) || idxTarget < 1) return;

    applyAcrossRanges((fields) => {
      if (idxTarget > fields.length) return null;
      const newTok = makeReplacementToken(kindVal, rawVal, fields[idxTarget - 1]);
      if (newTok == null) return null;
      return setField(fields, idxTarget, newTok);
    });
  }

  // --------- C) Replace span X..Y with a single string field ---------
  function onApplySpan() {
    const a = Math.floor(Number(sf_span_start.value));
    const b = Math.floor(Number(sf_span_end.value));
    const s = sf_span_text.value ?? '';
    if (!Number.isFinite(a) || !Number.isFinite(b) || a < 1 || b < 1) return;

    const from = Math.min(a, b), to = Math.max(a, b);

    applyAcrossRanges((fields) => {
      const i0 = from - 1, i1 = to - 1;
      if (i0 >= fields.length) return null;
      const next = fields.slice();
      // clamp i1 to last index
      const endIdx = Math.min(i1, next.length - 1);
      next.splice(i0, endIdx - i0 + 1, toSqlStringLiteral(s));
      return next;
    });
  }

  // --------- D) Increment sequence into field ---------
  function onApplyInc() {
    const idx = Math.floor(Number(sf_inc_field.value));
    let startNum = Number(sf_inc_start.value);
    const cont = !!(sf_inc_cont && sf_inc_cont.checked);
    if (!Number.isFinite(idx) || idx < 1) return;
    if (!Number.isFinite(startNum)) startNum = 1;

    const lines = ta.value.split(/\r?\n/);
    const ranges = getScopeRanges(lines);
    let globalCounter = startNum;

    for (const { start, end } of ranges) {
      let localCounter = cont ? globalCounter : startNum;
      for (let li = start; li <= end; li++) {
        const p = parseTuple(lines[li]);
        if (!p || !p.ok) continue;
        if (idx > p.fields.length) continue;

        const nextFields = setField(p.fields, idx, String(localCounter));
        if (!nextFields) continue;

        lines[li] = p.reconstructed(nextFields);
        localCounter++;
      }
      if (!cont) {
        // nothing to carry
      } else {
        globalCounter = localCounter;
      }
    }

    writeBack(lines);
  }

  // --- Wire buttons (once)
  function wireOnce(el, evt, fn) { if (!el || el._wired) return; el._wired = true; el.addEventListener(evt, fn); }

  wireOnce(sf_apply_when, 'click', (e) => { e.preventDefault(); onApplyWhen(); });
  wireOnce(sf_apply_all,  'click', (e) => { e.preventDefault(); onApplyAll(); });
  wireOnce(sf_apply_span, 'click', (e) => { e.preventDefault(); onApplySpan(); });
  wireOnce(sf_apply_inc,  'click', (e) => { e.preventDefault(); onApplyInc(); });
})();
</script>
<script id="feature-open-set-field">
(() => {
  const $  = (id) => document.getElementById(id);
  const $$ = (sel) => document.querySelector(sel);

  // Elements in your file
  const editor   = $('textArea');
  const mnuSet   = $('mnuFieldSet');        // Tools → Field → Set Field (exists)
  const modal    = $('set-field-modal');    // Set Field modal (exists)
  const btnClose = $('sf_close');           // Close button in footer (exists)

  if (!editor || !mnuSet || !modal || !btnClose) return;

  // Use existing overlay helpers if available, else minimal fallback
  const openOverlay  = window.openOverlay  || ((ov)=>{ ov.style.display='flex'; ov.setAttribute('data-open','true'); });
  const closeOverlay = window.closeOverlay || ((ov)=>{ ov.style.display='none'; ov.removeAttribute('data-open'); });

  function openModal() {
    openOverlay(modal);
    // Handy default focus: the first index input if present
    const firstIndex = $('sf_target_when') || $('sf_target_all') || $('sf_span_start') || $('sf_inc_field');
    setTimeout(() => { firstIndex?.focus(); firstIndex?.select?.(); }, 0);
  }

  // Wire once helpers
  function wireOnce(el, evt, fn){ if (!el || el._wired) return; el._wired = true; el.addEventListener(evt, fn); }

  // Open from menu
  wireOnce(mnuSet, 'click', (e)=>{ e.preventDefault(); openModal(); });

  // Close from footer button
  wireOnce(btnClose, 'click', (e)=>{ e.preventDefault(); closeOverlay(modal); editor.focus(); });

  // Click backdrop to close
  if (!modal._backdropWired){
    modal._backdropWired = true;
    modal.addEventListener('click', (e)=>{ if (e.target === modal) { closeOverlay(modal); editor.focus(); }});
  }

  // ESC closes topmost overlay
  if (!modal._escWired){
    modal._escWired = true;
    document.addEventListener('keydown', (e)=>{
      if (e.key !== 'Escape') return;
      const openTop = Array.from(document.querySelectorAll('.overlay[data-open="true"]')).pop();
      if (openTop === modal) { e.preventDefault(); closeOverlay(modal); editor.focus(); }
    });
  }
})();
</script>
<script id="feature-field-swapper">
(() => {
  // ---------- tiny helpers ----------
  const $  = (id) => document.getElementById(id);
  const $$ = (sel) => document.querySelector(sel);

  const ta       = $('textArea');
  const mnuSwap  = $('mnuFieldSwapper');
  const modal    = $('field-swapper-modal');
  const listUl   = $('fsList');
  const btnApply = $('fsApplyBtn');
  const btnCancel= $('fsCancelBtn');

  if (!ta || !mnuSwap || !modal || !listUl || !btnApply || !btnCancel) return;

  // Overlay helpers (reuse app’s if present)
  const openOverlay  = window.openOverlay  || ((ov)=>{ ov.style.display='flex'; ov.setAttribute('data-open','true'); });
  const closeOverlay = window.closeOverlay || ((ov)=>{ ov.style.display='none'; ov.removeAttribute('data-open'); });

  // Use your parser which handles quotes + escapes
  const parseTuple = (window.DupHelpers?.parseSqlTupleLine) || window.parseSqlTupleLine;

  // ---------- derive field count ----------
  function maxFieldCountAcrossDoc() {
    const lines = ta.value.split(/\r?\n/);
    let max = 0;
    for (const line of lines) {
      const p = parseTuple?.(line);
      if (p && p.ok) max = Math.max(max, p.fields.length);
    }
    return max || 0;
  }

  // ---------- list builders (drag n’ drop + rename) ----------
  function clearChildren(el){ while(el.firstChild) el.removeChild(el.firstChild); }

  function buildList(n) {
    clearChildren(listUl);
    for (let i = 1; i <= n; i++) {
      const li = document.createElement('li');
      li.className = 'fs-item';
      li.draggable = true;
      li.dataset.index = String(i);     // 1-based original position
      li.setAttribute('role','option');

      const name = document.createElement('span');
      name.className = 'fs-name';
      name.textContent = `Field ${i}`;

      // double-click to rename
      li.addEventListener('dblclick', () => {
        const newName = prompt('Rename field label (cosmetic only):', name.textContent);
        if (newName != null && newName.trim() !== '') name.textContent = newName.trim();
      });

      li.appendChild(name);
      listUl.appendChild(li);
    }
  }

  // Simple HTML5 drag & drop
  let dragEl = null;
  listUl.addEventListener('dragstart', (e) => {
    const li = e.target.closest('li');
    if (!li) return;
    dragEl = li;
    e.dataTransfer.setData('text/plain', li.dataset.index || '');
    e.dataTransfer.effectAllowed = 'move';
    li.classList.add('dragging');
  });
  listUl.addEventListener('dragend', () => {
    if (dragEl) dragEl.classList.remove('dragging');
    dragEl = null;
  });
  listUl.addEventListener('dragover', (e) => {
    e.preventDefault();
    const after = getDragAfterElement(listUl, e.clientY);
    if (after == null) {
      listUl.appendChild(dragEl);
    } else {
      listUl.insertBefore(dragEl, after);
    }
  });
  function getDragAfterElement(container, y) {
    const els = [...container.querySelectorAll('li:not(.dragging)')];
    return els.reduce((closest, child) => {
      const box = child.getBoundingClientRect();
      const offset = y - (box.top + box.height/2);
      if (offset < 0 && offset > closest.offset) return { offset, element: child };
      else return closest;
    }, { offset: Number.NEGATIVE_INFINITY, element: null }).element;
  }

  function currentOrder() {
    // returns array of original field 1-based positions in new order, e.g. [2,1,3]
    return [...listUl.querySelectorAll('li')].map(li => parseInt(li.dataset.index, 10));
  }

  // ---------- apply order across whole document ----------
  function applyFieldOrder(order) {
    if (!Array.isArray(order) || !order.length) return false;

    const lines = ta.value.split(/\r?\n/);
    let changed = false;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const p = parseTuple?.(line);
      if (!p || !p.ok) continue;

      const old = p.fields;
      const n = old.length;
      // Build new array; for any order entries beyond n, ignore; for fields not listed, append in original order.
      const picked = [];
      for (const oneBased of order) {
        const idx0 = oneBased - 1;
        if (idx0 >= 0 && idx0 < n) picked.push(old[idx0]);
      }
      // If the order omitted some fields (e.g., user built list from a shorter row), append the rest:
      if (picked.length < n) {
        const missing = [];
        for (let k = 0; k < n; k++) {
          const oneBased = k + 1;
          if (!order.includes(oneBased)) missing.push(old[k]);
        }
        picked.push(...missing);
      }

      const newLine = p.reconstructed(picked);
      if (newLine !== line) { lines[i] = newLine; changed = true; }
    }

    if (changed) {
      ta.value = lines.join('\n');
      try { window.pushSnapshot?.(); } catch {}
      try { window.updateRowsCountPill?.(); } catch {}
    }
    return changed;
  }

  // ---------- open/close ----------
  function openModal() {
    // derive from current document each time
    const count = maxFieldCountAcrossDoc();
    buildList(count || 0);
    openOverlay(modal);
  }
  function wireOnce(el, evt, fn){ if (!el || el._wired) return; el._wired = true; el.addEventListener(evt, fn); }

  wireOnce(mnuSwap,  'click', (e)=>{ e.preventDefault(); openModal(); });
  wireOnce(btnCancel,'click', (e)=>{ e.preventDefault(); closeOverlay(modal); ta.focus(); });

  // click backdrop to close
  if (!modal._backdropWired){
    modal._backdropWired = true;
    modal.addEventListener('click', (e)=>{ if (e.target === modal) { closeOverlay(modal); ta.focus(); }});
  }
  // ESC closes
  if (!modal._escWired){
    modal._escWired = true;
    document.addEventListener('keydown', (e)=>{
      if (e.key !== 'Escape') return;
      const openTop = [...document.querySelectorAll('.overlay[data-open="true"]')].pop();
      if (openTop === modal){ e.preventDefault(); closeOverlay(modal); ta.focus(); }
    });
  }

  // ---------- apply ----------
  wireOnce(btnApply, 'click', (e)=>{
    e.preventDefault();
    const order = currentOrder(); // e.g. [3,1,2]
    applyFieldOrder(order);
    closeOverlay(modal);
    ta.focus();
  });

  // ---------- minimal styles for drag state (optional; safe-noop if already styled) ----------
  const styleId = 'fs-drag-style';
  if (!document.getElementById(styleId)){
    const st = document.createElement('style'); st.id = styleId;
    st.textContent = `
      #field-swapper-modal .fs-list { list-style:none; margin:0; padding:0; }
      #field-swapper-modal .fs-item { padding:6px 10px; border:1px solid var(--border); border-radius:6px; margin:6px 0; cursor:grab; user-select:none; }
      #field-swapper-modal .fs-item.dragging { opacity:0.6; }
      #field-swapper-modal .fs-name { pointer-events:none; }
    `;
    document.head.appendChild(st);
  }
})();
</script>
<script id="feature-append-prepend">
(() => {
  const $  = (id) => document.getElementById(id);
  const $$ = (sel) => document.querySelector(sel);

  // Editor + menu + modal + controls
  const ta       = $('textArea');
  const mnuAP    = $('mnuFieldAppendPrepend');
  const modal    = $('append-prepend-modal');
  // A) Target [Append/Prepend] × Field
  const ap_target_field_f = $('ap_target_field_f');
  const ap_op_f           = $('ap_op_f');
  const ap_source_field   = $('ap_source_field');
  const ap_apply_field    = $('ap_apply_field');
  // B) Target [Append/Prepend] × String
  const ap_target_field_s = $('ap_target_field_s');
  const ap_op_s           = $('ap_op_s');
  const ap_string_input   = $('ap_string_input');
  const ap_apply_string   = $('ap_apply_string');
  const ap_close_btn      = $('ap_close_btn');

  if (!ta || !mnuAP || !modal || !ap_apply_field || !ap_apply_string) return;

  // Use app overlay helpers if present
  const openOverlay  = window.openOverlay  || ((ov)=>{ ov.style.display = 'flex'; ov.setAttribute('data-open','true'); });
  const closeOverlay = window.closeOverlay || ((ov)=>{ ov.style.display = 'none'; ov.removeAttribute('data-open'); });

  // Robust tuple parser that preserves quoting/backslashes on reconstruction
  const parseTuple = (window.DupHelpers?.parseSqlTupleLine) || window.parseSqlTupleLine;

  // ---- SQL string helpers (apostrophes become doubled, backslashes preserved) ----
  const isQuoted = (tok) => /^\s*'.*'\s*$/.test(String(tok));
  const toSqlString = (s) => `'${String(s).replace(/'/g,"''")}'`;
  const unquote = (tok) => {
    const t = String(tok).trim();
    if (!isQuoted(t)) return t;
    // strip quotes, collapse doubled apostrophes; leave backslashes verbatim
    return t.slice(1, -1).replace(/''/g, "'");
  };

  // ---- Apply helpers ----
  function writeBack(lines){
    ta.value = lines.join('\n');
    try { window.pushSnapshot?.(); } catch {}
    try { window.updateRowsCountPill?.(); } catch {}
  }

  function applyAcrossDoc(modifier){
    const lines = ta.value.split(/\r?\n/);
    let changed = false;
    for (let i=0;i<lines.length;i++){
      const p = parseTuple?.(lines[i]);
      if (!p || !p.ok) continue;
      const nextFields = modifier(p.fields.slice());
      if (!nextFields) continue;
      const newLine = p.reconstructed(nextFields);
      if (newLine !== lines[i]) { lines[i] = newLine; changed = true; }
    }
    if (changed) writeBack(lines);
    return changed;
  }

  // ---- A) Append/Prepend with FIELD ----
  function onApplyField(){
    const targetIdx = Math.floor(Number(ap_target_field_f.value));
    const op = (ap_op_f.value || 'append').toLowerCase(); // 'append' | 'prepend'
    const srcIdx = Math.floor(Number(ap_source_field.value));
    if (!Number.isFinite(targetIdx) || targetIdx < 1) return;
    if (!Number.isFinite(srcIdx)    || srcIdx    < 1) return;

    applyAcrossDoc((fields)=>{
      const t0 = targetIdx - 1, s0 = srcIdx - 1;
      if (t0 >= fields.length || s0 >= fields.length) return null;

      const tgtRaw = fields[t0], srcRaw = fields[s0];
      const tgtStr = unquote(tgtRaw);
      const srcStr = unquote(srcRaw);

      // Skip tuple if source becomes empty string after unquoting/trim
      if (srcStr === '') return fields;

      const result = (op === 'prepend') ? (srcStr + tgtStr) : (tgtStr + srcStr);
      const out = fields.slice();
      out[t0] = toSqlString(result); // result is always a string literal
      return out;
    });
  }

  // ---- B) Append/Prepend with STRING ----
  function onApplyString(){
    const targetIdx = Math.floor(Number(ap_target_field_s.value));
    const op = (ap_op_s.value || 'append').toLowerCase();
    const str = String(ap_string_input.value ?? '');

    if (!Number.isFinite(targetIdx) || targetIdx < 1) return;
    // If user’s string is empty, skip all tuples (per UI hint)
    if (str === '') return;

    applyAcrossDoc((fields)=>{
      const t0 = targetIdx - 1;
      if (t0 >= fields.length) return null;

      const tgtRaw = fields[t0];
      const tgtStr = unquote(tgtRaw);
      const result = (op === 'prepend') ? (str + tgtStr) : (tgtStr + str);
      const out = fields.slice();
      out[t0] = toSqlString(result); // result is always a string literal
      return out;
    });
  }

  // ---- Open/Close wiring ----
  function openModal(){
    openOverlay(modal);
    // focus first numeric input
    setTimeout(()=>{ ap_target_field_f?.focus(); ap_target_field_f?.select?.(); }, 0);
  }
  function wireOnce(el, evt, fn){ if (!el || el._wired) return; el._wired = true; el.addEventListener(evt, fn); }

  wireOnce(mnuAP, 'click', (e)=>{ e.preventDefault(); openModal(); });
  wireOnce(ap_close_btn, 'click', (e)=>{ e.preventDefault(); closeOverlay(modal); ta.focus(); });
  if (!modal._backdropWired){
    modal._backdropWired = true;
    modal.addEventListener('click', (e)=>{ if (e.target === modal) { closeOverlay(modal); ta.focus(); }});
  }
  if (!modal._escWired){
    modal._escWired = true;
    document.addEventListener('keydown', (e)=>{
      if (e.key !== 'Escape') return;
      const openTop = [...document.querySelectorAll('.overlay[data-open="true"]')].pop();
      if (openTop === modal){ e.preventDefault(); closeOverlay(modal); ta.focus(); }
    });
  }

  // ---- Apply buttons ----
  wireOnce(ap_apply_field,  'click', (e)=>{ e.preventDefault(); onApplyField(); });
  wireOnce(ap_apply_string, 'click', (e)=>{ e.preventDefault(); onApplyString(); });
})();
</script>
<script id="feature-field-paste">
(() => {
  const $  = (id) => document.getElementById(id);
  const $$ = (sel) => document.querySelector(sel);

  // Editor + UI
  const ta       = $('textArea');
  const mnu      = $('mnuFieldPaste');
  const modal    = $('field-paste-modal');
  const rInsert  = $('fp_mode_insert');      // radio: insert
  const rOver    = $('fp_mode_overwrite');   // radio: overwrite
  const fpAfter  = $('fp_after');            // number (Insert after #)
  const fpFrom   = $('fp_from');             // number (Overwrite X..)
  const fpTo     = $('fp_to');               // number (Overwrite ..Y)
  const fpScope  = $('fp_scope');            // text: "doc" or set #
  const fpValue  = $('fp_value');            // text: literal(s)
  const btnApply = $('fp_apply');
  const btnCancel= $('fp_cancel');

  if (!ta || !mnu || !modal || !btnApply || !btnCancel || !fpValue) return;

  // Overlay helpers
  const openOverlay  = window.openOverlay  || ((ov)=>{ ov.style.display='flex'; ov.setAttribute('data-open','true'); });
  const closeOverlay = window.closeOverlay || ((ov)=>{ ov.style.display='none'; ov.removeAttribute('data-open'); });

  // Robust tuple parser → preserves apostrophes ('') and backslashes on reconstruction
  const parseTuple = (window.DupHelpers?.parseSqlTupleLine) || window.parseSqlTupleLine;

  // ---- Sets/scoping ----
  function splitIntoSets(lines){
    const sets=[]; let start=null;
    for (let i=0;i<lines.length;i++){
      const blank = lines[i].trim()==='';
      if(!blank && start===null) start=i;
      if((blank || i===lines.length-1) && start!==null){
        const end = blank ? i-1 : i;
        sets.push({start,end});
        start=null;
      }
    }
    return sets;
  }
  function caretSet(lines){
    const caret = ta.selectionStart||0;
    const before = ta.value.slice(0, caret);
    const lineIdx = (before.match(/\n/g)||[]).length;
    return splitIntoSets(lines).find(s => lineIdx>=s.start && lineIdx<=s.end) ?? {start:0,end:lines.length-1};
  }
  function getScopeRanges(lines){
    const raw = (fpScope.value||'').trim().toLowerCase();
    if (raw==='' || raw==='doc'){                 // default/explicit: whole document
      return [{start:0,end:lines.length-1}];
    }
    const n = parseInt(raw,10);
    if (Number.isFinite(n) && n>=1){
      const sets = splitIntoSets(lines);
      const s = sets[n-1];
      return s ? [s] : [];
    }
    // fallback: current set under caret
    return [caretSet(lines)];
  }

  // ---- CSV splitter for overwrite value: split on commas OUTSIDE single quotes, honoring '' and backslash escapes
  function splitLiteralListVerbatim(s){
    const out=[]; let buf='', inS=false;
    for(let i=0;i<s.length;i++){
      const ch=s[i];
      if (inS){
        buf+=ch;
        if (ch==="\\"){ if (i+1<s.length){ buf+=s[++i]; } continue; }   // backslash escapes next char
        if (ch==="'"){
          const nxt=s[i+1];
          if (nxt==="'"){ buf+=nxt; i++; } else { inS=false; }
        }
        continue;
      }
      if (ch==="'"){ inS=true; buf+=ch; continue; }
      if (ch===','){ out.push(buf.trim()); buf=''; continue; }
      buf+=ch;
    }
    if (buf!=='') out.push(buf.trim());
    return out;
  }

  // ---- Apply operations ----
  function writeBack(lines){
    ta.value = lines.join('\n');
    try { window.pushSnapshot?.(); } catch {}
    try { window.updateRowsCountPill?.(); } catch {}
  }

  // Insert: place ONE verbatim token after N (0 = before first)
  function applyInsert(afterN, token){
    const lines = ta.value.split(/\r?\n/);
    const ranges = getScopeRanges(lines);
    let changed=false;

    for (const {start,end} of ranges){
      for (let li=start; li<=end; li++){
        const p = parseTuple?.(lines[li]);
        if (!p || !p.ok) continue;
        const fields = p.fields.slice();
        const idx = Math.max(0, Math.min(fields.length, Math.floor(afterN))); // clamp
        fields.splice(idx, 0, token);
        const newLine = p.reconstructed(fields);
        if (newLine !== lines[li]) { lines[li] = newLine; changed=true; }
      }
    }
    if (changed) writeBack(lines);
    return changed;
  }

  // Overwrite: replace X..Y with one or more verbatim tokens
  function applyOverwrite(x, y, tokens){
    const from = Math.max(1, Math.min(x,y));
    const to   = Math.max(1, Math.max(x,y));
    const lines = ta.value.split(/\r?\n/);
    const ranges = getScopeRanges(lines);
    let changed=false;

    for (const {start,end} of ranges){
      for (let li=start; li<=end; li++){
        const p = parseTuple?.(lines[li]);
        if (!p || !p.ok) continue;

        const fields = p.fields.slice();
        const i0 = from-1;
        const i1 = Math.min(to-1, fields.length-1);
        if (i0 >= fields.length) continue; // nothing to overwrite on this row

        fields.splice(i0, i1 - i0 + 1, ...tokens);
        const newLine = p.reconstructed(fields);
        if (newLine !== lines[li]) { lines[li] = newLine; changed=true; }
      }
    }
    if (changed) writeBack(lines);
    return changed;
  }

  // ---- Open/Close wiring ----
  function openModal(){
    // default mode: Insert after 0, scope doc
    if (rInsert) rInsert.checked = true;
    if (fpAfter && (fpAfter.value === '' || Number(fpAfter.value) < 0)) fpAfter.value = '0';
    if (fpScope && fpScope.value === '') fpScope.value = 'doc';
    openOverlay(modal);
    setTimeout(()=>{ (rInsert?.checked ? fpAfter : fpFrom)?.focus(); }, 0);
  }
  function wireOnce(el, evt, fn){ if (!el || el._wired) return; el._wired = true; el.addEventListener(evt, fn); }

  wireOnce(mnu, 'click', (e)=>{ e.preventDefault(); openModal(); });
  wireOnce(btnCancel, 'click', (e)=>{ e.preventDefault(); closeOverlay(modal); ta.focus(); });

  // backdrop & ESC
  if (!modal._backdropWired){
    modal._backdropWired = true;
    modal.addEventListener('click', (e)=>{ if (e.target === modal){ closeOverlay(modal); ta.focus(); }});
  }
  if (!modal._escWired){
    modal._escWired = true;
    document.addEventListener('keydown', (e)=>{
      if (e.key !== 'Escape') return;
      const openTop = [...document.querySelectorAll('.overlay[data-open="true"]')].pop();
      if (openTop === modal){ e.preventDefault(); closeOverlay(modal); ta.focus(); }
    });
  }

  // ---- Apply button wiring ----
  wireOnce(btnApply, 'click', (e)=>{
    e.preventDefault();
    const mode = (rOver?.checked ? 'overwrite' : 'insert');

    const literal = String(fpValue.value ?? '');
    if (literal.trim()==='') { closeOverlay(modal); ta.focus(); return; }

    if (mode === 'insert'){
      const after = Math.max(0, Math.floor(Number(fpAfter.value)));
      // Insert mode: value is a single field literal, inserted verbatim. :contentReference[oaicite:2]{index=2}
      applyInsert(after, literal);
    } else {
      // Overwrite mode: may provide one or more fields separated by commas (outside quotes). :contentReference[oaicite:3]{index=3}
      const from = Math.floor(Number(fpFrom.value));
      const to   = Math.floor(Number(fpTo.value));
      if (!Number.isFinite(from) || !Number.isFinite(to) || from<1 || to<1){ return; }
      const tokens = splitLiteralListVerbatim(literal);
      if (!tokens.length) { closeOverlay(modal); ta.focus(); return; }
      applyOverwrite(from, to, tokens);
    }

    closeOverlay(modal);
    ta.focus();
  });
})();
</script>
<script id="feature-list-extractor-live">
(() => {
  const $  = (id) => document.getElementById(id);
  const $$ = (sel) => document.querySelector(sel);

  // Elements from your HTML
  const ta        = $('textArea');
  const modal     = $('list-extractor-modal');
  const mnu       = $('mnuListExtractor');
  const scopeBox  = $('listScopeInput');     // contenteditable: "doc" or set #
  const fldInput  = $('le_field');           // number (1-based)
  const outMode   = $('le_output_mode');     // "csv" | "lines"
  const cbTrim    = $('le_trim');            // checkbox
  const cbUnique  = $('le_unique');          // checkbox
  const resultTA  = $('le_result');          // output textarea
  const btnCopy   = $('le_copyBtn');
  const btnClose  = $('le_closeBtn');

  if (!ta || !modal || !mnu || !scopeBox || !fldInput || !outMode || !resultTA) return;

  // Overlay helpers
  const openOverlay  = window.openOverlay  || ((ov)=>{ ov.style.display='flex'; ov.setAttribute('data-open','true'); });
  const closeOverlay = window.closeOverlay || ((ov)=>{ ov.style.display='none'; ov.removeAttribute('data-open'); });

  // Parser that respects '' and \' and reconstructs properly
  const parseTuple = (window.DupHelpers?.parseSqlTupleLine) || window.parseSqlTupleLine;

  // --- SQL token helpers ---
  const isQuoted = (tok) => /^\s*'.*'\s*$/.test(String(tok));
  const unescapeSql = (tok) => {
    const t = String(tok).trim();
    if (!isQuoted(t)) return t;
    // strip quotes, collapse doubled apostrophes; keep backslashes verbatim
    return t.slice(1, -1).replace(/''/g, "'");
  };

  // --- Sets / scope helpers (blocks of non-blank lines) ---
  function splitIntoSets(lines){
    const sets=[]; let start=null;
    for (let i=0;i<lines.length;i++){
      const blank = lines[i].trim()==='';
      if(!blank && start===null) start=i;
      if((blank || i===lines.length-1) && start!==null){
        const end = blank ? i-1 : i;
        sets.push({start,end});
        start=null;
      }
    }
    return sets;
  }
  function caretSet(lines){
    const caret = ta.selectionStart||0;
    const before = ta.value.slice(0, caret);
    const lineIdx = (before.match(/\n/g)||[]).length;
    return splitIntoSets(lines).find(s => lineIdx>=s.start && lineIdx<=s.end) ?? {start:0,end:lines.length-1};
  }
  function getScopeRanges(lines){
    const raw = (scopeBox.textContent || scopeBox.innerText || '').trim().toLowerCase();
    if (raw === '' || raw === 'doc') return [{start:0,end:lines.length-1}];
    const n = parseInt(raw,10);
    if (Number.isFinite(n) && n>=1){
      const sets = splitIntoSets(lines);
      return sets[n-1] ? [sets[n-1]] : [];
    }
    return [caretSet(lines)];
  }

  // --- Build list from one selected field (1-based) ---
  function getValues(){
    const field1 = Math.floor(Number(fldInput.value));
    if (!Number.isFinite(field1) || field1 < 1) return [];
    const lines = ta.value.split(/\r?\n/);
    const ranges = getScopeRanges(lines);

    const vals=[];
    for (const {start,end} of ranges){
      for (let li=start; li<=end; li++){
        const p = parseTuple?.(lines[li]);
        if (!p || !p.ok) continue;
        const i0 = field1 - 1;
        if (i0 < 0 || i0 >= p.fields.length) continue;
        vals.push(unescapeSql(p.fields[i0]));
      }
    }
    return vals;
  }

  // Options
  function applyTrim(arr){ return cbTrim?.checked ? arr.map(v => String(v).trim()) : arr.slice(); }
  function applyUnique(arr){
    if (!cbUnique?.checked) return arr.slice();
    const seen = new Set(); const out=[];
    for (const v of arr){ if (!seen.has(v)){ seen.add(v); out.push(v); } }
    return out;
  }

  // CSV + block rendering
  function csvEscape(s){ return /[",\n\r]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s; }
  function shouldForceBlock(items, longThresh=120){
    return items.some(v => /\r|\n/.test(v) || String(v).length > longThresh);
  }
  function render(items){
    // apply checkboxes
    let arr = applyTrim(items);
    arr = applyUnique(arr);

    // decide output mode (auto-upgrade to block for long/newline)
    const prefer = outMode?.value || 'csv';
    const forceBlock = shouldForceBlock(arr);
    const useBlock = forceBlock || prefer === 'lines';

    // if user chose CSV but data demands block, flip the UI to match
    if (forceBlock && outMode && outMode.value !== 'lines'){
      outMode.value = 'lines';
    }

    if (useBlock){
      const sep = arr.some(v => /\r|\n/.test(v)) ? '\n\n' : '\n';
      return { text: arr.join(sep), count: arr.length };
    } else {
      return { text: arr.map(csvEscape).join(', '), count: arr.length };
    }
  }

  // --- Regenerate result ---
  function rebuild(){
    const items = getValues();
    const { text, count } = render(items);
    resultTA.value = text;
    const countLabel = $('le_count');
    if (countLabel) countLabel.textContent = `${count} item${count===1?'':'s'}`;
  }

  // --- Open/close wiring (and initial build) ---
  function openModal(){
    if (!scopeBox.textContent.trim()) scopeBox.textContent = 'doc';
    if (!outMode.value) outMode.value = 'csv';
    openOverlay(modal);
    setTimeout(()=>{ fldInput?.focus(); fldInput?.select?.(); }, 0);
    rebuild(); // build immediately on open so the user sees output change as they click the spinners
  }
  function wireOnce(el, evt, fn){ if (!el || el._wired) return; el._wired = true; el.addEventListener(evt, fn, { passive: false }); }

  wireOnce(mnu, 'click', (e)=>{ e.preventDefault(); openModal(); });

  // ESC / backdrop / close
  if (!modal._backdropWired){
    modal._backdropWired = true;
    modal.addEventListener('click', (e)=>{ if (e.target === modal){ closeOverlay(modal); ta.focus(); }});
  }
  if (!modal._escWired){
    modal._escWired = true;
    document.addEventListener('keydown', (e)=>{
      if (e.key !== 'Escape') return;
      const openTop = [...document.querySelectorAll('.overlay[data-open="true"]')].pop();
      if (openTop === modal){ e.preventDefault(); closeOverlay(modal); ta.focus(); }
    });
  }
  wireOnce(btnClose, 'click', (e)=>{ e.preventDefault(); closeOverlay(modal); ta.focus(); });

  // --- Live rebuild hooks ---
  // Number spinners fire 'input' in most browsers, 'change' on blur elsewhere → listen to both.
  ['input','change','keyup','mousewheel'].forEach(ev => {
    wireOnce(fldInput, ev, rebuild);
  });
  wireOnce(outMode, 'change', rebuild);
  wireOnce(cbTrim, 'change', rebuild);
  wireOnce(cbUnique,'change', rebuild);

  // Contenteditable scope: rebuild on keystrokes & when it loses focus
  wireOnce(scopeBox, 'input', rebuild);
  wireOnce(scopeBox, 'blur', rebuild);

  // Also rebuild when the main editor changes (since the source rows may change)
  wireOnce(ta, 'input', rebuild);

  // Copy button
  if (btnCopy){
    wireOnce(btnCopy, 'click', async (e)=>{
      e.preventDefault();
      try { await navigator.clipboard.writeText(resultTA.value || ''); } catch {}
    });
  }
})();
</script>
<script id="feature-open-list-extractor">
(() => {
  const $  = (id) => document.getElementById(id);
  const $$ = (sel) => document.querySelector(sel);

  const mnu   = $('mnuListExtractor');          // Tools → List Extractor (exists)
  const modal = $('list-extractor-modal');      // List Extractor modal (exists)
  const ta    = $('textArea');
  const btnClose = $('le_closeBtn') || $$('#le_closeBtn, [data-close="list-extractor"]');

  if (!mnu || !modal || !ta) return;

  // Use your app helpers if present; fall back to style toggling + aria
  const openOverlay  = window.openOverlay  || ((ov)=>{ ov.style.display='flex'; ov.setAttribute('data-open','true'); ov.removeAttribute('aria-hidden'); });
  const closeOverlay = window.closeOverlay || ((ov)=>{ ov.style.display='none'; ov.removeAttribute('data-open'); ov.setAttribute('aria-hidden','true'); });

  // sensible defaults + focus
  function openModal() {
    // default values for convenience
    const scope = $('listScopeInput');
    const outMode = $('le_output_mode');
    const fld = $('le_field');
    if (scope && !scope.textContent.trim()) scope.textContent = 'doc';
    if (outMode && !outMode.value) outMode.value = 'csv';
    openOverlay(modal);
    setTimeout(() => { (fld || scope)?.focus(); }, 0);
    // close any open app menus (optional)
    document.querySelectorAll('.appmenu.show').forEach(m => m.classList.remove('show'));
  }

  function wireOnce(el, evt, fn){ if (!el || el._wired) return; el._wired = true; el.addEventListener(evt, fn); }

  wireOnce(mnu, 'click', (e) => { e.preventDefault(); openModal(); });

  // close buttons / backdrop / ESC
  wireOnce(btnClose, 'click', (e) => { e.preventDefault(); closeOverlay(modal); ta.focus(); });

  if (!modal._backdropWired){
    modal._backdropWired = true;
    modal.addEventListener('click', (e) => { if (e.target === modal){ closeOverlay(modal); ta.focus(); }});
  }
  if (!modal._escWired){
    modal._escWired = true;
    document.addEventListener('keydown', (e) => {
      if (e.key !== 'Escape') return;
      const openTop = [...document.querySelectorAll('.overlay[data-open="true"]')].pop();
      if (openTop === modal){ e.preventDefault(); closeOverlay(modal); ta.focus(); }
    });
  }
})();
</script>
<script id="feature-template-maker-v2">
(() => {
  const $ = (id) => document.getElementById(id);

  // Elements
  const ta            = $('textArea');
  const modal         = $('template-maker-modal');
  const mnu           = $('mnuTemplateMaker');
  const board         = $('board');
  const btnCB         = $('tmApplyCBBtn');
  const btnLines      = $('tmApplyLinesBtn');
  const txtLines      = $('tmListAlt');
  const inpFieldIndex = $('tmFieldIndex');
  const chkSepBlank   = $('tmSepBlank');
  const btnClose      = $('tmCloseBtn');

  if (!ta || !modal || !inpFieldIndex) return;

  // Overlay helpers: ensure centered (flex)
  const openOverlay  = window.openOverlay  || ((ov)=>{ ov.style.display='flex'; ov.setAttribute('data-open','true'); });
  const closeOverlay = window.closeOverlay || ((ov)=>{ ov.style.display='none';  ov.removeAttribute('data-open'); });

  function openModal() {
    if (!inpFieldIndex.value || Number(inpFieldIndex.value) < 1) inpFieldIndex.value = '1';
    openOverlay(modal);
    setTimeout(()=>{ inpFieldIndex?.focus(); inpFieldIndex?.select?.(); }, 0);
    document.querySelectorAll('.appmenu.show,.appmenu-field.show').forEach(m => m.classList.remove('show'));
  }

  // ===== Tuple helpers (use app’s robust parser if present) =====
  const H = window.DupHelpers || {};
  const parseTuple = H.parseSqlTupleLine || null;

  const toSqlString = (val) => `'${String(val).replace(/'/g,"''")}'`; // '' escape apostrophes

  // ===== Current set detection: block of non-blank lines around caret =====
  function currentSetRange(){
    const text = ta.value.replace(/\r/g,'');
    const lines = text.split('\n');
    const caret = ta.selectionStart || 0;
    const caretLine = text.slice(0, caret).split('\n').length - 1;

    let start = caretLine, end = caretLine;
    while (start > 0 && lines[start-1]?.trim() !== '') start--;
    while (end   < lines.length-1 && lines[end+1]?.trim() !== '') end++;
    return { text, lines, start, end };
  }

  // Render one copy of the set with field (1-based) replaced by value across every tuple
  function renderCopyWithValue(lines, start, end, field1, value){
    const idx0 = field1 - 1;
    const out = [];
    for (let i = start; i <= end; i++){
      const line = lines[i];
      if (!parseTuple) { out.push(line); continue; }
      const p = parseTuple(line);
      if (!p || !p.ok) { out.push(line); continue; }
      if (idx0 < 0 || idx0 >= p.fields.length) { out.push(line); continue; }

      // Always write a SQL string literal (consistent with tool’s intent)
      p.fields[idx0] = toSqlString(value);
      out.push(p.reconstructed(p.fields));
    }
    return out;
  }

  // Append N copies to end of document
  function appendCopies(items, field1, sepBlank){
    const { lines, start, end } = currentSetRange();
    if (start > end) return false;

    const parts = [];
    for (let k = 0; k < items.length; k++){
      const block = renderCopyWithValue(lines, start, end, field1, items[k]);
      if (block.length) parts.push(block.join('\n'));
      if (sepBlank && k < items.length - 1) parts.push(''); // blank line between copies
    }
    if (!parts.length) return false;

    // append to end of document; ensure a single trailing newline
    const base = ta.value.replace(/\r/g,'').replace(/\s*$/, '');
    ta.value = (base ? base + '\n' : '') + parts.join('\n') + '\n';

    try { window.pushSnapshot?.(); } catch {}
    try { window.updateRowsCountPill?.(); } catch {}
    ta.focus();
    ta.setSelectionRange(ta.value.length, ta.value.length);
    return true;
  }

  // ===== Board tokenization: CSV *or* lines/whitespace; respects quotes/double-quotes =====
 function parseBoardItems(src){
  // One item per line; keep commas and everything else verbatim
  return String(src || '')
    .replace(/\r/g, '')
    .split('\n')
    .map(s => s.trim())
    .filter(s => s.length > 0);
}

  function parseLinesList(src){
    return String(src || '').replace(/\r/g,'').split('\n').map(v => v.trim()).filter(v => v.length > 0);
  }

  // ===== Handlers =====
  function getFieldIndex(){
    const v = Math.floor(Number((inpFieldIndex.value || '1').trim()));
    return (Number.isFinite(v) && v >= 1) ? v : 1;
  }

  function applyFromBoard(){
    const field1 = getFieldIndex();
    const sepBlank = !!(chkSepBlank && chkSepBlank.checked);
    const content = board ? board.value : '';
    const items = parseBoardItems(content);
    if (!items.length){ alert('Copy Board is empty.'); return; }
    const ok = appendCopies(items, field1, sepBlank);
    if (!ok) alert('No tuples were changed (check the field index and current set).');
  }

  function applyFromLines(){
    const field1 = getFieldIndex();
    const sepBlank = !!(chkSepBlank && chkSepBlank.checked);
    const items = parseLinesList(txtLines ? txtLines.value : '');
    if (!items.length){ alert('Provide one item per line.'); return; }
    const ok = appendCopies(items, field1, sepBlank);
    if (!ok) alert('No tuples were changed (check the field index and current set).');
  }

  // ===== Wire =====
  function wireOnce(el, evt, fn){ if (!el || el._wired) return; el._wired = true; el.addEventListener(evt, fn); }

  wireOnce(mnu,     'click', (e)=>{ e.preventDefault(); openModal(); });
  wireOnce(btnClose,'click', (e)=>{ e.preventDefault(); closeOverlay(modal); ta.focus(); });

  // Backdrop + ESC close
  if (!modal._backdropWired){
    modal._backdropWired = true;
    modal.addEventListener('click', (e)=>{ if (e.target === modal){ closeOverlay(modal); ta.focus(); }});
  }
  if (!modal._escWired){
    modal._escWired = true;
    document.addEventListener('keydown', (e)=>{
      if (e.key !== 'Escape') return;
      const openTop = [...document.querySelectorAll('.overlay[data-open="true"]')].pop();
      if (openTop === modal){ e.preventDefault(); closeOverlay(modal); ta.focus(); }
    });
  }

  // Apply buttons
  wireOnce(btnCB,    'click', (e)=>{ e.preventDefault(); applyFromBoard(); });
  wireOnce(btnLines, 'click', (e)=>{ e.preventDefault(); applyFromLines(); });

  // Bonus: Ctrl/Cmd+Enter inside the one-per-line box
  if (txtLines && !txtLines._wiredEnter){
    txtLines._wiredEnter = true;
    txtLines.addEventListener('keydown', (e)=>{
      if ((e.ctrlKey || e.metaKey) && e.key === 'Enter'){ e.preventDefault(); applyFromLines(); }
    });
  }
})();
</script>
<script id="hotkey-ctrl-shift-v-import-board">
(() => {
  const board = document.getElementById('board');
  const pill  = document.getElementById('countPill');
  const btn   = document.getElementById('importBtn');

  if (!board) return;

  // Minimal CSV→items fallback (keeps your semantics)
  function csvToItems(text){
    const lines = String(text).split(/\r?\n/);
    const out = [];
    for (const raw of lines){
      const s = raw; let buf = ''; let inQ = false;
      for (let i=0;i<s.length;i++){
        const ch = s[i];
        if (inQ){
          if (ch === '"'){ if (s[i+1] === '"'){ buf+='"'; i++; } else { inQ=false; } }
          else buf += ch;
        } else {
          if (ch === '"'){ inQ = true; }
          else if (ch === ','){ out.push(buf.trim()); buf=''; }
          else buf += ch;
        }
      }
      out.push(buf.trim());
    }
    return out.filter(x => x.length>0);
  }

  // Append items to board + keep pill accurate (works with or without array model)
  function writeItemsToBoard(items){
    if (!items?.length) return;
    if (Array.isArray(window.collectedItems)){
      for (const it of items) window.collectedItems.push(it);
      if (typeof window.updateBoardView === 'function') { window.updateBoardView(); }
      else {
        const cur = (board.value ?? '').replace(/\r/g,'');
        const nl  = cur.length && !cur.endsWith('\n') ? '\n' : '';
        board.value = cur + nl + items.join('\n');
      }
    } else {
      const cur = (board.value ?? '').replace(/\r/g,'');
      const nl  = cur.length && !cur.endsWith('\n') ? '\n' : '';
      board.value = cur + nl + items.join('\n');
    }
    try {
      const count = Array.isArray(window.collectedItems)
        ? window.collectedItems.filter(s => String(s).trim().length > 0).length
        : ((board.value ?? '').replace(/\r/g,'').split('\n').filter(s => s.trim().length>0).length);
      if (pill) pill.textContent = `Copy Board: ${count} items`;
    } catch {}
  }

  async function importFromClipboardHotkey(){
    try{
      const text = await navigator.clipboard.readText();
      if (!text) return;

      if (typeof window.pushItemsAuto === 'function'){
        window.pushItemsAuto(text);
        if (typeof window.updateBoardView === 'function') window.updateBoardView();
        // pill will be recomputed below anyway
      } else {
        writeItemsToBoard(csvToItems(text));
      }

      // Ensure pill reflects the latest state (even if pushItemsAuto handled it).
      const count = Array.isArray(window.collectedItems)
        ? window.collectedItems.filter(s => String(s).trim().length > 0).length
        : ((board.value ?? '').replace(/\r/g,'').split('\n').filter(s => s.trim().length>0).length);
      if (pill) pill.textContent = `Copy Board: ${count} items`;
    } catch {
      alert('Clipboard read failed. Make sure the page has clipboard permission.');
    }
  }

  // Ctrl+Shift+V
  document.addEventListener('keydown', (e) => {
    const k = (e.key || '').toLowerCase();
    if (k !== 'v') return;
    if (!(e.ctrlKey || e.metaKey) || !e.shiftKey || e.altKey) return;
    e.preventDefault(); e.stopPropagation();
    importFromClipboardHotkey();
  }, true);

  // (Optional) Wire toolbar “Import Clipboard” to same behavior
  if (btn && !btn._wired){
    btn._wired = true;
    btn.addEventListener('click', (e)=>{ e.preventDefault(); importFromClipboardHotkey(); });
  }
})();
</script>
<script id="hotkey-ctrl-g-unique-token">
(() => {
  const ta = document.getElementById('textArea');
  if (!ta) return;

  // Use your AppSettings first; fall back to defaults.
  function getTokenPrefs() {
    const style = (window.AppSettings?.tokStyle ?? 'alnum');
    const len   = (window.AppSettings?.tokLen   ?? 12);
    return { style, len: Math.max(4, Math.min(64, parseInt(len, 10) || 12)) };
  }

  // Prefer your implementations if available.
  const collect = window.collectExistingTokens || ((text) => {
    // very small fallback: gather single-quoted strings as candidates
    const set = new Set(); const re = /'([^'\\]|\\.|'')*'/g; let m;
    while ((m = re.exec(String(text))) !== null) { set.add(m[0].slice(1,-1).replace(/''/g,"'")); }
    return set;
  });

  const genUnique = window.generateUniqueToken || ((existing, style, len) => {
    const alpha = 'abcdefghijklmnopqrstuvwxyz';
    const ALNUM = alpha + alpha.toUpperCase() + '0123456789';
    const ALPHA = alpha + alpha.toUpperCase();
    const UPPER = alpha.toUpperCase();
    const LOWER = alpha;
    const pool = (style === 'alpha') ? ALPHA : (style === 'upper') ? UPPER : (style === 'lower') ? LOWER : ALNUM;
    function makeToken(n){
      let s=''; for(let i=0;i<n;i++) s += pool[Math.floor(Math.random()*pool.length)];
      return s;
    }
    for (let tries=0; tries<2000; tries++){
      const t = makeToken(len);
      if (!existing.has(t)) { existing.add(t); return t; }
    }
    // worst case: length+1
    for (let i=0;i<2000;i++){
      const t = makeToken(len+1);
      if (!existing.has(t)) { existing.add(t); return t; }
    }
    // absolute last resort
    return (crypto?.randomUUID?.() ?? ('x'+Date.now().toString(36)));
  });

  function insertTokenAtCaret() {
    const { style, len } = getTokenPrefs();
    const existing = collect(ta.value);
    const token    = genUnique(existing, style, len);

    const s = ta.selectionStart ?? 0;
    const e = ta.selectionEnd   ?? s;
    const before = ta.value.slice(0, s);
    const after  = ta.value.slice(e);
    ta.value = before + token + after;

    const pos = before.length + token.length;
    ta.setSelectionRange(pos, pos);
    ta.focus();

    try { window.pushSnapshot?.(); } catch {}
  }

  // Ctrl+G hotkey (no Alt/Meta)
  document.addEventListener('keydown', (e) => {
    const k = (e.key || '').toLowerCase();
    if (k !== 'g') return;
    if (!e.ctrlKey || e.altKey || e.metaKey) return;
    e.preventDefault(); e.stopPropagation();
    if (document.activeElement === ta) insertTokenAtCaret();
  }, true);
})();
</script>
<script id="feature-hotkeys-r-k">
(() => {
  const $ = (id) => document.getElementById(id);
  const ta = $('textArea');
  if (!ta) return;

  // Prefer your robust parser if available
  const parseTuple = (window.DupHelpers?.parseSqlTupleLine) || window.parseSqlTupleLine || null;

  // ---------- Small helpers ----------
  function toSqlString(s){ return `'${String(s).replace(/'/g, "''")}'`; }
  function isQuoted(tok){ return /^\s*'.*'\s*$/.test(String(tok)); }
  function unquote(tok){
    const t = String(tok).trim();
    if (t.startsWith("'") && t.endsWith("'")) return t.slice(1,-1).replace(/''/g,"'");
    return t;
  }
  function numericLike(s){ return /^[+-]?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?$/.test(String(s).trim()); }

  function writeBack(lines, caretPos){
    ta.value = lines.join('\n');
    try { ta.focus(); if (Number.isInteger(caretPos)) ta.setSelectionRange(caretPos, caretPos); } catch {}
    try { window.pushSnapshot?.(); } catch {}
    try { window.updateRowsCountPill?.(); } catch {}
  }

  function caretLineInfo(text, caret){
    const lineStart = text.lastIndexOf('\n', Math.max(0, (caret ?? 0) - 1)) + 1;
    const nl = text.indexOf('\n', lineStart);
    const lineEnd = (nl === -1 ? text.length : nl);
    const lineIdx = text.slice(0, lineStart).split('\n').length - 1;
    return { lineIdx, lineStart, lineEnd };
  }

  // Set bounds = block of non-blank lines around caret line (end is EXCLUSIVE)
  function currentSetBounds(lines, caretLineIdx){
    let start = caretLineIdx;
    let end   = caretLineIdx + 1;
    while (start > 0 && lines[start-1].trim() !== '') start--;
    while (end < lines.length && lines[end].trim() !== '') end++;
    return { start, end };
  }

  // ---------- Tuple scanning (fallback path) ----------
  function findFirstTupleInLine(line){
    let open = -1, depth = 0, inS = false;
    for (let i=0; i<line.length; i++){
      const ch = line[i];
      if (inS){
        if (ch === "\\") { i++; continue; }
        if (ch === "'"){
          const nxt = line[i+1];
          if (nxt === "'"){ i++; continue; } // '' escape
          inS = false;
        }
        continue;
      }
      if (ch === "'"){ inS = true; continue; }
      if (ch === "("){ if (depth===0) open = i; depth++; continue; }
      if (ch === ")"){ depth--; if (depth===0 && open !== -1) return { open, close: i+1, raw: line.slice(open, i+1) }; }
    }
    return null;
  }

  // Split fields inside a single tuple token, tracking spans (start/end indices in the LINE)
  function splitFieldsWithSpans(line, tuple){
    const raw = tuple.raw; // includes ( ... )
    const inner = raw.slice(1, -1);
    const fields = [];
    const spans  = [];
    let buf = "", inS = false, startInner = 0;
    for (let i=0; i<inner.length; i++){
      const ch = inner[i];
      if (inS){
        buf += ch;
        if (ch === "\\"){ if (i+1 < inner.length){ buf += inner[++i]; } continue; }
        if (ch === "'"){
          const nxt = inner[i+1];
          if (nxt === "'"){ buf += nxt; i++; continue; } // doubled apostrophe
          inS = false;
        }
        continue;
      }
      if (ch === "'"){ inS = true; buf += ch; continue; }
      if (ch === ","){
        fields.push(buf);
        const startInLine = tuple.open + 1 + startInner;
        spans.push({ start: startInLine, end: startInLine + buf.length });
        buf = "";
        startInner = i+1; // after comma
        continue;
      }
      buf += ch;
    }
    // last field
    fields.push(buf);
    const startInLine = tuple.open + 1 + startInner;
    spans.push({ start: startInLine, end: startInLine + buf.length });

    // helper to rejoin fields to a tuple
    function joinFields(arr){ return '(' + arr.join(',') + ')'; }

    return { fields, spans, joinFields };
  }

  // ---------- Ctrl+R: remove current line and collapse ----------
  function removeCurrentLine(){
    const text  = ta.value;
    const caret = ta.selectionStart ?? 0;
    const { lineStart, lineEnd } = caretLineInfo(text, caret);
    const before = text.slice(0, lineStart);
    const after  = text.slice(lineEnd + (lineEnd < text.length ? 1 : 0)); // skip the newline if present
    const newCaret = before.length;
    writeBack((before + after).replace(/\r/g,'').split('\n'), newCaret);
  }

  // ---------- Ctrl+K: copy field at caret to same index across CURRENT SET only ----------
  function copyFieldAtCaretToAllRows(){
    const text  = ta.value.replace(/\r/g,'');
    const caret = ta.selectionStart ?? 0;
    const { lineIdx } = caretLineInfo(text, caret);
    const lines = text.split('\n');
    const line  = lines[lineIdx] ?? '';

    // Locate tuple on caret line
    let tupleOnLine = null;
    if (parseTuple){
      // Use fallback just to get raw span quickly
      tupleOnLine = findFirstTupleInLine(line);
    } else {
      tupleOnLine = findFirstTupleInLine(line);
    }
    if (!tupleOnLine) return;

    // Determine which field index caret is in
    const { fields, spans, joinFields } = splitFieldsWithSpans(line, tupleOnLine);
    if (!fields.length) return;

    let targetFieldIndex = -1;
    for (let i=0; i<spans.length; i++){
      const sp = spans[i];
      if (caret >= sp.start && caret <= sp.end){ targetFieldIndex = i; break; }
    }
    if (targetFieldIndex === -1){
      // choose nearest field if caret sits exactly on a comma, etc.
      let best=-1, dist=Infinity;
      for (let i=0;i<spans.length;i++){
        const sp=spans[i];
        const d = (caret < sp.start) ? sp.start - caret : (caret > sp.end ? caret - sp.end : 0);
        if (d < dist){ dist = d; best = i; }
      }
      targetFieldIndex = best;
    }
    if (targetFieldIndex === -1) return;

    // Decide token to copy (number: unquoted; string: single-quoted with escaping)
    const sourceTok = fields[targetFieldIndex];
    const core = unquote(sourceTok).trim();
    const isNum = numericLike(core);
    const writeToken = isNum ? String(Number(core)) : toSqlString(core);

    // Limit to the CURRENT SET ONLY
    const { start, end } = currentSetBounds(lines, lineIdx); // end is exclusive

    // Apply within the set
    for (let li = start; li < end; li++){
      const L = lines[li];
      if (!L || !L.includes('(')) continue;

      if (parseTuple){
        const p = parseTuple(L);
        if (!p || !p.ok || !p.fields || targetFieldIndex >= p.fields.length) continue;
        const copy = p.fields.slice();
        copy[targetFieldIndex] = writeToken;
        const rebuilt = p.reconstructed(copy);
        if (rebuilt !== L) lines[li] = rebuilt;
      } else {
        const t = findFirstTupleInLine(L);
        if (!t) continue;
        const sf = splitFieldsWithSpans(L, t);
        if (targetFieldIndex < 0 || targetFieldIndex >= sf.fields.length) continue;
        const copy = sf.fields.slice();
        copy[targetFieldIndex] = writeToken;
        const rebuilt = L.slice(0, t.open) + sf.joinFields(copy) + L.slice(t.close);
        if (rebuilt !== L) lines[li] = rebuilt;
      }
    }

    // Keep caret stable at original position if possible
    const beforeLen = lines.slice(0, lineIdx).join('\n').length + (lineIdx ? 1 : 0);
    const caretInLine = Math.min(Math.max(0, caret - beforeLen), (lines[lineIdx]||'').length);
    const newCaret = beforeLen + caretInLine;

    writeBack(lines, newCaret);
  }

  // ---------- Hotkey wiring ----------
  function onKeyDown(e){
    const k = (e.key || '').toLowerCase();
    const cmdOrCtrl = e.ctrlKey || e.metaKey;
    if (!cmdOrCtrl) return;
    if (document.activeElement !== ta) return;

    if (k === 'r'){
      e.preventDefault();
      removeCurrentLine();
      return;
    }
    if (k === 'k'){
      e.preventDefault();
      copyFieldAtCaretToAllRows(); // now scoped to current set only
      return;
    }
  }

  if (!ta._hotkeysRK){
    ta._hotkeysRK = true;
    document.addEventListener('keydown', onKeyDown);
  }
})();
</script>
<script id="hotkey-undo-redo-snapshots">
(() => {
  const ta = document.getElementById('textArea');
  if (!ta) return;

  const MAX = 20;
  let stack = [];    // [{value, selStart, selEnd, scrollTop}]
  let idx   = -1;    // points at current state in stack
  let lastPushedValue = null;
  let debounceTimer = null;

  function snapshotFromTextarea() {
    return {
      value: ta.value,
      selStart: ta.selectionStart ?? 0,
      selEnd: ta.selectionEnd ?? 0,
      scrollTop: ta.scrollTop ?? 0
    };
  }

  function applySnapshot(s) {
    if (!s) return;
    const was = ta.scrollTop;
    ta.value = s.value;
    try {
      ta.setSelectionRange(s.selStart, s.selEnd);
    } catch {}
    // restore scroll (set twice to be safe after layout)
    ta.scrollTop = s.scrollTop ?? was;
    setTimeout(() => { ta.scrollTop = s.scrollTop ?? was; }, 0);
  }

  function pushSnapshotInternal(snap) {
    // If we’re somewhere in the middle (after undos), drop the redo branch
    if (idx < stack.length - 1) stack = stack.slice(0, idx + 1);
    // Skip identical doc text to avoid spam
    if (lastPushedValue === snap.value) return;

    stack.push(snap);
    if (stack.length > MAX) stack.shift();
    idx = stack.length - 1;
    lastPushedValue = snap.value;
  }

  function pushSnapshot() {
    pushSnapshotInternal(snapshotFromTextarea());
  }

  function pushSnapshotDebounced() {
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(pushSnapshot, 200);
  }

  function canUndo() { return idx > 0; }
  function canRedo() { return idx >= 0 && idx < stack.length - 1; }

  function undo() {
    if (!canUndo()) return;
    idx--;
    const s = stack[idx];
    applySnapshot(s);
    lastPushedValue = s.value;
  }

  function redo() {
    if (!canRedo()) return;
    idx++;
    const s = stack[idx];
    applySnapshot(s);
    lastPushedValue = s.value;
  }

  // Public API for other scripts
  window.pushSnapshot = pushSnapshot;
  window.undoDocument = undo;
  window.redoDocument = redo;

  // Initialize with the current content so first undo returns to initial state
  function init() {
    pushSnapshotInternal(snapshotFromTextarea());
  }

  // Capture snapshots on typical edit flows
  // 1) After user edits (debounced, to coalesce bursts)
  ta.addEventListener('input', pushSnapshotDebounced);

  // 2) On blur (safety net)
  ta.addEventListener('blur', () => { pushSnapshot(); });

  // 3) On paste/cut we push AFTER the operation (input will fire), but
  //    we also ensure a snapshot is present in case the browser coalesces.
  ta.addEventListener('paste', () => { setTimeout(pushSnapshot, 0); });
  ta.addEventListener('cut',   () => { setTimeout(pushSnapshot, 0); });

  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    const k = (e.key || '').toLowerCase();
    const isMac = /mac/i.test(navigator.platform);
    const mod = isMac ? e.metaKey : e.ctrlKey;

    // Ctrl/Cmd + Z  (with/without Shift)
    if (k === 'z' && mod && !e.altKey) {
      e.preventDefault(); e.stopPropagation();
      if (e.shiftKey) redo(); else undo();
      return;
    }
    // Ctrl/Cmd + Y  (redo)
    if (k === 'y' && mod && !e.altKey && !e.shiftKey) {
      e.preventDefault(); e.stopPropagation();
      redo();
      return;
    }
  }, true);

  // First paint init
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init, { once: true });
  } else {
    init();
  }
})();
</script>
<script id="feature-duplicate-token-report">
(() => {
  // ------- Utilities (reuse if present, otherwise fallback) -------
  const textArea = document.getElementById('textArea') || document.querySelector('textarea');

  // Use your smart tuple scanner if available; otherwise fallback (quote + backslash aware)
  const findAllTuplesInLineSmart = (typeof window.findAllTuplesInLineSmart === 'function')
    ? window.findAllTuplesInLineSmart
    : function fallbackFind(line){
        const tuples = [];
        let inQ = false, depth = 0, open = -1;
        for (let i = 0; i < line.length; i++){
          const ch = line[i];
          if (inQ){
            if (ch === "\\") { i++; continue; }
            if (ch === "'"){
              if (line[i+1] === "'"){ i++; } else { inQ = false; }
            }
            continue;
          }
          if (ch === "'"){ inQ = true; continue; }
          if (ch === "("){ if (depth === 0) open = i; depth++; continue; }
          if (ch === ")"){
            depth--;
            if (depth === 0 && open >= 0){
              tuples.push({ open, close: i + 1, raw: line.slice(open, i + 1) });
              open = -1;
            }
          }
        }
        return tuples;
      };

  // Get the last field’s absolute range within a tuple raw "( ... )"
  function getLastFieldRange(tupleRaw){
    // find the '(' that starts this tuple (ignore whitespace before it)
    let firstParen = tupleRaw.indexOf('(');
    if (firstParen === -1) return { start: 0, end: 0 };

    // scan inside (…) to find comma boundaries, respecting quotes and backslashes
    let s = tupleRaw;
    let i = firstParen + 1;
    let inStr = false;
    let lastStart = i;
    for (; i < s.length; i++){
      const ch = s[i];
      if (inStr){
        if (ch === "\\"){ i++; continue; }
        if (ch === "'"){
          if (s[i+1] === "'"){ i++; } else { inStr = false; }
        }
        continue;
      }
      if (ch === "'"){ inStr = true; continue; }
      if (ch === ","){ lastStart = i + 1; continue; }
      if (ch === ")"){ break; }
    }
    const leadingSpaces = (s.slice(lastStart).match(/^\s*/)||[''])[0].length;
    let start = lastStart + leadingSpaces;
    // end is just before ')', trimming trailing spaces
    let end = s.lastIndexOf(')');
    let e = end - 1;
    while (e >= 0 && /\s/.test(s[e])) e--;
    end = e + 1;
    return { start, end };
  }

  // Extract normalized end-token value from a tuple raw
  function getLastFieldValue(tupleRaw){
    const { start, end } = getLastFieldRange(tupleRaw);
    const raw = tupleRaw.slice(start, end).trim();
    // If quoted: unquote and collapse doubled single quotes; leave backslashes as typed
    if (raw.startsWith("'") && raw.endsWith("'")){
      const inner = raw.slice(1, -1).replace(/''/g, "'");
      return inner.trim();
    }
    return raw;
  }

  // ------- Modal creation / references -------
  let dupesModal, dupesList, dupesCountEl, dupesCloseBtn, dupesCopyAllBtn, dupesSearch;

  function ensureModal(){
    dupesModal = document.getElementById('dupes-modal');
    if (!dupesModal){
      const wrap = document.createElement('div');
      wrap.id = 'dupes-modal';
      wrap.style.cssText = `
        position:fixed; inset:0; display:none; align-items:center; justify-content:center;
        background:rgba(0,0,0,.35); z-index:9999;
      `;
      wrap.innerHTML = `
        <div style="background:#fff; width:min(900px, 92vw); max-height:80vh; border-radius:12px; box-shadow:0 12px 40px rgba(0,0,0,.25); display:flex; flex-direction:column; overflow:hidden;">
          <div style="display:flex; align-items:center; gap:12px; padding:12px 14px; border-bottom:1px solid #eee;">
            <strong id="dupesHeader" style="font-size:15px;">Duplicate end tokens</strong>
            <span style="opacity:.6">•</span>
            <span id="dupesCount" style="opacity:.85"></span>
            <input id="dupesSearch" type="search" placeholder="Filter…" style="margin-left:auto; width:220px; padding:6px 8px; border:1px solid #ddd; border-radius:8px;">
            <button id="dupesCopyAllBtn" style="padding:6px 10px; border-radius:8px; border:1px solid #ddd; background:#f9f9f9;">Copy all</button>
            <button id="dupesCloseBtn" style="padding:6px 10px; border-radius:8px; border:1px solid #ddd; background:#fafafa;">Close</button>
          </div>
          <div id="dupesListWrap" style="overflow:auto;">
            <div id="dupesList" style="padding:10px 0;"></div>
          </div>
        </div>
      `;
      document.body.appendChild(wrap);
    }
    // refs
    dupesModal       = document.getElementById('dupes-modal');
    dupesList        = document.getElementById('dupesList');
    dupesCountEl     = document.getElementById('dupesCount');
    dupesCloseBtn    = document.getElementById('dupesCloseBtn');
    dupesCopyAllBtn  = document.getElementById('dupesCopyAllBtn');
    dupesSearch      = document.getElementById('dupesSearch');

    // wire once
    if (!dupesModal.dataset.wired){
      dupesModal.dataset.wired = '1';
      dupesCloseBtn.addEventListener('click', closeDupesModal);
      dupesModal.addEventListener('click', e => { if (e.target === dupesModal) closeDupesModal(); });
      dupesSearch.addEventListener('input', () => renderDupesList(dupesSearch.value));
      dupesCopyAllBtn.addEventListener('click', () => {
        const all = collectDuplicateEndTokens().map(([t]) => t).join('\n');
        if (all) navigator.clipboard.writeText(all).catch(()=>{});
      });
      document.addEventListener('keydown', (e) => {
        if (dupesModal.style.display === 'flex' && e.key === 'Escape') { e.preventDefault(); closeDupesModal(); }
      });
    }
  }

  // ------- Core collection + render -------
  function collectDuplicateEndTokens(){
    const counts = new Map();
    const lines = (textArea?.value || '').split(/\r?\n/);
    for (const line of lines){
      if (!line.trim()) continue;
      const tuples = findAllTuplesInLineSmart(line);
      for (const t of tuples){
        const val = getLastFieldValue(t.raw);
        if (val === '') continue; // ignore empty ''
        counts.set(val, (counts.get(val) || 0) + 1);
      }
    }
    const dupes = [];
    counts.forEach((c, k) => { if (c >= 2) dupes.push([k, c]); });
    dupes.sort((a,b) => b[1] - a[1] || a[0].localeCompare(b[0]));
    return dupes;
  }

  function renderDupesList(filterText = ''){
    const dupes = collectDuplicateEndTokens();
    const filtered = filterText
      ? dupes.filter(([tok]) => tok.toLowerCase().includes(filterText.toLowerCase()))
      : dupes;

    dupesCountEl.textContent = `${dupes.length} token${dupes.length===1?'':'s'} duplicated`;

    const frag = document.createDocumentFragment();
    if (!filtered.length){
      const empty = document.createElement('div');
      empty.style.cssText = 'padding:14px 16px; opacity:.65;';
      empty.textContent = 'No duplicate end tokens found.';
      frag.appendChild(empty);
    } else {
      for (const [token, count] of filtered){
        const row = document.createElement('div');
        row.style.cssText = 'display:flex; align-items:center; gap:10px; padding:8px 14px; border-bottom:1px solid #f0f0f0;';
        const label = document.createElement('code');
        label.style.cssText = 'font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; font-size:12px;';
        label.textContent = token;
        const meta = document.createElement('span');
        meta.style.cssText = 'margin-left:auto; opacity:.7;';
        meta.textContent = `×${count}`;
        const copyBtn = document.createElement('button');
        copyBtn.className = 'dupeBtn';
        copyBtn.setAttribute('data-copy', token);
        copyBtn.textContent = 'Copy';
        copyBtn.style.cssText = 'padding:4px 8px; border:1px solid #ddd; border-radius:6px; background:#fafafa;';
        copyBtn.addEventListener('click', () => navigator.clipboard.writeText(token).catch(()=>{}));
        row.appendChild(label);
        row.appendChild(meta);
        row.appendChild(copyBtn);
        frag.appendChild(row);
      }
    }
    dupesList.innerHTML = '';
    dupesList.appendChild(frag);
  }

  function openDupesModal(){
    ensureModal();
    renderDupesList('');
    dupesSearch.value = '';
    dupesModal.style.display = 'flex';
    setTimeout(() => dupesSearch.focus(), 0);
  }
  function closeDupesModal(){
    dupesModal && (dupesModal.style.display = 'none');
  }

  // ------- Hotkey: Ctrl+Shift+E -------
  if (textArea){
    textArea.addEventListener('keydown', (e) => {
      const key = String(e.key).toLowerCase();
      if ((e.ctrlKey || e.metaKey) && e.shiftKey && key === 'e'){
        e.preventDefault();
        e.stopPropagation();
        openDupesModal();
      }
    }, true);
  }

  // Expose (optional)
  window.openDupesModal  = openDupesModal;
  window.closeDupesModal = closeDupesModal;
})();
</script>
<script id="settings-core">
(function(){
  const K = {
    dupClearLast: "dup.clearLastField",
    tokReplaceAll: "tok.replaceAll",     // mirrors #tokenizerReplaceAll
    tokStyle: "tok.style",               // 'alnum' | 'alpha' | 'upper' | 'lower'
    tokLen: "tok.len"                    // integer 4..64
  };

  function loadBool(key, def=false){ try { const v = localStorage.getItem(key); return v === null ? def : v === "1"; } catch(_) { return def; } }
  function saveBool(key, val){ try { localStorage.setItem(key, val ? "1":"0"); } catch(_) {} }
  function loadStr(key, def=""){ try { const v = localStorage.getItem(key); return v === null ? def : v; } catch(_) { return def; } }
  function saveStr(key, val){ try { localStorage.setItem(key, String(val)); } catch(_) {} }

  // --- Duplicate setting
  const cbDup = document.getElementById("clearLastField");
  if (cbDup){
    cbDup.checked = loadBool(K.dupClearLast, cbDup.checked || false);
    cbDup.addEventListener("change", ()=> saveBool(K.dupClearLast, cbDup.checked));
  }

  // --- Tokenizer: replace all last fields (not just empty)
  const cbAll = document.getElementById("tokenizerReplaceAll");
  if (cbAll){
    cbAll.checked = loadBool(K.tokReplaceAll, cbAll.checked || false);
    cbAll.addEventListener("change", ()=> saveBool(K.tokReplaceAll, cbAll.checked));
  }

  // --- Token style + length
  const selStyle = document.getElementById("tokenStyle");
  const lenInput = document.getElementById("tokenLength");

  if (selStyle){
    const saved = loadStr(K.tokStyle, selStyle.value || "alnum");
    if ([...selStyle.options].some(o=>o.value===saved)) selStyle.value = saved;
    selStyle.addEventListener("change", ()=> saveStr(K.tokStyle, selStyle.value));
  }
  if (lenInput){
    const savedLen = parseInt(loadStr(K.tokLen, String(lenInput.value || 12)), 10);
    if (!Number.isNaN(savedLen)) lenInput.value = savedLen;
    lenInput.addEventListener("change", ()=>{
      const v = Math.max(4, Math.min(64, parseInt(lenInput.value || "12", 10)));
      lenInput.value = v;
      saveStr(K.tokLen, v);
    });
  }

  // Expose a tiny API
  window.AppSettings = {
    get dupClearLast(){ return cbDup ? cbDup.checked : loadBool(K.dupClearLast, false); },
    get tokReplaceAll(){ return cbAll ? cbAll.checked : loadBool(K.tokReplaceAll, false); },
    get tokStyle(){ return selStyle ? selStyle.value : loadStr(K.tokStyle, "alnum"); },
    get tokLen(){ return lenInput ? parseInt(lenInput.value || "12", 10) : parseInt(loadStr(K.tokLen, "12"), 10) }
  };
})();
</script>
<script id="feature-settings">
(() => {
  const $ = (id) => document.getElementById(id);

  // UI
  const settingsBtn     = $('settingsBtn');         // toolbar button
  const settingsModal   = $('settings-modal');      // modal overlay
  const themeSelect     = $('themeSelect');         // "Light" | "Dark"
  const settingsClose   = $('settingsCloseBtn');    // Done

  // Optional: if you add a menu item later (e.g. #mnuSettings), we’ll catch it too.
  const mnuSettings = document.getElementById('mnuSettings') 
                   || document.querySelector('[data-menu="settings"], [data-action="settings"]');

  // Helpers from your file (already defined)
  const applyTheme  = window.applyTheme || ((t)=>document.body.setAttribute('data-theme',t));
  const saveSettings= window.saveSettings || ((s)=>{ try{ localStorage.setItem('sqlFieldDump.settings', JSON.stringify(s)); }catch{} });
  const loadSettings= window.loadSettings || (()=>({ theme:'light' }));
  // Live settings object (already created in your file)
  const SETTINGS = window.SETTINGS || loadSettings();

  function openOverlay(ov){
    ov.style.display = 'flex';
    ov.setAttribute('data-open','true');
  }
  function closeOverlay(ov){
    ov.style.display = 'none';
    ov.removeAttribute('data-open');
  }

  function syncControlsFromSettings(){
    if (themeSelect) themeSelect.value = (SETTINGS.theme || document.body.getAttribute('data-theme') || 'light');
  }

  function syncSettingsFromControls(){
    if (themeSelect){
      const t = themeSelect.value === 'dark' ? 'dark' : 'light';
      SETTINGS.theme = t;
      applyTheme(t);
      // keep legacy key in sync if you use it elsewhere
      try { localStorage.setItem('sqlFieldDump.theme', t); } catch {}
    }
    saveSettings(SETTINGS);
  }

  function openSettings(){
    syncControlsFromSettings();
    openOverlay(settingsModal);
    setTimeout(()=> themeSelect?.focus(), 0);
    // close any open app menus so the overlay isn't obstructed
    document.querySelectorAll('.appmenu.show, .appmenu-field.show').forEach(m => m.classList.remove('show'));
  }

  // Wire open buttons
  if (settingsBtn && !settingsBtn._wired){
    settingsBtn._wired = true;
    settingsBtn.addEventListener('click', (e)=>{ e.preventDefault(); openSettings(); });
  }
  if (mnuSettings && !mnuSettings._wired){
    mnuSettings._wired = true;
    mnuSettings.addEventListener('click', (e)=>{ e.preventDefault(); openSettings(); });
  }

  // Live-apply theme on change
  if (themeSelect && !themeSelect._wired){
    themeSelect._wired = true;
    themeSelect.addEventListener('change', ()=> {
      syncSettingsFromControls();
    });
  }

  // Close
  if (settingsClose && !settingsClose._wired){
    settingsClose._wired = true;
    settingsClose.addEventListener('click', (e)=>{ e.preventDefault(); syncSettingsFromControls(); closeOverlay(settingsModal); });
  }

  // Backdrop click to close
  if (settingsModal && !settingsModal._backdropWired){
    settingsModal._backdropWired = true;
    settingsModal.addEventListener('click', (e)=>{ if (e.target === settingsModal){ syncSettingsFromControls(); closeOverlay(settingsModal); }});
  }

  // ESC to close (topmost only)
  if (!document._settingsEscWired){
    document._settingsEscWired = true;
    document.addEventListener('keydown', (e)=>{
      if (e.key !== 'Escape') return;
      const openTop = [...document.querySelectorAll('.overlay[data-open="true"]')].pop();
      if (openTop === settingsModal){
        e.preventDefault();
        syncSettingsFromControls();
        closeOverlay(settingsModal);
      }
    });
  }

  // On load, ensure themeSelect matches applied theme
  syncControlsFromSettings();
})();
</script>
</body>
</html>
